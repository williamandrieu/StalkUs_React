{"ast":null,"code":"!function (t, e) {\n  \"object\" == typeof exports && \"undefined\" != typeof module ? e(require(\"@firebase/app\")) : \"function\" == typeof define && define.amd ? define([\"@firebase/app\"], e) : e((t = t || self).firebase);\n}(this, function (sc) {\n  \"use strict\";\n\n  try {\n    (function () {\n      var o, t;\n      sc = sc && sc.hasOwnProperty(\"default\") ? sc.default : sc, (t = o || (o = {}))[t.DEBUG = 0] = \"DEBUG\", t[t.VERBOSE = 1] = \"VERBOSE\", t[t.INFO = 2] = \"INFO\", t[t.WARN = 3] = \"WARN\", t[t.ERROR = 4] = \"ERROR\", t[t.SILENT = 5] = \"SILENT\";\n\n      var e = o.INFO,\n          n = function n(t, e) {\n        for (var n = [], r = 2; r < arguments.length; r++) {\n          n[r - 2] = arguments[r];\n        }\n\n        if (!(e < t.logLevel)) {\n          var i = new Date().toISOString();\n\n          switch (e) {\n            case o.DEBUG:\n            case o.VERBOSE:\n              console.log.apply(console, [\"[\" + i + \"]  \" + t.name + \":\"].concat(n));\n              break;\n\n            case o.INFO:\n              console.info.apply(console, [\"[\" + i + \"]  \" + t.name + \":\"].concat(n));\n              break;\n\n            case o.WARN:\n              console.warn.apply(console, [\"[\" + i + \"]  \" + t.name + \":\"].concat(n));\n              break;\n\n            case o.ERROR:\n              console.error.apply(console, [\"[\" + i + \"]  \" + t.name + \":\"].concat(n));\n              break;\n\n            default:\n              throw new Error(\"Attempted to log a message with an invalid logType (value: \" + e + \")\");\n          }\n        }\n      },\n          r = function () {\n        function t(t) {\n          this.name = t, this._logLevel = e, this._logHandler = n;\n        }\n\n        return Object.defineProperty(t.prototype, \"logLevel\", {\n          get: function get() {\n            return this._logLevel;\n          },\n          set: function set(t) {\n            if (!(t in o)) throw new TypeError(\"Invalid value assigned to `logLevel`\");\n            this._logLevel = t;\n          },\n          enumerable: !0,\n          configurable: !0\n        }), Object.defineProperty(t.prototype, \"logHandler\", {\n          get: function get() {\n            return this._logHandler;\n          },\n          set: function set(t) {\n            if (\"function\" != typeof t) throw new TypeError(\"Value assigned to `logHandler` must be a function\");\n            this._logHandler = t;\n          },\n          enumerable: !0,\n          configurable: !0\n        }), t.prototype.debug = function () {\n          for (var t = [], e = 0; e < arguments.length; e++) {\n            t[e] = arguments[e];\n          }\n\n          this._logHandler.apply(this, [this, o.DEBUG].concat(t));\n        }, t.prototype.log = function () {\n          for (var t = [], e = 0; e < arguments.length; e++) {\n            t[e] = arguments[e];\n          }\n\n          this._logHandler.apply(this, [this, o.VERBOSE].concat(t));\n        }, t.prototype.info = function () {\n          for (var t = [], e = 0; e < arguments.length; e++) {\n            t[e] = arguments[e];\n          }\n\n          this._logHandler.apply(this, [this, o.INFO].concat(t));\n        }, t.prototype.warn = function () {\n          for (var t = [], e = 0; e < arguments.length; e++) {\n            t[e] = arguments[e];\n          }\n\n          this._logHandler.apply(this, [this, o.WARN].concat(t));\n        }, t.prototype.error = function () {\n          for (var t = [], e = 0; e < arguments.length; e++) {\n            t[e] = arguments[e];\n          }\n\n          this._logHandler.apply(this, [this, o.ERROR].concat(t));\n        }, t;\n      }(),\n          _i2 = function i(t, e) {\n        return (_i2 = Object.setPrototypeOf || {\n          __proto__: []\n        } instanceof Array && function (t, e) {\n          t.__proto__ = e;\n        } || function (t, e) {\n          for (var n in e) {\n            e.hasOwnProperty(n) && (t[n] = e[n]);\n          }\n        })(t, e);\n      };\n\n      function a(t, e) {\n        function n() {\n          this.constructor = t;\n        }\n\n        _i2(t, e), t.prototype = null === e ? Object.create(e) : (n.prototype = e.prototype, new n());\n      }\n\n      function h(o, s, a, u) {\n        return new (a || (a = Promise))(function (t, e) {\n          function n(t) {\n            try {\n              i(u.next(t));\n            } catch (t) {\n              e(t);\n            }\n          }\n\n          function r(t) {\n            try {\n              i(u.throw(t));\n            } catch (t) {\n              e(t);\n            }\n          }\n\n          function i(e) {\n            e.done ? t(e.value) : new a(function (t) {\n              t(e.value);\n            }).then(n, r);\n          }\n\n          i((u = u.apply(o, s || [])).next());\n        });\n      }\n\n      function p(n, r) {\n        var i,\n            o,\n            s,\n            t,\n            a = {\n          label: 0,\n          sent: function sent() {\n            if (1 & s[0]) throw s[1];\n            return s[1];\n          },\n          trys: [],\n          ops: []\n        };\n        return t = {\n          next: e(0),\n          throw: e(1),\n          return: e(2)\n        }, \"function\" == typeof Symbol && (t[Symbol.iterator] = function () {\n          return this;\n        }), t;\n\n        function e(e) {\n          return function (t) {\n            return function (e) {\n              if (i) throw new TypeError(\"Generator is already executing.\");\n\n              for (; a;) {\n                try {\n                  if (i = 1, o && (s = 2 & e[0] ? o.return : e[0] ? o.throw || ((s = o.return) && s.call(o), 0) : o.next) && !(s = s.call(o, e[1])).done) return s;\n\n                  switch (o = 0, s && (e = [2 & e[0], s.value]), e[0]) {\n                    case 0:\n                    case 1:\n                      s = e;\n                      break;\n\n                    case 4:\n                      return a.label++, {\n                        value: e[1],\n                        done: !1\n                      };\n\n                    case 5:\n                      a.label++, o = e[1], e = [0];\n                      continue;\n\n                    case 7:\n                      e = a.ops.pop(), a.trys.pop();\n                      continue;\n\n                    default:\n                      if (!(s = 0 < (s = a.trys).length && s[s.length - 1]) && (6 === e[0] || 2 === e[0])) {\n                        a = 0;\n                        continue;\n                      }\n\n                      if (3 === e[0] && (!s || e[1] > s[0] && e[1] < s[3])) {\n                        a.label = e[1];\n                        break;\n                      }\n\n                      if (6 === e[0] && a.label < s[1]) {\n                        a.label = s[1], s = e;\n                        break;\n                      }\n\n                      if (s && a.label < s[2]) {\n                        a.label = s[2], a.ops.push(e);\n                        break;\n                      }\n\n                      s[2] && a.ops.pop(), a.trys.pop();\n                      continue;\n                  }\n\n                  e = r.call(n, a);\n                } catch (t) {\n                  e = [6, t], o = 0;\n                } finally {\n                  i = s = 0;\n                }\n              }\n\n              if (5 & e[0]) throw e[1];\n              return {\n                value: e[0] ? e[1] : void 0,\n                done: !0\n              };\n            }([e, t]);\n          };\n        }\n      }\n\n      var s,\n          u = \"undefined\" != typeof window ? window : \"undefined\" != typeof global ? global : \"undefined\" != typeof self ? self : {},\n          c = c || {},\n          l = u;\n\n      function f(t) {\n        return \"string\" == typeof t;\n      }\n\n      function d(t, e) {\n        t = t.split(\".\"), e = e || l;\n\n        for (var n = 0; n < t.length; n++) {\n          if (null == (e = e[t[n]])) return null;\n        }\n\n        return e;\n      }\n\n      function m() {}\n\n      function y(t) {\n        var e = typeof t;\n\n        if (\"object\" == e) {\n          if (!t) return \"null\";\n          if (t instanceof Array) return \"array\";\n          if (t instanceof Object) return e;\n          var n = Object.prototype.toString.call(t);\n          if (\"[object Window]\" == n) return \"object\";\n          if (\"[object Array]\" == n || \"number\" == typeof t.length && void 0 !== t.splice && void 0 !== t.propertyIsEnumerable && !t.propertyIsEnumerable(\"splice\")) return \"array\";\n          if (\"[object Function]\" == n || void 0 !== t.call && void 0 !== t.propertyIsEnumerable && !t.propertyIsEnumerable(\"call\")) return \"function\";\n        } else if (\"function\" == e && void 0 === t.call) return \"object\";\n\n        return e;\n      }\n\n      function g(t) {\n        return \"array\" == y(t);\n      }\n\n      function v(t) {\n        var e = y(t);\n        return \"array\" == e || \"object\" == e && \"number\" == typeof t.length;\n      }\n\n      function b(t) {\n        var e = typeof t;\n        return \"object\" == e && null != t || \"function\" == e;\n      }\n\n      var w = \"closure_uid_\" + (1e9 * Math.random() >>> 0),\n          E = 0;\n\n      function S(t, e, n) {\n        return t.call.apply(t.bind, arguments);\n      }\n\n      function T(e, n, t) {\n        if (!e) throw Error();\n\n        if (2 < arguments.length) {\n          var r = Array.prototype.slice.call(arguments, 2);\n          return function () {\n            var t = Array.prototype.slice.call(arguments);\n            return Array.prototype.unshift.apply(t, r), e.apply(n, t);\n          };\n        }\n\n        return function () {\n          return e.apply(n, arguments);\n        };\n      }\n\n      function I(t, e, n) {\n        return (I = Function.prototype.bind && -1 != Function.prototype.bind.toString().indexOf(\"native code\") ? S : T).apply(null, arguments);\n      }\n\n      function C(e, t) {\n        var n = Array.prototype.slice.call(arguments, 1);\n        return function () {\n          var t = n.slice();\n          return t.push.apply(t, arguments), e.apply(this, t);\n        };\n      }\n\n      var D = Date.now || function () {\n        return +new Date();\n      };\n\n      function N(t, o) {\n        function e() {}\n\n        e.prototype = o.prototype, t.S = o.prototype, t.prototype = new e(), (t.prototype.constructor = t).re = function (t, e, n) {\n          for (var r = Array(arguments.length - 2), i = 2; i < arguments.length; i++) {\n            r[i - 2] = arguments[i];\n          }\n\n          return o.prototype[e].apply(t, r);\n        };\n      }\n\n      function A() {\n        this.i = this.i, this.j = this.j;\n      }\n\n      A.prototype.i = !1, A.prototype.La = function () {\n        if (!this.i && (this.i = !0, this.G(), 0)) this[w] || (this[w] = ++E);\n      }, A.prototype.G = function () {\n        if (this.j) for (; this.j.length;) {\n          this.j.shift()();\n        }\n      };\n      var k = Array.prototype.indexOf ? function (t, e) {\n        return Array.prototype.indexOf.call(t, e, void 0);\n      } : function (t, e) {\n        if (f(t)) return f(e) && 1 == e.length ? t.indexOf(e, 0) : -1;\n\n        for (var n = 0; n < t.length; n++) {\n          if (n in t && t[n] === e) return n;\n        }\n\n        return -1;\n      },\n          R = Array.prototype.forEach ? function (t, e, n) {\n        Array.prototype.forEach.call(t, e, n);\n      } : function (t, e, n) {\n        for (var r = t.length, i = f(t) ? t.split(\"\") : t, o = 0; o < r; o++) {\n          o in i && e.call(n, i[o], o, t);\n        }\n      };\n\n      function M(t) {\n        return Array.prototype.concat.apply([], arguments);\n      }\n\n      function _(t) {\n        var e = t.length;\n\n        if (0 < e) {\n          for (var n = Array(e), r = 0; r < e; r++) {\n            n[r] = t[r];\n          }\n\n          return n;\n        }\n\n        return [];\n      }\n\n      function O(t) {\n        return /^[\\s\\xa0]*$/.test(t);\n      }\n\n      var P,\n          L = String.prototype.trim ? function (t) {\n        return t.trim();\n      } : function (t) {\n        return /^[\\s\\xa0]*([\\s\\S]*?)[\\s\\xa0]*$/.exec(t)[1];\n      };\n\n      function x(t, e) {\n        return -1 != t.indexOf(e);\n      }\n\n      function q(t, e) {\n        return t < e ? -1 : e < t ? 1 : 0;\n      }\n\n      t: {\n        var F = l.navigator;\n\n        if (F) {\n          var V = F.userAgent;\n\n          if (V) {\n            P = V;\n            break t;\n          }\n        }\n\n        P = \"\";\n      }\n\n      function B(t, e, n) {\n        for (var r in t) {\n          e.call(n, t[r], r, t);\n        }\n      }\n\n      function U(t) {\n        var e,\n            n = {};\n\n        for (e in t) {\n          n[e] = t[e];\n        }\n\n        return n;\n      }\n\n      var Q = \"constructor hasOwnProperty isPrototypeOf propertyIsEnumerable toLocaleString toString valueOf\".split(\" \");\n\n      function K(t, e) {\n        for (var n, r, i = 1; i < arguments.length; i++) {\n          for (n in r = arguments[i]) {\n            t[n] = r[n];\n          }\n\n          for (var o = 0; o < Q.length; o++) {\n            n = Q[o], Object.prototype.hasOwnProperty.call(r, n) && (t[n] = r[n]);\n          }\n        }\n      }\n\n      function j(t) {\n        return j[\" \"](t), t;\n      }\n\n      j[\" \"] = m;\n      var W,\n          G,\n          z = x(P, \"Opera\"),\n          H = x(P, \"Trident\") || x(P, \"MSIE\"),\n          Y = x(P, \"Edge\"),\n          X = Y || H,\n          J = x(P, \"Gecko\") && !(x(P.toLowerCase(), \"webkit\") && !x(P, \"Edge\")) && !(x(P, \"Trident\") || x(P, \"MSIE\")) && !x(P, \"Edge\"),\n          $ = x(P.toLowerCase(), \"webkit\") && !x(P, \"Edge\");\n\n      function Z() {\n        var t = l.document;\n        return t ? t.documentMode : void 0;\n      }\n\n      t: {\n        var tt = \"\",\n            et = (G = P, J ? /rv:([^\\);]+)(\\)|;)/.exec(G) : Y ? /Edge\\/([\\d\\.]+)/.exec(G) : H ? /\\b(?:MSIE|rv)[: ]([^\\);]+)(\\)|;)/.exec(G) : $ ? /WebKit\\/(\\S+)/.exec(G) : z ? /(?:Version)[ \\/]?(\\S+)/.exec(G) : void 0);\n\n        if (et && (tt = et ? et[1] : \"\"), H) {\n          var nt = Z();\n\n          if (null != nt && nt > parseFloat(tt)) {\n            W = String(nt);\n            break t;\n          }\n        }\n\n        W = tt;\n      }\n\n      var rt,\n          it = {};\n\n      function ot(a) {\n        return t = a, e = function e() {\n          for (var t = 0, e = L(String(W)).split(\".\"), n = L(String(a)).split(\".\"), r = Math.max(e.length, n.length), i = 0; 0 == t && i < r; i++) {\n            var o = e[i] || \"\",\n                s = n[i] || \"\";\n\n            do {\n              if (o = /(\\d*)(\\D*)(.*)/.exec(o) || [\"\", \"\", \"\", \"\"], s = /(\\d*)(\\D*)(.*)/.exec(s) || [\"\", \"\", \"\", \"\"], 0 == o[0].length && 0 == s[0].length) break;\n              t = q(0 == o[1].length ? 0 : parseInt(o[1], 10), 0 == s[1].length ? 0 : parseInt(s[1], 10)) || q(0 == o[2].length, 0 == s[2].length) || q(o[2], s[2]), o = o[3], s = s[3];\n            } while (0 == t);\n          }\n\n          return 0 <= t;\n        }, n = it, Object.prototype.hasOwnProperty.call(n, t) ? n[t] : n[t] = e(t);\n        var t, e, n;\n      }\n\n      var st = l.document;\n      rt = st && H ? Z() || (\"CSS1Compat\" == st.compatMode ? parseInt(W, 10) : 5) : void 0;\n\n      var at = !H || 9 <= Number(rt),\n          ut = H && !ot(\"9\"),\n          ct = function () {\n        if (!l.addEventListener || !Object.defineProperty) return !1;\n        var t = !1,\n            e = Object.defineProperty({}, \"passive\", {\n          get: function get() {\n            t = !0;\n          }\n        });\n\n        try {\n          l.addEventListener(\"test\", m, e), l.removeEventListener(\"test\", m, e);\n        } catch (t) {}\n\n        return t;\n      }();\n\n      function ht(t, e) {\n        this.type = t, this.a = this.target = e, this.b = !1, this.hc = !0;\n      }\n\n      function lt(t, e) {\n        ht.call(this, t ? t.type : \"\"), this.relatedTarget = this.a = this.target = null, this.button = this.screenY = this.screenX = this.clientY = this.clientX = 0, this.key = \"\", this.metaKey = this.shiftKey = this.altKey = this.ctrlKey = !1, this.pointerId = 0, this.pointerType = \"\", this.f = null, t && this.g(t, e);\n      }\n\n      ht.prototype.c = function () {\n        this.hc = !1;\n      }, N(lt, ht);\n      var ft = {\n        2: \"touch\",\n        3: \"pen\",\n        4: \"mouse\"\n      };\n      lt.prototype.g = function (t, e) {\n        var n = this.type = t.type,\n            r = t.changedTouches && t.changedTouches.length ? t.changedTouches[0] : null;\n\n        if (this.target = t.target || t.srcElement, this.a = e, e = t.relatedTarget) {\n          if (J) {\n            t: {\n              try {\n                j(e.nodeName);\n                var i = !0;\n                break t;\n              } catch (t) {}\n\n              i = !1;\n            }\n\n            i || (e = null);\n          }\n        } else \"mouseover\" == n ? e = t.fromElement : \"mouseout\" == n && (e = t.toElement);\n\n        this.relatedTarget = e, this.screenY = r ? (this.clientX = void 0 !== r.clientX ? r.clientX : r.pageX, this.clientY = void 0 !== r.clientY ? r.clientY : r.pageY, this.screenX = r.screenX || 0, r.screenY || 0) : (this.clientX = void 0 !== t.clientX ? t.clientX : t.pageX, this.clientY = void 0 !== t.clientY ? t.clientY : t.pageY, this.screenX = t.screenX || 0, t.screenY || 0), this.button = t.button, this.key = t.key || \"\", this.ctrlKey = t.ctrlKey, this.altKey = t.altKey, this.shiftKey = t.shiftKey, this.metaKey = t.metaKey, this.pointerId = t.pointerId || 0, this.pointerType = f(t.pointerType) ? t.pointerType : ft[t.pointerType] || \"\", (this.f = t).defaultPrevented && this.c();\n      }, lt.prototype.c = function () {\n        lt.S.c.call(this);\n        var t = this.f;\n        if (t.preventDefault) t.preventDefault();else if (t.returnValue = !1, ut) try {\n          (t.ctrlKey || 112 <= t.keyCode && t.keyCode <= 123) && (t.keyCode = -1);\n        } catch (t) {}\n      };\n      var pt = \"closure_listenable_\" + (1e6 * Math.random() | 0),\n          dt = 0;\n\n      function mt(t, e, n, r, i) {\n        this.listener = t, this.proxy = null, this.src = e, this.type = n, this.capture = !!r, this.ya = i, this.key = ++dt, this.ja = this.oa = !1;\n      }\n\n      function yt(t) {\n        this.src = t, this.a = {}, this.b = 0;\n      }\n\n      function gt(t, e, n, r) {\n        for (var i = 0; i < t.length; ++i) {\n          var o = t[i];\n          if (!o.ja && o.listener == e && o.capture == !!n && o.ya == r) return i;\n        }\n\n        return -1;\n      }\n\n      mt.prototype.a = function () {\n        this.ja = !0, this.ya = this.src = this.proxy = this.listener = null;\n      }, (s = yt.prototype).add = function (t, e, n, r, i) {\n        var o = t.toString();\n        (t = this.a[o]) || (t = this.a[o] = [], this.b++);\n        var s = gt(t, e, r, i);\n        return -1 < s ? (e = t[s], n || (e.oa = !1)) : ((e = new mt(e, this.src, o, !!r, i)).oa = n, t.push(e)), e;\n      }, s.Sc = function (t, e, n, r) {\n        if ((t = t.toString()) in this.a) {\n          var i = this.a[t];\n          -1 < (e = gt(i, e, n, r)) && (i[e].a(), Array.prototype.splice.call(i, e, 1), 0 == i.length && (delete this.a[t], this.b--));\n        }\n      }, s.fc = function (t) {\n        var e = t.type;\n\n        if (e in this.a) {\n          var n,\n              r = this.a[e],\n              i = k(r, t);\n          (n = 0 <= i) && Array.prototype.splice.call(r, i, 1), n && (t.a(), 0 == this.a[e].length && (delete this.a[e], this.b--));\n        }\n      }, s.Tc = function () {\n        var t;\n\n        for (t in this.a) {\n          for (var e = this.a[t], n = 0; n < e.length; n++) {\n            e[n].a();\n          }\n\n          delete this.a[t], this.b--;\n        }\n      }, s.Rc = function (t, e, n, r) {\n        var i = -1;\n        return (t = this.a[t.toString()]) && (i = gt(t, e, n, r)), -1 < i ? t[i] : null;\n      };\n      var vt = \"closure_lm_\" + (1e6 * Math.random() | 0),\n          bt = {};\n\n      function wt(t, e, n, r, i) {\n        if (r && r.once) return function t(e, n, r, i, o) {\n          if (g(n)) {\n            for (var s = 0; s < n.length; s++) {\n              t(e, n[s], r, i, o);\n            }\n\n            return null;\n          }\n\n          r = At(r);\n          return e && e[pt] ? e.Mb(n, r, b(i) ? !!i.capture : !!i, o) : Et(e, n, r, !0, i, o);\n        }(t, e, n, r, i);\n\n        if (g(e)) {\n          for (var o = 0; o < e.length; o++) {\n            wt(t, e[o], n, r, i);\n          }\n\n          return null;\n        }\n\n        return n = At(n), t && t[pt] ? t.Lb(e, n, b(r) ? !!r.capture : !!r, i) : Et(t, e, n, !1, r, i);\n      }\n\n      function Et(t, e, n, r, i, o) {\n        if (!e) throw Error(\"Invalid event type\");\n        var s = b(i) ? !!i.capture : !!i;\n        if (s && !at) return null;\n        var a,\n            u,\n            c = Dt(t);\n        if (c || (t[vt] = c = new yt(t)), (n = c.add(e, n, r, s, o)).proxy) return n;\n        if (a = Ct, r = u = at ? function (t) {\n          return a.call(u.src, u.listener, t);\n        } : function (t) {\n          if (!(t = a.call(u.src, u.listener, t))) return t;\n        }, (n.proxy = r).src = t, r.listener = n, t.addEventListener) ct || (i = s), void 0 === i && (i = !1), t.addEventListener(e.toString(), r, i);else if (t.attachEvent) t.attachEvent(Tt(e.toString()), r);else {\n          if (!t.addListener || !t.removeListener) throw Error(\"addEventListener and attachEvent are unavailable.\");\n          t.addListener(r);\n        }\n        return n;\n      }\n\n      function St(t) {\n        if (\"number\" != typeof t && t && !t.ja) {\n          var e = t.src;\n          if (e && e[pt]) e.nc(t);else {\n            var n = t.type,\n                r = t.proxy;\n            e.removeEventListener ? e.removeEventListener(n, r, t.capture) : e.detachEvent ? e.detachEvent(Tt(n), r) : e.addListener && e.removeListener && e.removeListener(r), (n = Dt(e)) ? (n.fc(t), 0 == n.b && (n.src = null, e[vt] = null)) : t.a();\n          }\n        }\n      }\n\n      function Tt(t) {\n        return t in bt ? bt[t] : bt[t] = \"on\" + t;\n      }\n\n      function It(t, e) {\n        var n = t.listener,\n            r = t.ya || t.src;\n        return t.oa && St(t), n.call(r, e);\n      }\n\n      function Ct(t, e) {\n        return !!t.ja || (at ? It(t, new lt(e, this)) : It(t, e = new lt(e || d(\"window.event\"), this)));\n      }\n\n      function Dt(t) {\n        return (t = t[vt]) instanceof yt ? t : null;\n      }\n\n      var Nt = \"__closure_events_fn_\" + (1e9 * Math.random() >>> 0);\n\n      function At(e) {\n        return \"function\" == y(e) ? e : (e[Nt] || (e[Nt] = function (t) {\n          return e.handleEvent(t);\n        }), e[Nt]);\n      }\n\n      function kt() {\n        A.call(this), this.c = new yt(this), (this.K = this).F = null;\n      }\n\n      N(kt, A), kt.prototype[pt] = !0, (s = kt.prototype).addEventListener = function (t, e, n, r) {\n        wt(this, t, e, n, r);\n      }, s.removeEventListener = function (t, e, n, r) {\n        !function t(e, n, r, i, o) {\n          if (g(n)) for (var s = 0; s < n.length; s++) {\n            t(e, n[s], r, i, o);\n          } else i = b(i) ? !!i.capture : !!i, r = At(r), e && e[pt] ? e.Qc(n, r, i, o) : e && (e = Dt(e)) && (n = e.Rc(n, r, i, o)) && St(n);\n        }(this, t, e, n, r);\n      }, s.dispatchEvent = function (t) {\n        var e,\n            n = this.F;\n        if (n) for (e = []; n; n = n.F) {\n          e.push(n);\n        }\n        n = this.K;\n        var r = t.type || t;\n        if (f(t)) t = new ht(t, n);else if (t instanceof ht) t.target = t.target || n;else {\n          var i = t;\n          K(t = new ht(r, n), i);\n        }\n        if (i = !0, e) for (var o = e.length - 1; !t.b && 0 <= o; o--) {\n          var s = t.a = e[o];\n          i = s.ua(r, !0, t) && i;\n        }\n        if (t.b || (i = (s = t.a = n).ua(r, !0, t) && i, t.b || (i = s.ua(r, !1, t) && i)), e) for (o = 0; !t.b && o < e.length; o++) {\n          i = (s = t.a = e[o]).ua(r, !1, t) && i;\n        }\n        return i;\n      }, s.G = function () {\n        kt.S.G.call(this), this.Id(), this.F = null;\n      }, s.Lb = function (t, e, n, r) {\n        return this.c.add(String(t), e, !1, n, r);\n      }, s.Mb = function (t, e, n, r) {\n        return this.c.add(String(t), e, !0, n, r);\n      }, s.Qc = function (t, e, n, r) {\n        this.c.Sc(String(t), e, n, r);\n      }, s.nc = function (t) {\n        this.c.fc(t);\n      }, s.Id = function () {\n        this.c && this.c.Tc();\n      }, s.ua = function (t, e, n) {\n        if (!(t = this.c.a[String(t)])) return !0;\n        t = t.concat();\n\n        for (var r = !0, i = 0; i < t.length; ++i) {\n          var o = t[i];\n\n          if (o && !o.ja && o.capture == e) {\n            var s = o.listener,\n                a = o.ya || o.src;\n            o.oa && this.nc(o), r = !1 !== s.call(a, n) && r;\n          }\n        }\n\n        return r && 0 != n.hc;\n      };\n      var Rt = l.JSON.stringify;\n\n      function Mt(t, e) {\n        this.g = 100, this.c = t, this.h = e, this.b = 0, this.a = null;\n      }\n\n      function _t() {\n        this.b = this.a = null;\n      }\n\n      Mt.prototype.get = function () {\n        if (0 < this.b) {\n          this.b--;\n          var t = this.a;\n          this.a = t.next, t.next = null;\n        } else t = this.c();\n\n        return t;\n      }, Mt.prototype.f = function (t) {\n        this.h(t), this.b < this.g && (this.b++, t.next = this.a, this.a = t);\n      };\n      var Ot,\n          Pt = new Mt(function () {\n        return new Lt();\n      }, function (t) {\n        t.reset();\n      });\n\n      function Lt() {\n        this.next = this.b = this.a = null;\n      }\n\n      function xt(t) {\n        l.setTimeout(function () {\n          throw t;\n        }, 0);\n      }\n\n      _t.prototype.add = function (t, e) {\n        var n = this.c();\n        n.set(t, e), this.b ? this.b.next = n : this.a = n, this.b = n;\n      }, _t.prototype.f = function () {\n        var t = null;\n        return this.a && (t = this.a, this.a = this.a.next, this.a || (this.b = null), t.next = null), t;\n      }, _t.prototype.g = function (t) {\n        Pt.f(t);\n      }, _t.prototype.c = function () {\n        return Pt.get();\n      }, Lt.prototype.set = function (t, e) {\n        this.a = t, this.b = e, this.next = null;\n      };\n      var qt = !(Lt.prototype.reset = function () {\n        this.next = this.b = this.a = null;\n      }),\n          Ft = new _t();\n\n      function Vt() {\n        for (var t; t = Ft.f();) {\n          try {\n            t.a.call(t.b);\n          } catch (t) {\n            xt(t);\n          }\n\n          Ft.g(t);\n        }\n\n        qt = !1;\n      }\n\n      function Bt(t, e) {\n        kt.call(this), this.b = t || 1, this.a = e || l, this.f = I(this.$d, this), this.g = D();\n      }\n\n      function Ut(t, e, n) {\n        if (\"function\" == y(t)) n && (t = I(t, n));else {\n          if (!t || \"function\" != typeof t.handleEvent) throw Error(\"Invalid listener argument\");\n          t = I(t.handleEvent, t);\n        }\n        return 2147483647 < Number(e) ? -1 : l.setTimeout(t, e || 0);\n      }\n\n      function Qt(t, e, n) {\n        A.call(this), this.f = null != n ? I(t, n) : t, this.c = e, this.b = I(this.Cd, this), this.a = [];\n      }\n\n      function Kt(t) {\n        A.call(this), this.b = t, this.a = {};\n      }\n\n      N(Bt, kt), (s = Bt.prototype).wa = !1, s.P = null, s.$d = function () {\n        if (this.wa) {\n          var t = D() - this.g;\n          0 < t && t < .8 * this.b ? this.P = this.a.setTimeout(this.f, this.b - t) : (this.P && (this.a.clearTimeout(this.P), this.P = null), this.Gc(), this.wa && (this.Na(), this.start()));\n        }\n      }, s.Gc = function () {\n        this.dispatchEvent(\"tick\");\n      }, s.start = function () {\n        this.wa = !0, this.P || (this.P = this.a.setTimeout(this.f, this.b), this.g = D());\n      }, s.Na = function () {\n        this.wa = !1, this.P && (this.a.clearTimeout(this.P), this.P = null);\n      }, s.G = function () {\n        Bt.S.G.call(this), this.Na(), delete this.a;\n      }, N(Qt, A), (s = Qt.prototype).Ca = !1, s.ec = 0, s.ba = null, s.Hc = function (t) {\n        this.a = arguments, this.ba || this.ec ? this.Ca = !0 : this.yb();\n      }, s.Pc = function () {\n        this.ba && (l.clearTimeout(this.ba), this.ba = null, this.Ca = !1, this.a = []);\n      }, s.G = function () {\n        Qt.S.G.call(this), this.Pc();\n      }, s.Cd = function () {\n        this.ba = null, this.Ca && !this.ec && (this.Ca = !1, this.yb());\n      }, s.yb = function () {\n        this.ba = Ut(this.b, this.c), this.f.apply(null, this.a);\n      }, N(Kt, A);\n      var jt = [];\n\n      function Wt() {}\n\n      (s = Kt.prototype).Jb = function (t, e, n) {\n        this.wd(t, e, n);\n      }, s.wd = function (t, e, n) {\n        g(e) || (e && (jt[0] = e.toString()), e = jt);\n\n        for (var r = 0; r < e.length; r++) {\n          var i = wt(t, e[r], n || this.handleEvent, !1, this.b || this);\n          if (!i) break;\n          this.a[i.key] = i;\n        }\n      }, s.Kb = function () {\n        B(this.a, function (t, e) {\n          this.a.hasOwnProperty(e) && St(t);\n        }, this), this.a = {};\n      }, s.G = function () {\n        Kt.S.G.call(this), this.Kb();\n      }, s.handleEvent = function () {\n        throw Error(\"EventHandler.handleEvent not implemented\");\n      };\n      var Gt = new kt();\n\n      function zt(t) {\n        ht.call(this, \"serverreachability\", t);\n      }\n\n      function Ht(t) {\n        Gt.dispatchEvent(new zt(Gt, t));\n      }\n\n      function Yt(t) {\n        ht.call(this, \"statevent\", t);\n      }\n\n      function Xt(t) {\n        Gt.dispatchEvent(new Yt(Gt, t));\n      }\n\n      function Jt(t) {\n        ht.call(this, \"timingevent\", t);\n      }\n\n      function $t(t, e) {\n        if (\"function\" != y(t)) throw Error(\"Fn must not be null and must be a function\");\n        return l.setTimeout(function () {\n          t();\n        }, e);\n      }\n\n      N(zt, ht), N(Yt, ht), N(Jt, ht);\n      var Zt = {\n        NO_ERROR: 0,\n        ae: 1,\n        he: 2,\n        ge: 3,\n        de: 4,\n        fe: 5,\n        ie: 6,\n        qc: 7,\n        TIMEOUT: 8,\n        le: 9\n      },\n          te = {\n        ce: \"complete\",\n        pe: \"success\",\n        rc: \"error\",\n        qc: \"abort\",\n        ne: \"ready\",\n        oe: \"readystatechange\",\n        TIMEOUT: \"timeout\",\n        je: \"incrementaldata\",\n        me: \"progress\",\n        ee: \"downloadprogress\",\n        qe: \"uploadprogress\"\n      };\n\n      function ee() {}\n\n      function ne() {}\n\n      ee.prototype.a = null, ee.prototype.c = function () {\n        return this.a || (this.a = {});\n      };\n      var re,\n          ie = {\n        OPEN: \"a\",\n        be: \"b\",\n        rc: \"c\",\n        ke: \"d\"\n      };\n\n      function oe() {\n        ht.call(this, \"d\");\n      }\n\n      function se() {\n        ht.call(this, \"c\");\n      }\n\n      function ae() {}\n\n      function ue(t, e, n) {\n        this.g = t, this.da = e, this.ca = n || 1, this.I = new Kt(this), this.L = 45e3, t = X ? 125 : void 0, this.T = new Bt(t), this.J = null, this.b = !1, this.i = this.C = this.f = this.F = this.u = this.U = this.h = null, this.j = [], this.a = null, this.A = 0, this.c = this.v = null, this.o = -1, this.l = !1, this.K = 0, this.B = null, this.s = this.Y = this.H = !1;\n      }\n\n      N(oe, ht), N(se, ht), N(ae, ee), ae.prototype.b = function () {\n        return new XMLHttpRequest();\n      }, re = new ae();\n      var ce = {},\n          he = {};\n\n      function le(t, e) {\n        if (t.forEach && \"function\" == typeof t.forEach) t.forEach(e, void 0);else if (v(t) || f(t)) R(t, e, void 0);else {\n          if (t.O && \"function\" == typeof t.O) var n = t.O();else if (t.D && \"function\" == typeof t.D) n = void 0;else if (v(t) || f(t)) {\n            n = [];\n\n            for (var r = t.length, i = 0; i < r; i++) {\n              n.push(i);\n            }\n          } else for (i in n = [], r = 0, t) {\n            n[r++] = i;\n          }\n\n          i = (r = function (t) {\n            if (t.D && \"function\" == typeof t.D) return t.D();\n            if (f(t)) return t.split(\"\");\n\n            if (v(t)) {\n              for (var e = [], n = t.length, r = 0; r < n; r++) {\n                e.push(t[r]);\n              }\n\n              return e;\n            }\n\n            for (r in e = [], n = 0, t) {\n              e[n++] = t[r];\n            }\n\n            return e;\n          }(t)).length;\n\n          for (var o = 0; o < i; o++) {\n            e.call(void 0, r[o], n && n[o], t);\n          }\n        }\n      }\n\n      function fe(t, e) {\n        this.b = {}, this.a = [], this.c = 0;\n        var n = arguments.length;\n\n        if (1 < n) {\n          if (n % 2) throw Error(\"Uneven number of arguments\");\n\n          for (var r = 0; r < n; r += 2) {\n            this.set(arguments[r], arguments[r + 1]);\n          }\n        } else t && this.fd(t);\n      }\n\n      function pe(t, e) {\n        return Object.prototype.hasOwnProperty.call(t, e);\n      }\n\n      (s = ue.prototype).ha = function (t) {\n        this.J = t;\n      }, s.setTimeout = function (t) {\n        this.L = t;\n      }, s.Xc = function (t) {\n        this.K = t;\n      }, s.Qd = function (t) {\n        this.j = t;\n      }, s.cb = function (t, e) {\n        this.F = 1, this.f = t.N().za(), this.i = e, this.H = !0, this.ic(null);\n      }, s.bb = function (t, e, n) {\n        this.F = 1, this.f = t.N().za(), this.i = null, this.H = e, this.ic(n);\n      }, s.ic = function (t) {\n        this.u = D(), this.fa(), this.C = this.f.N(), this.C.Aa(\"t\", this.ca), this.A = 0, this.a = this.g.sa(this.g.Da() ? t : null), 0 < this.K && (this.B = new Qt(I(this.oc, this, this.a), this.K)), this.I.Jb(this.a, \"readystatechange\", this.Hd), t = this.J ? U(this.J) : {}, this.i ? (this.v || (this.v = \"POST\"), t[\"Content-Type\"] = \"application/x-www-form-urlencoded\", this.a.xa(this.C, this.v, this.i, t)) : (this.v = \"GET\", this.a.xa(this.C, this.v, null, t)), Ht(1);\n      }, s.Hd = function (t) {\n        t = t.target;\n        var e = this.B;\n        e && 3 == t.W() ? e.Hc() : this.oc(t);\n      }, s.oc = function (t) {\n        try {\n          t == this.a && this.Ed();\n        } catch (t) {}\n      }, s.Ed = function () {\n        var t = this.a.W(),\n            e = this.a.Db(),\n            n = this.a.aa();\n        if (!(t < 3 || 3 == t && !X && !this.a.va())) if (this.l || 4 != t || 7 == e || Ht(8 == e || n <= 0 ? 3 : 2), this.pa(), this.o = n = this.a.aa(), e = this.a.va(), this.b = 200 == n) {\n          if (this.Td()) {\n            if (!(n = this.Kc())) return this.b = !1, this.c = 3, Xt(12), this.Z(), void this.ta();\n            this.s = !0, this.Wa(n);\n          }\n\n          this.H ? (this.vb(t, e), X && this.b && 3 == t && this.Yd()) : this.Wa(e), 4 == t && this.Z(), this.b && !this.l && (4 == t ? this.g.Va(this) : (this.b = !1, this.fa()));\n        } else 400 == n && 0 < e.indexOf(\"Unknown SID\") ? (this.c = 3, Xt(12)) : (this.c = 0, Xt(13)), this.Z(), this.ta();\n      }, s.Td = function () {\n        return this.Y && !this.s;\n      }, s.Kc = function () {\n        if (this.a) {\n          var t = this.a.ga(\"X-HTTP-Initial-Response\");\n          if (t && !O(t)) return t;\n        }\n\n        return null;\n      }, s.Md = function () {\n        this.Y = !0;\n      }, s.vb = function (t, e) {\n        for (var n = !0; !this.l && this.A < e.length;) {\n          var r = this.Lc(e);\n\n          if (r == he) {\n            4 == t && (this.c = 4, Xt(14), n = !1);\n            break;\n          }\n\n          if (r == ce) {\n            this.c = 4, Xt(15), n = !1;\n            break;\n          }\n\n          this.Wa(r);\n        }\n\n        4 == t && 0 == e.length && (this.c = 1, Xt(16), n = !1), this.b = this.b && n, n || (this.Z(), this.ta());\n      }, s.Gd = function () {\n        if (this.a) {\n          var t = this.a.W(),\n              e = this.a.va();\n          this.A < e.length && (this.pa(), this.vb(t, e), this.b && 4 != t && this.fa());\n        }\n      }, s.Yd = function () {\n        this.I.Jb(this.T, \"tick\", this.Gd), this.T.start();\n      }, s.Lc = function (t) {\n        var e = this.A,\n            n = t.indexOf(\"\\n\", e);\n        return -1 == n ? he : (e = Number(t.substring(e, n)), isNaN(e) ? ce : (n += 1) + e > t.length ? he : (t = t.substr(n, e), this.A = n + e, t));\n      }, s.Ld = function (t) {\n        this.F = 2, this.f = t.N().za(), t = !1, l.navigator && l.navigator.sendBeacon && (t = l.navigator.sendBeacon(this.f.toString(), \"\")), !t && l.Image && (new Image().src = this.f, t = !0), t || (this.a = this.g.sa(null), this.a.xa(this.f)), this.u = D(), this.fa();\n      }, s.cancel = function () {\n        this.l = !0, this.Z();\n      }, s.Kd = function (t) {\n        t && this.setTimeout(t), this.h && (this.pa(), this.fa());\n      }, s.fa = function () {\n        this.U = D() + this.L, this.mc(this.L);\n      }, s.mc = function (t) {\n        if (null != this.h) throw Error(\"WatchDog timer not null\");\n        this.h = $t(I(this.Dd, this), t);\n      }, s.pa = function () {\n        this.h && (l.clearTimeout(this.h), this.h = null);\n      }, s.Dd = function () {\n        this.h = null;\n        var t = D();\n        0 <= t - this.U ? this.md() : this.mc(this.U - t);\n      }, s.md = function () {\n        2 != this.F && (Ht(3), Xt(17)), this.Z(), this.c = 2, this.ta();\n      }, s.ta = function () {\n        this.g.Tb() || this.l || this.g.Va(this);\n      }, s.Z = function () {\n        this.pa();\n        var t = this.B;\n        t && \"function\" == typeof t.La && t.La(), this.B = null, this.T.Na(), this.I.Kb(), this.a && (t = this.a, this.a = null, t.abort(), t.La());\n      }, s.Wa = function (t) {\n        try {\n          this.g.bc(this, t), Ht(4);\n        } catch (t) {}\n      }, (s = fe.prototype).D = function () {\n        this.Ka();\n\n        for (var t = [], e = 0; e < this.a.length; e++) {\n          t.push(this.b[this.a[e]]);\n        }\n\n        return t;\n      }, s.O = function () {\n        return this.Ka(), this.a.concat();\n      }, s.Ra = function (t) {\n        return pe(this.b, t);\n      }, s.hd = function () {\n        return 0 == this.c;\n      }, s.gd = function () {\n        this.b = {}, this.c = this.a.length = 0;\n      }, s.Qb = function (t) {\n        pe(this.b, t) && (delete this.b[t], this.c--, this.a.length > 2 * this.c && this.Ka());\n      }, s.Ka = function () {\n        if (this.c != this.a.length) {\n          for (var t = 0, e = 0; t < this.a.length;) {\n            var n = this.a[t];\n            pe(this.b, n) && (this.a[e++] = n), t++;\n          }\n\n          this.a.length = e;\n        }\n\n        if (this.c != this.a.length) {\n          var r = {};\n\n          for (e = t = 0; t < this.a.length;) {\n            pe(r, n = this.a[t]) || (r[this.a[e++] = n] = 1), t++;\n          }\n\n          this.a.length = e;\n        }\n      }, s.get = function (t, e) {\n        return pe(this.b, t) ? this.b[t] : e;\n      }, s.set = function (t, e) {\n        pe(this.b, t) || (this.c++, this.a.push(t)), this.b[t] = e;\n      }, s.fd = function (t) {\n        if (t instanceof fe) for (var e = t.O(), n = 0; n < e.length; n++) {\n          this.set(e[n], t.get(e[n]));\n        } else for (e in t) {\n          this.set(e, t[e]);\n        }\n      }, s.forEach = function (t, e) {\n        for (var n = this.O(), r = 0; r < n.length; r++) {\n          var i = n[r],\n              o = this.get(i);\n          t.call(e, o, i, this);\n        }\n      }, s.Pb = function () {\n        return new fe(this);\n      };\n      var de = /^(?:([^:/?#.]+):)?(?:\\/\\/(?:([^/?#]*)@)?([^/#?]*?)(?::([0-9]+))?(?=[/#?]|$))?([^?#]+)?(?:\\?([^#]*))?(?:#([\\s\\S]*))?$/;\n\n      function me(t, e) {\n        var n;\n        this.c = this.i = this.b = \"\", this.h = null, this.j = this.g = \"\", this.f = this.l = !1, t instanceof me ? (this.f = void 0 !== e ? e : t.f, this.ma(t.b), this.$a(t.i), this.ka(t.c), this.la(t.h), this.Ba(t.g), this.Za(t.a.Gb()), this.Ya(t.j)) : t && (n = String(t).match(de)) ? (this.f = !!e, this.ma(n[1] || \"\", !0), this.$a(n[2] || \"\", !0), this.ka(n[3] || \"\", !0), this.la(n[4]), this.Ba(n[5] || \"\", !0), this.Za(n[6] || \"\", !0), this.Ya(n[7] || \"\", !0)) : (this.f = !!e, this.a = new Ie(null, this.f));\n      }\n\n      function ye(t, e) {\n        return t ? e ? decodeURI(t.replace(/%25/g, \"%2525\")) : decodeURIComponent(t) : \"\";\n      }\n\n      function ge(t, e, n) {\n        return f(t) ? (t = encodeURI(t).replace(e, ve), n && (t = t.replace(/%25([0-9a-fA-F]{2})/g, \"%$1\")), t) : null;\n      }\n\n      function ve(t) {\n        return \"%\" + ((t = t.charCodeAt(0)) >> 4 & 15).toString(16) + (15 & t).toString(16);\n      }\n\n      (s = me.prototype).toString = function () {\n        var t = [],\n            e = this.b;\n        e && t.push(ge(e, be, !0), \":\");\n        var n = this.c;\n        return (n || \"file\" == e) && (t.push(\"//\"), (e = this.i) && t.push(ge(e, be, !0), \"@\"), t.push(encodeURIComponent(String(n)).replace(/%25([0-9a-fA-F]{2})/g, \"%$1\")), null != (n = this.h) && t.push(\":\", String(n))), (n = this.g) && (this.Sa() && \"/\" != n.charAt(0) && t.push(\"/\"), t.push(ge(n, \"/\" == n.charAt(0) ? Ee : we, !0))), (n = this.Ic()) && t.push(\"?\", n), (n = this.j) && t.push(\"#\", ge(n, Te)), t.join(\"\");\n      }, s.resolve = function (t) {\n        var e = this.N(),\n            n = t.qd();\n        n ? e.ma(t.b) : n = t.rd(), n ? e.$a(t.i) : n = t.Sa(), n ? e.ka(t.c) : n = t.od();\n        var r = t.g;\n        if (n) e.la(t.h);else if (n = t.Sb()) {\n          if (\"/\" != r.charAt(0)) if (this.Sa() && !this.Sb()) r = \"/\" + r;else {\n            var i = e.g.lastIndexOf(\"/\");\n            -1 != i && (r = e.g.substr(0, i + 1) + r);\n          }\n          if (\"..\" == (i = r) || \".\" == i) r = \"\";else if (x(i, \"./\") || x(i, \"/.\")) {\n            r = 0 == i.lastIndexOf(\"/\", 0), i = i.split(\"/\");\n\n            for (var o = [], s = 0; s < i.length;) {\n              var a = i[s++];\n              \".\" == a ? r && s == i.length && o.push(\"\") : \"..\" == a ? ((1 < o.length || 1 == o.length && \"\" != o[0]) && o.pop(), r && s == i.length && o.push(\"\")) : (o.push(a), r = !0);\n            }\n\n            r = o.join(\"/\");\n          } else r = i;\n        }\n        return n ? e.Ba(r) : n = t.pd(), n ? e.Za(t.a.Gb()) : n = t.nd(), n && e.Ya(t.j), e;\n      }, s.N = function () {\n        return new me(this);\n      }, s.ma = function (t, e) {\n        this.M(), (this.b = e ? ye(t, !0) : t) && (this.b = this.b.replace(/:$/, \"\"));\n      }, s.qd = function () {\n        return !!this.b;\n      }, s.$a = function (t, e) {\n        this.M(), this.i = e ? ye(t) : t;\n      }, s.rd = function () {\n        return !!this.i;\n      }, s.ka = function (t, e) {\n        this.M(), this.c = e ? ye(t, !0) : t;\n      }, s.Sa = function () {\n        return !!this.c;\n      }, s.la = function (t) {\n        if (this.M(), t) {\n          if (t = Number(t), isNaN(t) || t < 0) throw Error(\"Bad port number \" + t);\n          this.h = t;\n        } else this.h = null;\n      }, s.od = function () {\n        return null != this.h;\n      }, s.Ba = function (t, e) {\n        this.M(), this.g = e ? ye(t, !0) : t;\n      }, s.Sb = function () {\n        return !!this.g;\n      }, s.pd = function () {\n        return \"\" !== this.a.toString();\n      }, s.Za = function (t, e) {\n        this.M(), t instanceof Ie ? (this.a = t, this.a.Oc(this.f)) : (e || (t = ge(t, Se)), this.a = new Ie(t, this.f));\n      }, s.Ic = function () {\n        return this.a.toString();\n      }, s.m = function (t, e) {\n        this.M(), this.a.set(t, e);\n      }, s.Aa = function (t, e) {\n        this.M(), g(e) || (e = [String(e)]), this.a.lc(t, e);\n      }, s.Ya = function (t, e) {\n        this.M(), this.j = e ? ye(t) : t;\n      }, s.nd = function () {\n        return !!this.j;\n      }, s.za = function () {\n        return this.M(), this.m(\"zx\", Math.floor(2147483648 * Math.random()).toString(36) + Math.abs(Math.floor(2147483648 * Math.random()) ^ D()).toString(36)), this;\n      }, s.M = function () {\n        if (this.l) throw Error(\"Tried to modify a read-only Uri\");\n      };\n      var be = /[#\\/\\?@]/g,\n          we = /[#\\?:]/g,\n          Ee = /[#\\?]/g,\n          Se = /[#\\?@]/g,\n          Te = /#/g;\n\n      function Ie(t, e) {\n        this.b = this.a = null, this.c = t || null, this.f = !!e;\n      }\n\n      function Ce(t) {\n        this.a = t, this.b = this.h = null, this.g = !1, this.i = null, this.c = -1, this.l = this.f = null;\n      }\n\n      function De() {\n        this.a = this.b = null;\n      }\n\n      function Ne() {\n        this.a = new fe();\n      }\n\n      function Ae(t) {\n        var e = typeof t;\n        return \"object\" == e && t || \"function\" == e ? \"o\" + (t[w] || (t[w] = ++E)) : e.charAt(0) + t;\n      }\n\n      function ke(t, e) {\n        this.a = t, this.b = e;\n      }\n\n      function Re(t) {\n        this.g = t || Me, t = l.PerformanceNavigationTiming ? 0 < (t = l.performance.getEntriesByType(\"navigation\")).length && (\"hq\" == t[0].nextHopProtocol || \"h2\" == t[0].nextHopProtocol) : !!(l.Ja && l.Ja.Vb && l.Ja.Vb() && l.Ja.Vb().te), this.f = t ? this.g : 1, this.a = null, 1 < this.f && (this.a = new Ne()), this.b = null, this.c = [];\n      }\n\n      (s = Ie.prototype).V = function () {\n        if (!this.a && (this.a = new fe(), this.b = 0, this.c)) {\n          var n = this;\n          !function (t, e) {\n            if (t) {\n              t = t.split(\"&\");\n\n              for (var n = 0; n < t.length; n++) {\n                var r = t[n].indexOf(\"=\"),\n                    i = null;\n\n                if (0 <= r) {\n                  var o = t[n].substring(0, r);\n                  i = t[n].substring(r + 1);\n                } else o = t[n];\n\n                e(o, i ? decodeURIComponent(i.replace(/\\+/g, \" \")) : \"\");\n              }\n            }\n          }(this.c, function (t, e) {\n            n.add(decodeURIComponent(t.replace(/\\+/g, \" \")), e);\n          });\n        }\n      }, s.add = function (t, e) {\n        this.V(), this.ia(), t = this.$(t);\n        var n = this.a.get(t);\n        return n || this.a.set(t, n = []), n.push(e), this.b += 1, this;\n      }, s.Ib = function (t) {\n        this.V(), t = this.$(t), this.a.Ra(t) && (this.ia(), this.b -= this.a.get(t).length, this.a.Qb(t));\n      }, s.Hb = function (t) {\n        return this.V(), t = this.$(t), this.a.Ra(t);\n      }, s.forEach = function (n, r) {\n        this.V(), this.a.forEach(function (t, e) {\n          R(t, function (t) {\n            n.call(r, t, e, this);\n          }, this);\n        }, this);\n      }, s.O = function () {\n        this.V();\n\n        for (var t = this.a.D(), e = this.a.O(), n = [], r = 0; r < e.length; r++) {\n          for (var i = t[r], o = 0; o < i.length; o++) {\n            n.push(e[r]);\n          }\n        }\n\n        return n;\n      }, s.D = function (t) {\n        this.V();\n        var e = [];\n        if (f(t)) this.Hb(t) && (e = M(e, this.a.get(this.$(t))));else {\n          t = this.a.D();\n\n          for (var n = 0; n < t.length; n++) {\n            e = M(e, t[n]);\n          }\n        }\n        return e;\n      }, s.set = function (t, e) {\n        return this.V(), this.ia(), t = this.$(t), this.Hb(t) && (this.b -= this.a.get(t).length), this.a.set(t, [e]), this.b += 1, this;\n      }, s.get = function (t, e) {\n        return t && 0 < (t = this.D(t)).length ? String(t[0]) : e;\n      }, s.lc = function (t, e) {\n        this.Ib(t), 0 < e.length && (this.ia(), this.a.set(this.$(t), _(e)), this.b += e.length);\n      }, s.toString = function () {\n        if (this.c) return this.c;\n        if (!this.a) return \"\";\n\n        for (var t = [], e = this.a.O(), n = 0; n < e.length; n++) {\n          var r = e[n],\n              i = encodeURIComponent(String(r));\n          r = this.D(r);\n\n          for (var o = 0; o < r.length; o++) {\n            var s = i;\n            \"\" !== r[o] && (s += \"=\" + encodeURIComponent(String(r[o]))), t.push(s);\n          }\n        }\n\n        return this.c = t.join(\"&\");\n      }, s.ia = function () {\n        this.c = null;\n      }, s.Gb = function () {\n        var t = new Ie();\n        return t.c = this.c, this.a && (t.a = this.a.Pb(), t.b = this.b), t;\n      }, s.$ = function (t) {\n        return t = String(t), this.f && (t = t.toLowerCase()), t;\n      }, s.Oc = function (t) {\n        t && !this.f && (this.V(), this.ia(), this.a.forEach(function (t, e) {\n          var n = e.toLowerCase();\n          e != n && (this.Ib(e), this.lc(n, t));\n        }, this)), this.f = t;\n      }, N(function () {}, function () {}), (s = Ce.prototype).R = null, s.Wc = function (t) {\n        this.h = t;\n      }, s.Vc = function (t) {\n        this.i = t, t = this.a.Cb(this.i), Xt(3);\n        var e = this.a.H.b;\n        null != e ? (this.f = this.a.Oa(e[0]), this.R = 1, this.rb()) : (t.Aa(\"MODE\", \"init\"), !this.a.o && this.a.j && t.Aa(\"X-HTTP-Session-Id\", this.a.j), this.b = new ue(this, void 0, void 0), this.b.ha(this.h), this.b.bb(t, !1, null), this.R = 0);\n      }, s.rb = function () {\n        var t = this.a.H.a;\n        if (null != t) Xt(4), t ? (Xt(10), this.a.na(this, !1)) : (Xt(11), this.a.na(this, !0));else {\n          this.b = new ue(this, void 0, void 0), this.b.ha(this.h), t = this.a.Bb(this.f, this.i), Xt(4), t.Aa(\"TYPE\", \"xmlhttp\");\n          var e = this.a.j,\n              n = this.a.Fa;\n          e && n && t.m(e, n), this.b.bb(t, !1, this.f);\n        }\n      }, s.sa = function (t) {\n        return this.a.sa(t);\n      }, s.abort = function () {\n        this.b && (this.b.cancel(), this.b = null), this.c = -1;\n      }, s.Tb = function () {\n        return !1;\n      }, s.bc = function (t, e) {\n        if (this.c = t.o, 0 == this.R) {\n          if (this.Uc(t), e) {\n            try {\n              var n = this.a.U.a(e);\n            } catch (t) {\n              return void this.a.ab(this);\n            }\n\n            this.f = this.a.Oa(n[0]);\n          } else this.a.ab(this);\n        } else 1 == this.R && (this.g ? Xt(6) : \"11111\" == e ? (Xt(5), this.g = !0, this.Ac() && (this.c = 200, this.b.cancel(), Xt(11), this.a.na(this, !0))) : (Xt(7), this.g = !1));\n      }, s.Va = function () {\n        this.c = this.b.o, this.b.b ? 0 == this.R ? (this.R = 1, this.rb()) : 1 == this.R && (this.g ? (Xt(11), this.a.na(this, !0)) : (Xt(10), this.a.na(this, !1))) : (0 == this.R ? Xt(8) : 1 == this.R && Xt(9), this.a.ab(this));\n      }, s.Uc = function (t) {\n        if (!this.a.o && (t = t.a)) {\n          var e = t.ga(\"X-Client-Wire-Protocol\");\n          this.l = e || null, this.a.j && (t = t.ga(\"X-HTTP-Session-Id\")) && this.a.kc(t);\n        }\n      }, s.Da = function () {\n        return this.a.Da();\n      }, s.Pa = function () {\n        return this.a.Pa();\n      }, s.Ac = function () {\n        return !H || 10 <= Number(rt);\n      }, (s = Ne.prototype).add = function (t) {\n        this.a.set(Ae(t), t);\n      }, s.ed = function (t) {\n        this.a.Qb(Ae(t));\n      }, s.jd = function () {\n        this.a.gd();\n      }, s.Rb = function () {\n        return this.a.hd();\n      }, s.Ob = function (t) {\n        return this.a.Ra(Ae(t));\n      }, s.D = function () {\n        return this.a.D();\n      };\n      var Me = 10;\n\n      function _e() {\n        this.b = this.a = void 0;\n      }\n\n      function Oe() {\n        this.f = new _e();\n      }\n\n      function Pe(t, e, n, r, i) {\n        try {\n          e.onload = null, e.onerror = null, e.onabort = null, e.ontimeout = null, i(r);\n        } catch (t) {}\n      }\n\n      (s = Re.prototype).kb = function (t) {\n        !this.a && (x(t, \"spdy\") || x(t, \"quic\") || x(t, \"h2\")) && (this.f = this.g, this.a = new Ne(), this.b && (this.Ha(this.b), this.b = null));\n      }, s.Ub = function () {\n        return !!this.b || !!this.a && this.a.a.c >= this.f;\n      }, s.Mc = function () {\n        return this.b ? 1 : this.a ? this.a.a.c : 0;\n      }, s.Ta = function (t) {\n        return this.b ? this.b == t : !!this.a && this.a.Ob(t);\n      }, s.Ha = function (t) {\n        this.a ? this.a.add(t) : this.b = t;\n      }, s.gc = function (t) {\n        this.b && this.b == t ? this.b = null : this.a && this.a.Ob(t) && this.a.ed(t);\n      }, s.cancel = function () {\n        this.c = this.Xb(), this.b ? (this.b.cancel(), this.b = null) : this.a && !this.a.Rb() && (R(this.a.D(), function (t) {\n          t.cancel();\n        }), this.a.jd());\n      }, s.Xb = function () {\n        if (null != this.b) return this.c.concat(this.b.j);\n        if (null == this.a || this.a.Rb()) return _(this.c);\n        var e = this.c;\n        return R(this.a.D(), function (t) {\n          e = e.concat(t.j);\n        }), e;\n      }, s.wc = function (t) {\n        this.c = this.c.concat(t);\n      }, s.Bc = function () {\n        this.c.length = 0;\n      }, _e.prototype.stringify = function (t) {\n        return l.JSON.stringify(t, this.a);\n      }, _e.prototype.parse = function (t) {\n        return l.JSON.parse(t, this.b);\n      }, Oe.prototype.b = function (t, r, e) {\n        var i = e || \"\";\n\n        try {\n          le(t, function (t, e) {\n            var n = t;\n            b(t) && (n = Rt(t)), r.push(i + e + \"=\" + encodeURIComponent(n));\n          });\n        } catch (t) {\n          throw r.push(i + \"type=\" + encodeURIComponent(\"_badmap\")), t;\n        }\n      }, Oe.prototype.c = function (t, e, n) {\n        for (var r = -1;;) {\n          var i = [\"count=\" + e];\n          -1 == r ? 0 < e ? (r = t[0].a, i.push(\"ofs=\" + r)) : r = 0 : i.push(\"ofs=\" + r);\n\n          for (var o = !0, s = 0; s < e; s++) {\n            var a = t[s].a,\n                u = t[s].b;\n            if ((a -= r) < 0) r = Math.max(0, t[s].a - 100), o = !1;else try {\n              this.b(u, i, \"req\" + a + \"_\");\n            } catch (t) {\n              n && n(u);\n            }\n          }\n\n          if (o) return i.join(\"&\");\n        }\n      }, Oe.prototype.a = function (t) {\n        return this.f.parse(t);\n      };\n      var Le = l.JSON.parse;\n\n      function xe(t) {\n        kt.call(this), this.headers = new fe(), this.l = t || null, this.b = !1, this.v = this.a = null, this.C = \"\", this.h = 0, this.f = \"\", this.g = this.B = this.o = this.A = !1, this.u = 0, this.s = null, this.J = qe, this.H = this.L = this.I = !1;\n      }\n\n      N(xe, kt);\n      var qe = \"\",\n          Fe = /^https?$/i,\n          Ve = [\"POST\", \"PUT\"];\n\n      function Be(t) {\n        return \"content-type\" == t.toLowerCase();\n      }\n\n      function Ue(t, e) {\n        return {\n          type: e,\n          lengthComputable: t.lengthComputable,\n          loaded: t.loaded,\n          total: t.total\n        };\n      }\n\n      function Qe(t, e, n) {\n        t: {\n          for (r in n) {\n            var r = !1;\n            break t;\n          }\n\n          r = !0;\n        }\n\n        if (r) return t;\n        var i;\n\n        if (i = \"\", B(n, function (t, e) {\n          i += e, i += \":\", i += t, i += \"\\r\\n\";\n        }), n = i, f(t)) {\n          if (e = encodeURIComponent(String(e)), e += n = null != n ? \"=\" + encodeURIComponent(String(n)) : \"\") {\n            if ((n = t.indexOf(\"#\")) < 0 && (n = t.length), (r = t.indexOf(\"?\")) < 0 || n < r) {\n              r = n;\n              var o = \"\";\n            } else o = t.substring(r + 1, n);\n\n            n = (t = [t.substr(0, r), o, t.substr(n)])[1], t[1] = e ? n ? n + \"&\" + e : e : n, t = t[0] + (t[1] ? \"?\" + t[1] : \"\") + t[2];\n          }\n\n          return t;\n        }\n\n        return t.m(e, n), t;\n      }\n\n      function Ke(t) {\n        this.gb = 22, this.g = [], this.H = new De(), this.da = this.fb = this.C = this.Ea = this.a = this.Fa = this.j = this.ca = this.f = this.J = this.h = null, this.sc = !0, this.zc = this.L = 0, this.uc = !!d(\"internalChannelParams.failFast\", t), this.Ga = this.v = this.s = this.l = this.i = this.b = null, this.eb = !0, this.B = this.jb = this.K = -1, this.Y = this.u = this.A = 0, this.tc = d(\"internalChannelParams.baseRetryDelayMs\", t) || 5e3, this.Fc = d(\"internalChannelParams.retryDelaySeedMs\", t) || 1e4, this.pc = d(\"internalChannelParams.forwardChannelMaxRetries\", t) || 2, this.ib = d(\"internalChannelParams.forwardChannelRequestTimeoutMs\", t) || 2e4, this.xc = t && t.ue || void 0, this.F = void 0, this.vc = 0, this.T = t && t.supportsCrossDomainXhr || !1, this.I = \"\", this.c = new Re(t && t.concurrentRequestLimit), this.U = new Oe(), this.o = !t || void 0 === t.backgroundChannelTest || t.backgroundChannelTest, (this.hb = t && t.fastHandshake || !1) && !this.o && (this.o = !0), t && t.se && (this.eb = !1);\n      }\n\n      function je() {}\n\n      function We() {\n        if (H && !(10 <= Number(rt))) throw Error(\"Environmental error: no available transport.\");\n      }\n\n      function Ge(t, e) {\n        kt.call(this), this.a = new Ke(e), this.g = t, this.o = e && e.testUrl ? e.testUrl : function (t) {\n          for (var e = t, n = 1; n < arguments.length; n++) {\n            var r,\n                i = arguments[n];\n            0 == i.lastIndexOf(\"/\", 0) ? e = i : ((r = \"\" == e) || (r = 0 <= (r = e.length - 1) && e.indexOf(\"/\", r) == r), e += r ? i : \"/\" + i);\n          }\n\n          return e;\n        }(this.g, \"test\"), this.b = e && e.messageUrlParams || null, t = e && e.messageHeaders || null, e && e.clientProtocolHeaderRequired && (t ? t[\"X-Client-Protocol\"] = \"webchannel\" : t = {\n          \"X-Client-Protocol\": \"webchannel\"\n        }), this.a.cd(t), t = e && e.initMessageHeaders || null, e && e.messageContentType && (t ? t[\"X-WebChannel-Content-Type\"] = e.messageContentType : t = {\n          \"X-WebChannel-Content-Type\": e.messageContentType\n        }), e && e.tb && (t ? t[\"X-WebChannel-Client-Profile\"] = e.tb : t = {\n          \"X-WebChannel-Client-Profile\": e.tb\n        }), this.a.Pd(t), (t = e && e.httpHeadersOverwriteParam) && !O(t) && this.a.Nd(t), this.l = e && e.supportsCrossDomainXhr || !1, this.h = e && e.sendRawJson || !1, (e = e && e.httpSessionIdParam) && !O(e) && (this.a.Od(e), null !== (t = this.b) && e in t && e in (t = this.b) && delete t[e]), this.f = new Ye(this);\n      }\n\n      function ze(t) {\n        oe.call(this);\n        var e = t.__sm__;\n\n        if (e) {\n          t: {\n            for (var n in e) {\n              t = n;\n              break t;\n            }\n\n            t = void 0;\n          }\n\n          (this.f = t) ? (t = this.f, this.data = null !== e && t in e ? e[t] : void 0) : this.data = e;\n        } else this.data = t;\n      }\n\n      function He() {\n        se.call(this), this.status = 1;\n      }\n\n      function Ye(t) {\n        this.a = t;\n      }\n\n      (s = xe.prototype).Sd = function (t) {\n        this.I = t;\n      }, s.xa = function (t, e, n, r) {\n        if (this.a) throw Error(\"[goog.net.XhrIo] Object is active with another request=\" + this.C + \"; newUri=\" + t);\n        e = e ? e.toUpperCase() : \"GET\", this.C = t, this.f = \"\", this.h = 0, this.A = !1, this.b = !0, this.a = this.Ec(), this.v = this.l ? this.l.c() : re.c(), this.a.onreadystatechange = I(this.ac, this), this.L && \"onprogress\" in this.a && (this.a.onprogress = I(function (t) {\n          this.Zb(t, !0);\n        }, this), this.a.upload && (this.a.upload.onprogress = I(this.Zb, this)));\n\n        try {\n          this.B = !0, this.a.open(e, String(t), !0), this.B = !1;\n        } catch (t) {\n          return void this.Ab(t);\n        }\n\n        t = n || \"\";\n        var i,\n            o = this.headers.Pb();\n        r && le(r, function (t, e) {\n          o.set(e, t);\n        }), r = function (t) {\n          t: {\n            for (var e = Be, n = t.length, r = f(t) ? t.split(\"\") : t, i = 0; i < n; i++) {\n              if (i in r && e.call(void 0, r[i], i, t)) {\n                e = i;\n                break t;\n              }\n            }\n\n            e = -1;\n          }\n\n          return e < 0 ? null : f(t) ? t.charAt(e) : t[e];\n        }(o.O()), n = l.FormData && t instanceof l.FormData, !(0 <= k(Ve, e)) || r || n || o.set(\"Content-Type\", \"application/x-www-form-urlencoded;charset=utf-8\"), o.forEach(function (t, e) {\n          this.a.setRequestHeader(e, t);\n        }, this), this.J && (this.a.responseType = this.J), \"withCredentials\" in this.a && this.a.withCredentials !== this.I && (this.a.withCredentials = this.I);\n\n        try {\n          this.sb(), 0 < this.u && ((this.H = (i = this.a, H && ot(9) && \"number\" == typeof i.timeout && void 0 !== i.ontimeout)) ? (this.a.timeout = this.u, this.a.ontimeout = I(this.Nb, this)) : this.s = Ut(this.Nb, this.u, this)), this.o = !0, this.a.send(t), this.o = !1;\n        } catch (t) {\n          this.Ab(t);\n        }\n      }, s.Ec = function () {\n        return this.l ? this.l.b() : re.b();\n      }, s.Nb = function () {\n        void 0 !== c && this.a && (this.f = \"Timed out after \" + this.u + \"ms, aborting\", this.h = 8, this.dispatchEvent(\"timeout\"), this.abort(8));\n      }, s.Ab = function (t) {\n        this.b = !1, this.a && (this.g = !0, this.a.abort(), this.g = !1), this.f = t, this.h = 5, this.xb(), this.qa();\n      }, s.xb = function () {\n        this.A || (this.A = !0, this.dispatchEvent(\"complete\"), this.dispatchEvent(\"error\"));\n      }, s.abort = function (t) {\n        this.a && this.b && (this.b = !1, this.g = !0, this.a.abort(), this.g = !1, this.h = t || 7, this.dispatchEvent(\"complete\"), this.dispatchEvent(\"abort\"), this.qa());\n      }, s.G = function () {\n        this.a && (this.b && (this.b = !1, this.g = !0, this.a.abort(), this.g = !1), this.qa(!0)), xe.S.G.call(this);\n      }, s.ac = function () {\n        this.i || (this.B || this.o || this.g ? this.$b() : this.Bd());\n      }, s.Bd = function () {\n        this.$b();\n      }, s.$b = function () {\n        if (this.b && void 0 !== c && (!this.v[1] || 4 != this.W() || 2 != this.aa())) if (this.o && 4 == this.W()) Ut(this.ac, 0, this);else if (this.dispatchEvent(\"readystatechange\"), this.td()) {\n          this.b = !1;\n\n          try {\n            this.vd() ? (this.dispatchEvent(\"complete\"), this.dispatchEvent(\"success\")) : (this.h = 6, this.f = this.Fb() + \" [\" + this.aa() + \"]\", this.xb());\n          } finally {\n            this.qa();\n          }\n        }\n      }, s.Zb = function (t, e) {\n        this.dispatchEvent(Ue(t, \"progress\")), this.dispatchEvent(Ue(t, e ? \"downloadprogress\" : \"uploadprogress\"));\n      }, s.qa = function (t) {\n        if (this.a) {\n          this.sb();\n          var e = this.a,\n              n = this.v[0] ? m : null;\n          this.v = this.a = null, t || this.dispatchEvent(\"ready\");\n\n          try {\n            e.onreadystatechange = n;\n          } catch (t) {}\n        }\n      }, s.sb = function () {\n        this.a && this.H && (this.a.ontimeout = null), this.s && (l.clearTimeout(this.s), this.s = null);\n      }, s.td = function () {\n        return 4 == this.W();\n      }, s.vd = function () {\n        var t = this.aa();\n\n        t: switch (t) {\n          case 200:\n          case 201:\n          case 202:\n          case 204:\n          case 206:\n          case 304:\n          case 1223:\n            var e = !0;\n            break t;\n\n          default:\n            e = !1;\n        }\n\n        return e || 0 === t && !this.ud();\n      }, s.ud = function () {\n        var t = String(this.C).match(de)[1] || null;\n        return !t && l.self && l.self.location && (t = (t = l.self.location.protocol).substr(0, t.length - 1)), Fe.test(t ? t.toLowerCase() : \"\");\n      }, s.W = function () {\n        return this.a ? this.a.readyState : 0;\n      }, s.aa = function () {\n        try {\n          return 2 < this.W() ? this.a.status : -1;\n        } catch (t) {\n          return -1;\n        }\n      }, s.Fb = function () {\n        try {\n          return 2 < this.W() ? this.a.statusText : \"\";\n        } catch (t) {\n          return \"\";\n        }\n      }, s.va = function () {\n        try {\n          return this.a ? this.a.responseText : \"\";\n        } catch (t) {\n          return \"\";\n        }\n      }, s.Nc = function (t) {\n        if (this.a) {\n          var e = this.a.responseText;\n          return t && 0 == e.indexOf(t) && (e = e.substring(t.length)), Le(e);\n        }\n      }, s.ga = function (t) {\n        return this.a ? this.a.getResponseHeader(t) : null;\n      }, s.Db = function () {\n        return this.h;\n      }, s.dd = function () {\n        return f(this.f) ? this.f : String(this.f);\n      }, (s = Ke.prototype).qb = 8, s.w = 1, s.bd = function (t, e, n) {\n        Xt(0), this.Ea = e, this.ca = n || {}, this.o && (this.H.b = [], this.H.a = !1), this.Dc(t);\n      }, s.Qa = function () {\n        if (this.lb(), 3 == this.w) {\n          var t = this.L++,\n              e = this.C.N();\n          e.m(\"SID\", this.I), e.m(\"RID\", t), e.m(\"TYPE\", \"terminate\"), this.ea(e), new ue(this, t, void 0).Ld(e);\n        }\n\n        this.Yb();\n      }, s.Dc = function (t) {\n        this.v = new Ce(this), null === this.f && this.v.Wc(this.h);\n        var e = t;\n        this.f && this.h && (e = Qe(t, this.f, this.h)), this.v.Vc(e);\n      }, s.Cc = function () {\n        this.C = this.Cb(this.Ea), this.Ma();\n      }, s.lb = function () {\n        this.v && (this.v.abort(), this.v = null), this.a && (this.a.cancel(), this.a = null), this.l && (l.clearTimeout(this.l), this.l = null), this.ra(), this.c.cancel(), this.i && (l.clearTimeout(this.i), this.i = null);\n      }, s.cd = function (t) {\n        this.h = t;\n      }, s.Pd = function (t) {\n        this.J = t;\n      }, s.Nd = function (t) {\n        this.f = t;\n      }, s.Od = function (t) {\n        this.j = t;\n      }, s.kc = function (t) {\n        this.Fa = t;\n      }, s.Rd = function () {\n        this.T = !0;\n      }, s.jc = function (t) {\n        this.b = t;\n      }, s.sd = function () {\n        return !this.Ga;\n      }, s.Xa = function (t) {\n        this.g.push(new ke(this.zc++, t)), 3 == this.w && this.Ma();\n      }, s.Jc = function () {\n        return this.uc ? 0 : this.pc;\n      }, s.Tb = function () {\n        return 0 == this.w;\n      }, s.Ma = function () {\n        this.c.Ub() || this.i || (this.i = $t(I(this.dc, this), 0), this.A = 0);\n      }, s.xd = function (t) {\n        return !(this.c.Mc() >= this.c.f - (this.i ? 1 : 0)) && (this.i ? (this.g = t.j.concat(this.g), !0) : !(1 == this.w || 2 == this.w || this.A >= this.Jc()) && (this.i = $t(I(this.dc, this, t), this.Eb(this.A)), this.A++, !0));\n      }, s.dc = function (t) {\n        this.i = null, this.Xd(t);\n      }, s.Xd = function (t) {\n        1 == this.w ? t || (this.Fd(), this.w = 2) : 3 == this.w && (t ? this.Wb(t) : 0 == this.g.length || this.c.Ub() || this.Wb());\n      }, s.Fd = function () {\n        this.L = Math.floor(1e5 * Math.random());\n        var t = this.L++,\n            e = new ue(this, t, void 0),\n            n = this.h;\n        this.J && (n ? K(n = U(n), this.J) : n = this.J), null === this.f && e.ha(n);\n        var r = this.wb(e),\n            i = this.C.N();\n        i.m(\"RID\", t), 0 < this.gb && i.m(\"CVER\", this.gb), this.o && this.j && i.m(\"X-HTTP-Session-Id\", this.j), this.ea(i), this.f && n && Qe(i, this.f, n), this.c.Ha(e), this.hb ? (i.m(\"$req\", r), i.m(\"SID\", \"null\"), e.Md(), e.cb(i, null)) : e.cb(i, r);\n      }, s.Wb = function (t) {\n        var e;\n        e = t ? t.da : this.L++;\n        var n = this.C.N();\n        n.m(\"SID\", this.I), n.m(\"RID\", e), n.m(\"AID\", this.K), this.ea(n), this.f && this.h && Qe(n, this.f, this.h), e = new ue(this, e, this.A + 1), null === this.f && e.ha(this.h), t && this.Jd(t), t = this.wb(e), e.setTimeout(Math.round(.5 * this.ib) + Math.round(.5 * this.ib * Math.random())), this.c.Ha(e), e.cb(n, t);\n      }, s.ea = function (n) {\n        this.b && le({}, function (t, e) {\n          n.m(e, t);\n        });\n      }, s.wb = function (t) {\n        var e = Math.min(this.g.length, 1e3),\n            n = this.b ? I(this.b.yc, this.b, this) : null;\n        return n = this.U.c(this.g, e, n), t.Qd(this.g.splice(0, e)), n;\n      }, s.Jd = function (t) {\n        this.g = t.j.concat(this.g);\n      }, s.zb = function () {\n        if (!this.a && !this.l) {\n          this.Y = 1;\n          var t = this.cc;\n          Ot || (e = l.Promise.resolve(void 0), Ot = function Ot() {\n            e.then(Vt);\n          }), qt || (Ot(), qt = !0), Ft.add(t, this), this.u = 0;\n        }\n\n        var e;\n      }, s.Ua = function () {\n        return !(this.a || this.l || 3 <= this.u) && (this.Y++, this.l = $t(I(this.cc, this), this.Eb(this.u)), this.u++, !0);\n      }, s.cc = function () {\n        this.l = null, this.Vd();\n      }, s.Vd = function () {\n        this.a = new ue(this, \"rpc\", this.Y), null === this.f && this.a.ha(this.h), this.a.Xc(this.vc);\n        var t = this.fb.N();\n        t.m(\"RID\", \"rpc\"), t.m(\"SID\", this.I), t.m(\"CI\", this.Ga ? \"0\" : \"1\"), t.m(\"AID\", this.K), this.ea(t), t.m(\"TYPE\", \"xmlhttp\"), this.f && this.h && Qe(t, this.f, this.h), this.F && this.a.setTimeout(this.F), this.a.bb(t, !0, this.da);\n      }, s.na = function (t, e) {\n        var n = t.l;\n        n && this.c.kb(n), this.Ga = this.eb && e, this.B = t.c, this.Cc();\n      }, s.ab = function (t) {\n        this.B = t.c, this.X(2);\n      }, s.bc = function (t, e) {\n        if (0 != this.w && (this.a == t || this.c.Ta(t))) if (this.B = t.o, !t.s && this.c.Ta(t) && 3 == this.w) {\n          try {\n            var n = this.U.a(e);\n          } catch (t) {\n            n = null;\n          }\n\n          g(n) && 3 == n.length ? this.ld(n, t) : this.X(11);\n        } else (t.s || this.a == t) && this.ra(), O(e) || (n = this.U.a(e), this.Ad(n, t));\n      }, s.ld = function (t, e) {\n        0 == t[0] ? this.kd(e) : (this.jb = t[1], 0 < this.jb - this.K && this.Ud(t[2]) && !this.s && (this.s = $t(I(this.yd, this), 6e3)));\n      }, s.kd = function (t) {\n        if (!this.l) {\n          if (this.a) {\n            if (!(this.a.u + 3e3 < t.u)) return;\n            this.ra(), this.a.cancel(), this.a = null;\n          }\n\n          this.Ua(), Xt(18);\n        }\n      }, s.Ud = function (t) {\n        return t < 37500 && !this.sd() && 0 == this.u;\n      }, s.Oa = function (t) {\n        return this.sc ? this.b ? this.b.$c(t) : t : null;\n      }, s.yd = function () {\n        null != this.s && (this.s = null, this.a.cancel(), this.a = null, this.Ua(), Xt(19));\n      }, s.ra = function () {\n        null != this.s && (l.clearTimeout(this.s), this.s = null);\n      }, s.Va = function (t) {\n        var e = null;\n\n        if (this.a == t) {\n          this.ra(), this.a = null;\n          var n = 2;\n        } else {\n          if (!this.c.Ta(t)) return;\n          e = t.j, this.c.gc(t), n = 1;\n        }\n\n        if (this.B = t.o, 0 != this.w) if (t.b) 1 == n ? (n = D() - t.u, Gt.dispatchEvent(new Jt(Gt, t.i ? t.i.length : 0, n, this.A)), this.Ma()) : this.zb();else {\n          var r = t.c;\n          if (3 == r || 0 == r && 0 < this.B || !(1 == n && this.xd(t) || 2 == n && this.Ua())) switch (e && 0 < e.length && this.c.wc(e), r) {\n            case 1:\n              this.X(5);\n              break;\n\n            case 4:\n              this.X(10);\n              break;\n\n            case 3:\n              this.X(6);\n              break;\n\n            default:\n              this.X(2);\n          }\n        }\n      }, s.Eb = function (t) {\n        var e = this.tc + Math.floor(Math.random() * this.Fc);\n        return this.Pa() || (e *= 2), e * t;\n      }, s.ad = function (t) {\n        if (this.o && (t = t.a)) {\n          var e = t.ga(\"X-Client-Wire-Protocol\");\n          e && this.c.kb(e), this.j && (t = t.ga(\"X-HTTP-Session-Id\")) && (this.kc(t), this.C.m(this.j, t));\n        }\n      }, s.Ad = function (t, e) {\n        for (var n = this.b && this.b.Ia ? [] : null, r = 0; r < t.length; r++) {\n          var i = t[r];\n          if (this.K = i[0], i = i[1], 2 == this.w) {\n            if (\"c\" == i[0]) {\n              this.I = i[1], this.da = this.Oa(i[2]);\n              var o = i[3];\n              null != o && (this.qb = o), null != (i = i[5]) && \"number\" == typeof i && 0 < i && (this.F = 1.5 * i), this.ad(e), this.w = 3, this.b && this.b.pb(), this.Wd(e);\n            } else \"stop\" != i[0] && \"close\" != i[0] || this.X(7);\n          } else 3 == this.w && (\"stop\" == i[0] || \"close\" == i[0] ? (n && 0 != n.length && (this.b.Ia(this, n), n.length = 0), \"stop\" == i[0] ? this.X(7) : this.Qa()) : \"noop\" != i[0] && (n ? n.push(i) : this.b && this.b.ob(i)), this.u = 0);\n        }\n\n        n && 0 != n.length && this.b.Ia(this, n);\n      }, s.Wd = function (t) {\n        this.fb = this.Bb(this.da, this.Ea), t.s ? (this.c.gc(t), t.Kd(this.F), this.a = t) : this.zb();\n      }, s.X = function (t) {\n        if (2 == t) {\n          var e = null;\n          this.b && (e = null);\n          var n = I(this.Zd, this);\n          e || (e = new me(\"//www.google.com/images/cleardot.gif\"), l.location && \"http\" == l.location.protocol || e.ma(\"https\"), e.za()), r = e.toString(), i = n, o = new Wt(), (s = new Image()).onload = C(Pe, o, s, \"TestLoadImage: loaded\", !0, i), s.onerror = C(Pe, o, s, \"TestLoadImage: error\", !1, i), s.onabort = C(Pe, o, s, \"TestLoadImage: abort\", !1, i), s.ontimeout = C(Pe, o, s, \"TestLoadImage: timeout\", !1, i), l.setTimeout(function () {\n            s.ontimeout && s.ontimeout();\n          }, 1e4), s.src = r;\n        } else Xt(2);\n\n        var r, i, o, s;\n        this.zd(t);\n      }, s.Zd = function (t) {\n        Xt(t ? 2 : 1);\n      }, s.zd = function (t) {\n        this.w = 0, this.b && this.b.nb(t), this.Yb(), this.lb();\n      }, s.Yb = function () {\n        this.w = 0, this.B = -1, this.b && (0 == this.c.Xb().length && 0 == this.g.length || (this.c.Bc(), _(this.g), this.g.length = 0), this.b.mb());\n      }, s.Cb = function (t) {\n        return this.ub(null, t);\n      }, s.Bb = function (t, e) {\n        return this.ub(this.Da() ? t : null, e);\n      }, s.ub = function (t, e) {\n        var n,\n            r,\n            i,\n            o,\n            s,\n            a,\n            u = (n = e) instanceof me ? n.N() : new me(n, void 0);\n        if (\"\" != u.c) t && u.ka(t + \".\" + u.c), u.la(u.h);else {\n          var c,\n              h = l.location;\n          c = t ? t + \".\" + h.hostname : h.hostname, r = h.protocol, i = c, o = +h.port, s = e, a = new me(null, void 0), r && a.ma(r), i && a.ka(i), o && a.la(o), s && a.Ba(s), u = a;\n        }\n        return this.ca && B(this.ca, function (t, e) {\n          u.m(e, t);\n        }), t = this.j, e = this.Fa, t && e && u.m(t, e), u.m(\"VER\", this.qb), this.ea(u), u;\n      }, s.sa = function (t) {\n        if (t && !this.T) throw Error(\"Can't create secondary domain capable XhrIo object.\");\n        return (t = new xe(this.xc)).Sd(this.T), t;\n      }, s.Pa = function () {\n        return !!this.b && !0;\n      }, s.Da = function () {\n        return this.T;\n      }, (s = je.prototype).Ia = null, s.pb = function () {}, s.ob = function () {}, s.nb = function () {}, s.mb = function () {}, s.yc = function () {}, s.$c = function (t) {\n        return t;\n      }, We.prototype.a = function (t, e) {\n        return new Ge(t, e);\n      }, N(Ge, kt), (s = Ge.prototype).addEventListener = function (t, e, n, r) {\n        Ge.S.addEventListener.call(this, t, e, n, r);\n      }, s.removeEventListener = function (t, e, n, r) {\n        Ge.S.removeEventListener.call(this, t, e, n, r);\n      }, s.Yc = function () {\n        this.a.jc(this.f), this.l && this.a.Rd(), this.a.bd(this.o, this.g, this.b || void 0);\n      }, s.close = function () {\n        this.a.Qa();\n      }, s.Zc = function (t) {\n        if (f(t)) {\n          var e = {};\n          e.__data__ = t, this.a.Xa(e);\n        } else this.h ? ((e = {}).__data__ = Rt(t), this.a.Xa(e)) : this.a.Xa(t);\n      }, s.G = function () {\n        this.a.jc(null), delete this.f, this.a.Qa(), delete this.a, Ge.S.G.call(this);\n      }, N(ze, oe), N(He, se), N(Ye, je), Ye.prototype.pb = function () {\n        this.a.dispatchEvent(\"a\");\n      }, Ye.prototype.ob = function (t) {\n        this.a.dispatchEvent(new ze(t));\n      }, Ye.prototype.nb = function (t) {\n        this.a.dispatchEvent(new He(t));\n      }, Ye.prototype.mb = function () {\n        this.a.dispatchEvent(\"b\");\n      };\n      var Xe = C(function (t, e) {\n        function n() {}\n\n        n.prototype = t.prototype;\n        var r = new n();\n        return t.apply(r, Array.prototype.slice.call(arguments, 1)), r;\n      }, We);\n      We.prototype.createWebChannel = We.prototype.a, Ge.prototype.send = Ge.prototype.Zc, Ge.prototype.open = Ge.prototype.Yc, Ge.prototype.close = Ge.prototype.close, Zt.NO_ERROR = 0, Zt.TIMEOUT = 8, Zt.HTTP_ERROR = 6, te.COMPLETE = \"complete\", (ne.EventType = ie).OPEN = \"a\", ie.CLOSE = \"b\", ie.ERROR = \"c\", ie.MESSAGE = \"d\", kt.prototype.listen = kt.prototype.Lb, xe.prototype.listenOnce = xe.prototype.Mb, xe.prototype.getLastError = xe.prototype.dd, xe.prototype.getLastErrorCode = xe.prototype.Db, xe.prototype.getStatus = xe.prototype.aa, xe.prototype.getStatusText = xe.prototype.Fb, xe.prototype.getResponseJson = xe.prototype.Nc, xe.prototype.getResponseText = xe.prototype.va, xe.prototype.send = xe.prototype.xa;\n\n      var Je = {\n        createWebChannelTransport: Xe,\n        ErrorCode: Zt,\n        EventType: te,\n        WebChannel: ne,\n        XhrIo: xe\n      },\n          $e = Je.createWebChannelTransport,\n          Ze = Je.ErrorCode,\n          tn = Je.EventType,\n          en = Je.WebChannel,\n          nn = Je.XhrIo,\n          rn = \"FirebaseError\",\n          on = Error.captureStackTrace,\n          sn = function sn(t, e) {\n        if (this.code = t, this.message = e, on) on(this, cn.prototype.create);else try {\n          throw Error.apply(this, arguments);\n        } catch (t) {\n          this.name = rn, Object.defineProperty(this, \"stack\", {\n            get: function get() {\n              return t.stack;\n            }\n          });\n        }\n      };\n\n      sn.prototype = Object.create(Error.prototype), (sn.prototype.constructor = sn).prototype.name = rn;\n\n      var an,\n          un,\n          cn = function () {\n        function t(t, e, n) {\n          this.service = t, this.serviceName = e, this.errors = n, this.pattern = /\\{\\$([^}]+)}/g;\n        }\n\n        return t.prototype.create = function (t, r) {\n          void 0 === r && (r = {});\n          var e,\n              n = this.errors[t],\n              i = this.service + \"/\" + t;\n          e = void 0 === n ? \"Error\" : n.replace(this.pattern, function (t, e) {\n            var n = r[e];\n            return void 0 !== n ? n.toString() : \"<\" + e + \"?>\";\n          }), e = this.serviceName + \": \" + e + \" (\" + i + \").\";\n          var o = new sn(i, e);\n\n          for (var s in r) {\n            r.hasOwnProperty(s) && \"_\" !== s.slice(-1) && (o[s] = r[s]);\n          }\n\n          return o;\n        }, t;\n      }(),\n          hn = (function (n) {\n        function t() {\n          var t = n.call(this) || this;\n          t.chain_ = [], t.buf_ = [], t.W_ = [], t.pad_ = [], t.inbuf_ = 0, t.total_ = 0, t.blockSize = 64, t.pad_[0] = 128;\n\n          for (var e = 1; e < t.blockSize; ++e) {\n            t.pad_[e] = 0;\n          }\n\n          return t.reset(), t;\n        }\n\n        a(t, n), t.prototype.reset = function () {\n          this.chain_[0] = 1732584193, this.chain_[1] = 4023233417, this.chain_[2] = 2562383102, this.chain_[3] = 271733878, this.chain_[4] = 3285377520, this.inbuf_ = 0, this.total_ = 0;\n        }, t.prototype.compress_ = function (t, e) {\n          e || (e = 0);\n          var n = this.W_;\n          if (\"string\" == typeof t) for (var r = 0; r < 16; r++) {\n            n[r] = t.charCodeAt(e) << 24 | t.charCodeAt(e + 1) << 16 | t.charCodeAt(e + 2) << 8 | t.charCodeAt(e + 3), e += 4;\n          } else for (r = 0; r < 16; r++) {\n            n[r] = t[e] << 24 | t[e + 1] << 16 | t[e + 2] << 8 | t[e + 3], e += 4;\n          }\n\n          for (r = 16; r < 80; r++) {\n            var i = n[r - 3] ^ n[r - 8] ^ n[r - 14] ^ n[r - 16];\n            n[r] = 4294967295 & (i << 1 | i >>> 31);\n          }\n\n          var o,\n              s,\n              a = this.chain_[0],\n              u = this.chain_[1],\n              c = this.chain_[2],\n              h = this.chain_[3],\n              l = this.chain_[4];\n\n          for (r = 0; r < 80; r++) {\n            s = r < 40 ? r < 20 ? (o = h ^ u & (c ^ h), 1518500249) : (o = u ^ c ^ h, 1859775393) : r < 60 ? (o = u & c | h & (u | c), 2400959708) : (o = u ^ c ^ h, 3395469782);\n            i = (a << 5 | a >>> 27) + o + l + s + n[r] & 4294967295;\n            l = h, h = c, c = 4294967295 & (u << 30 | u >>> 2), u = a, a = i;\n          }\n\n          this.chain_[0] = this.chain_[0] + a & 4294967295, this.chain_[1] = this.chain_[1] + u & 4294967295, this.chain_[2] = this.chain_[2] + c & 4294967295, this.chain_[3] = this.chain_[3] + h & 4294967295, this.chain_[4] = this.chain_[4] + l & 4294967295;\n        }, t.prototype.update = function (t, e) {\n          if (null != t) {\n            void 0 === e && (e = t.length);\n\n            for (var n = e - this.blockSize, r = 0, i = this.buf_, o = this.inbuf_; r < e;) {\n              if (0 == o) for (; r <= n;) {\n                this.compress_(t, r), r += this.blockSize;\n              }\n\n              if (\"string\" == typeof t) {\n                for (; r < e;) {\n                  if (i[o] = t.charCodeAt(r), ++r, ++o == this.blockSize) {\n                    this.compress_(i), o = 0;\n                    break;\n                  }\n                }\n              } else for (; r < e;) {\n                if (i[o] = t[r], ++r, ++o == this.blockSize) {\n                  this.compress_(i), o = 0;\n                  break;\n                }\n              }\n            }\n\n            this.inbuf_ = o, this.total_ += e;\n          }\n        }, t.prototype.digest = function () {\n          var t = [],\n              e = 8 * this.total_;\n          this.inbuf_ < 56 ? this.update(this.pad_, 56 - this.inbuf_) : this.update(this.pad_, this.blockSize - (this.inbuf_ - 56));\n\n          for (var n = this.blockSize - 1; 56 <= n; n--) {\n            this.buf_[n] = 255 & e, e /= 256;\n          }\n\n          this.compress_(this.buf_);\n          var r = 0;\n\n          for (n = 0; n < 5; n++) {\n            for (var i = 24; 0 <= i; i -= 8) {\n              t[r] = this.chain_[n] >> i & 255, ++r;\n            }\n          }\n\n          return t;\n        };\n      }(function () {\n        this.blockSize = -1;\n      }), sc.SDK_VERSION),\n          ln = new r(\"@firebase/firestore\");\n\n      function fn() {\n        return ln.logLevel === o.DEBUG ? an.DEBUG : ln.logLevel === o.SILENT ? an.SILENT : an.ERROR;\n      }\n\n      function pn(t) {\n        switch (t) {\n          case an.DEBUG:\n            ln.logLevel = o.DEBUG;\n            break;\n\n          case an.ERROR:\n            ln.logLevel = o.ERROR;\n            break;\n\n          case an.SILENT:\n            ln.logLevel = o.SILENT;\n            break;\n\n          default:\n            ln.error(\"Firestore (\" + hn + \"): Invalid value passed to `setLogLevel`\");\n        }\n      }\n\n      function dn(t, e) {\n        for (var n = [], r = 2; r < arguments.length; r++) {\n          n[r - 2] = arguments[r];\n        }\n\n        if (ln.logLevel <= o.DEBUG) {\n          var i = n.map(yn);\n          ln.debug.apply(ln, [\"Firestore (\" + hn + \") [\" + t + \"]: \" + e].concat(i));\n        }\n      }\n\n      function mn(t) {\n        for (var e = [], n = 1; n < arguments.length; n++) {\n          e[n - 1] = arguments[n];\n        }\n\n        if (ln.logLevel <= o.ERROR) {\n          var r = e.map(yn);\n          ln.error.apply(ln, [\"Firestore (\" + hn + \"): \" + t].concat(r));\n        }\n      }\n\n      function yn(e) {\n        if (\"string\" == typeof e) return e;\n        var t = bn.getPlatform();\n\n        try {\n          return t.formatJSON(e);\n        } catch (t) {\n          return e;\n        }\n      }\n\n      function gn(t) {\n        var e = \"FIRESTORE (\" + hn + \") INTERNAL ASSERTION FAILED: \" + t;\n        throw mn(e), new Error(e);\n      }\n\n      function vn(t, e) {\n        t || gn(e);\n      }\n\n      (un = an || (an = {}))[un.DEBUG = 0] = \"DEBUG\", un[un.ERROR = 1] = \"ERROR\", un[un.SILENT = 2] = \"SILENT\";\n\n      var bn = function () {\n        function e() {}\n\n        return e.setPlatform = function (t) {\n          e.platform && gn(\"Platform already defined\"), e.platform = t;\n        }, e.getPlatform = function () {\n          return e.platform || gn(\"Platform not set\"), e.platform;\n        }, e;\n      }();\n\n      function wn() {\n        return bn.getPlatform().emptyByteString;\n      }\n\n      var En = {\n        OK: \"ok\",\n        CANCELLED: \"cancelled\",\n        UNKNOWN: \"unknown\",\n        INVALID_ARGUMENT: \"invalid-argument\",\n        DEADLINE_EXCEEDED: \"deadline-exceeded\",\n        NOT_FOUND: \"not-found\",\n        ALREADY_EXISTS: \"already-exists\",\n        PERMISSION_DENIED: \"permission-denied\",\n        UNAUTHENTICATED: \"unauthenticated\",\n        RESOURCE_EXHAUSTED: \"resource-exhausted\",\n        FAILED_PRECONDITION: \"failed-precondition\",\n        ABORTED: \"aborted\",\n        OUT_OF_RANGE: \"out-of-range\",\n        UNIMPLEMENTED: \"unimplemented\",\n        INTERNAL: \"internal\",\n        UNAVAILABLE: \"unavailable\",\n        DATA_LOSS: \"data-loss\"\n      },\n          Sn = function (r) {\n        function t(t, e) {\n          var n = r.call(this, e) || this;\n          return n.code = t, n.message = e, n.name = \"FirebaseError\", n.toString = function () {\n            return n.name + \": [code=\" + n.code + \"]: \" + n.message;\n          }, n;\n        }\n\n        return a(t, r), t;\n      }(Error);\n\n      function Tn(t, e) {\n        function n() {\n          var t = \"This constructor is private.\";\n          throw e && (t += \" \", t += e), new Sn(En.INVALID_ARGUMENT, t);\n        }\n\n        for (var r in n.prototype = t.prototype, t) {\n          t.hasOwnProperty(r) && (n[r] = t[r]);\n        }\n\n        return n;\n      }\n\n      function In(t, e) {\n        return Object.prototype.hasOwnProperty.call(t, e);\n      }\n\n      function Cn(t, e) {\n        return void 0 !== t ? t : e;\n      }\n\n      function Dn(t, e) {\n        for (var n in t) {\n          if (Object.prototype.hasOwnProperty.call(t, n)) {\n            var r = Number(n);\n            isNaN(r) || e(r, t[n]);\n          }\n        }\n      }\n\n      function Nn(t, e) {\n        for (var n in t) {\n          Object.prototype.hasOwnProperty.call(t, n) && e(n, t[n]);\n        }\n      }\n\n      function An(t) {\n        for (var e in vn(null != t && \"object\" == typeof t, \"isEmpty() expects object parameter.\"), t) {\n          if (Object.prototype.hasOwnProperty.call(t, e)) return !1;\n        }\n\n        return !0;\n      }\n\n      function kn(t, e) {\n        if (0 !== e.length) throw new Sn(En.INVALID_ARGUMENT, \"Function \" + t + \"() does not support arguments, but was called with \" + Gn(e.length, \"argument\") + \".\");\n      }\n\n      function Rn(t, e, n) {\n        if (e.length !== n) throw new Sn(En.INVALID_ARGUMENT, \"Function \" + t + \"() requires \" + Gn(n, \"argument\") + \", but was called with \" + Gn(e.length, \"argument\") + \".\");\n      }\n\n      function Mn(t, e, n) {\n        if (e.length < n) throw new Sn(En.INVALID_ARGUMENT, \"Function \" + t + \"() requires at least \" + Gn(n, \"argument\") + \", but was called with \" + Gn(e.length, \"argument\") + \".\");\n      }\n\n      function _n(t, e, n, r) {\n        if (e.length < n || e.length > r) throw new Sn(En.INVALID_ARGUMENT, \"Function \" + t + \"() requires between \" + n + \" and \" + r + \" arguments, but was called with \" + Gn(e.length, \"argument\") + \".\");\n      }\n\n      function On(t, e, n, r) {\n        Vn(t, e, Wn(n) + \" argument\", r);\n      }\n\n      function Pn(t, e, n, r) {\n        void 0 !== r && On(t, e, n, r);\n      }\n\n      function Ln(t, e, n, r) {\n        Vn(t, e, n + \" option\", r);\n      }\n\n      function xn(t, e, n, r) {\n        void 0 !== r && Ln(t, e, n, r);\n      }\n\n      function qn(t, e, n, r, i) {\n        void 0 !== r && function (t, e, n, r, i) {\n          if (!(r instanceof Array)) throw new Sn(En.INVALID_ARGUMENT, \"Function \" + t + \"() requires its \" + e + \" option to be an array, but it was: \" + Un(r));\n\n          for (var o = 0; o < r.length; ++o) {\n            if (!i(r[o])) throw new Sn(En.INVALID_ARGUMENT, \"Function \" + t + \"() requires all \" + e + \" elements to be \" + n + \", but the value at index \" + o + \" was: \" + Un(r[o]));\n          }\n        }(t, e, n, r, i);\n      }\n\n      function Fn(t, e, n, r, i) {\n        void 0 !== r && function (t, e, n, r, i) {\n          for (var o = [], s = 0, a = i; s < a.length; s++) {\n            var u = a[s];\n            if (u === r) return;\n            o.push(Un(u));\n          }\n\n          var c = Un(r);\n          throw new Sn(En.INVALID_ARGUMENT, \"Invalid value \" + c + \" provided to function \" + t + '() for option \"' + n + '\". Acceptable values: ' + o.join(\", \"));\n        }(t, 0, n, r, i);\n      }\n\n      function Vn(t, e, n, r) {\n        if (!(\"object\" === e ? Bn(r) : \"non-empty string\" === e ? \"string\" == typeof r && \"\" !== r : typeof r === e)) {\n          var i = Un(r);\n          throw new Sn(En.INVALID_ARGUMENT, \"Function \" + t + \"() requires its \" + n + \" to be of type \" + e + \", but it was: \" + i);\n        }\n      }\n\n      function Bn(t) {\n        return \"object\" == typeof t && null !== t && (Object.getPrototypeOf(t) === Object.prototype || null === Object.getPrototypeOf(t));\n      }\n\n      function Un(t) {\n        if (void 0 === t) return \"undefined\";\n        if (null === t) return \"null\";\n        if (\"string\" == typeof t) return 20 < t.length && (t = t.substring(0, 20) + \"...\"), JSON.stringify(t);\n        if (\"number\" == typeof t || \"boolean\" == typeof t) return \"\" + t;\n        if (\"object\" != typeof t) return \"function\" == typeof t ? \"a function\" : gn(\"Unknown wrong type: \" + typeof t);\n        if (t instanceof Array) return \"an array\";\n\n        var e = function (t) {\n          if (t.constructor) {\n            var e = /function\\s+([^\\s(]+)\\s*\\(/.exec(t.constructor.toString());\n            if (e && 1 < e.length) return e[1];\n          }\n\n          return null;\n        }(t);\n\n        return e ? \"a custom \" + e + \" object\" : \"an object\";\n      }\n\n      function Qn(t, e, n) {\n        if (void 0 === n) throw new Sn(En.INVALID_ARGUMENT, \"Function \" + t + \"() requires a valid \" + Wn(e) + \" argument, but it was undefined.\");\n      }\n\n      function Kn(n, t, r) {\n        Nn(t, function (t, e) {\n          if (r.indexOf(t) < 0) throw new Sn(En.INVALID_ARGUMENT, \"Unknown option '\" + t + \"' passed to function \" + n + \"(). Available options: \" + r.join(\", \"));\n        });\n      }\n\n      function jn(t, e, n, r) {\n        var i = Un(r);\n        return new Sn(En.INVALID_ARGUMENT, \"Function \" + t + \"() requires its \" + Wn(n) + \" argument to be a \" + e + \", but it was: \" + i);\n      }\n\n      function Wn(t) {\n        switch (t) {\n          case 1:\n            return \"first\";\n\n          case 2:\n            return \"second\";\n\n          case 3:\n            return \"third\";\n\n          default:\n            return t + \"th\";\n        }\n      }\n\n      function Gn(t, e) {\n        return t + \" \" + e + (1 === t ? \"\" : \"s\");\n      }\n\n      var zn = function () {\n        function t() {}\n\n        return t.newId = function () {\n          for (var t = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789\", e = \"\", n = 0; n < 20; n++) {\n            e += t.charAt(Math.floor(Math.random() * t.length));\n          }\n\n          return vn(20 === e.length, \"Invalid auto ID: \" + e), e;\n        }, t;\n      }();\n\n      function Hn(t, e) {\n        return t < e ? -1 : e < t ? 1 : 0;\n      }\n\n      function Yn(t, e) {\n        if (t.length !== e.length) return !1;\n\n        for (var n = 0; n < t.length; n++) {\n          if (!t[n].isEqual(e[n])) return !1;\n        }\n\n        return !0;\n      }\n\n      function Xn(t) {\n        return t + \"\\0\";\n      }\n\n      function Jn() {\n        if (\"undefined\" == typeof Uint8Array) throw new Sn(En.UNIMPLEMENTED, \"Uint8Arrays are not available in this environment.\");\n      }\n\n      function $n() {\n        if (!bn.getPlatform().base64Available) throw new Sn(En.UNIMPLEMENTED, \"Blobs are unavailable in Firestore in this environment.\");\n      }\n\n      var Zn,\n          tr,\n          er,\n          nr,\n          rr = function () {\n        function e(t) {\n          $n(), this._binaryString = t;\n        }\n\n        return e.fromBase64String = function (t) {\n          Rn(\"Blob.fromBase64String\", arguments, 1), On(\"Blob.fromBase64String\", \"string\", 1, t), $n();\n\n          try {\n            return new e(bn.getPlatform().atob(t));\n          } catch (t) {\n            throw new Sn(En.INVALID_ARGUMENT, \"Failed to construct Blob from Base64 string: \" + t);\n          }\n        }, e.fromUint8Array = function (t) {\n          if (Rn(\"Blob.fromUint8Array\", arguments, 1), Jn(), !(t instanceof Uint8Array)) throw jn(\"Blob.fromUint8Array\", \"Uint8Array\", 1, t);\n          return new e(Array.prototype.map.call(t, function (t) {\n            return String.fromCharCode(t);\n          }).join(\"\"));\n        }, e.prototype.toBase64 = function () {\n          return Rn(\"Blob.toBase64\", arguments, 0), $n(), bn.getPlatform().btoa(this._binaryString);\n        }, e.prototype.toUint8Array = function () {\n          Rn(\"Blob.toUint8Array\", arguments, 0), Jn();\n\n          for (var t = new Uint8Array(this._binaryString.length), e = 0; e < this._binaryString.length; e++) {\n            t[e] = this._binaryString.charCodeAt(e);\n          }\n\n          return t;\n        }, e.prototype.toString = function () {\n          return \"Blob(base64: \" + this.toBase64() + \")\";\n        }, e.prototype.isEqual = function (t) {\n          return this._binaryString === t._binaryString;\n        }, e.prototype._compareTo = function (t) {\n          return Hn(this._binaryString, t._binaryString);\n        }, e;\n      }(),\n          ir = Tn(rr, \"Use Blob.fromUint8Array() or Blob.fromBase64String() instead.\"),\n          or = function () {\n        function t(t, e) {\n          if (Rn(\"GeoPoint\", arguments, 2), On(\"GeoPoint\", \"number\", 1, t), On(\"GeoPoint\", \"number\", 2, e), !isFinite(t) || t < -90 || 90 < t) throw new Sn(En.INVALID_ARGUMENT, \"Latitude must be a number between -90 and 90, but was: \" + t);\n          if (!isFinite(e) || e < -180 || 180 < e) throw new Sn(En.INVALID_ARGUMENT, \"Longitude must be a number between -180 and 180, but was: \" + e);\n          this._lat = t, this._long = e;\n        }\n\n        return Object.defineProperty(t.prototype, \"latitude\", {\n          get: function get() {\n            return this._lat;\n          },\n          enumerable: !0,\n          configurable: !0\n        }), Object.defineProperty(t.prototype, \"longitude\", {\n          get: function get() {\n            return this._long;\n          },\n          enumerable: !0,\n          configurable: !0\n        }), t.prototype.isEqual = function (t) {\n          return this._lat === t._lat && this._long === t._long;\n        }, t.prototype._compareTo = function (t) {\n          return Hn(this._lat, t._lat) || Hn(this._long, t._long);\n        }, t;\n      }(),\n          sr = function () {\n        function n(t, e) {\n          if (this.seconds = t, (this.nanoseconds = e) < 0) throw new Sn(En.INVALID_ARGUMENT, \"Timestamp nanoseconds out of range: \" + e);\n          if (1e9 <= e) throw new Sn(En.INVALID_ARGUMENT, \"Timestamp nanoseconds out of range: \" + e);\n          if (t < -62135596800) throw new Sn(En.INVALID_ARGUMENT, \"Timestamp seconds out of range: \" + t);\n          if (253402300800 <= t) throw new Sn(En.INVALID_ARGUMENT, \"Timestamp seconds out of range: \" + t);\n        }\n\n        return n.now = function () {\n          return n.fromMillis(Date.now());\n        }, n.fromDate = function (t) {\n          return n.fromMillis(t.getTime());\n        }, n.fromMillis = function (t) {\n          var e = Math.floor(t / 1e3);\n          return new n(e, 1e6 * (t - 1e3 * e));\n        }, n.prototype.toDate = function () {\n          return new Date(this.toMillis());\n        }, n.prototype.toMillis = function () {\n          return 1e3 * this.seconds + this.nanoseconds / 1e6;\n        }, n.prototype._compareTo = function (t) {\n          return this.seconds === t.seconds ? Hn(this.nanoseconds, t.nanoseconds) : Hn(this.seconds, t.seconds);\n        }, n.prototype.isEqual = function (t) {\n          return t.seconds === this.seconds && t.nanoseconds === this.nanoseconds;\n        }, n.prototype.toString = function () {\n          return \"Timestamp(seconds=\" + this.seconds + \", nanoseconds=\" + this.nanoseconds + \")\";\n        }, n;\n      }(),\n          ar = function ar(t, e, n, r) {\n        this.databaseId = t, this.persistenceKey = e, this.host = n, this.ssl = r;\n      },\n          ur = \"(default)\",\n          cr = function () {\n        function e(t, e) {\n          this.projectId = t, this.database = e || ur;\n        }\n\n        return Object.defineProperty(e.prototype, \"isDefaultDatabase\", {\n          get: function get() {\n            return this.database === ur;\n          },\n          enumerable: !0,\n          configurable: !0\n        }), e.prototype.isEqual = function (t) {\n          return t instanceof e && t.projectId === this.projectId && t.database === this.database;\n        }, e.prototype.compareTo = function (t) {\n          return Hn(this.projectId, t.projectId) || Hn(this.database, t.database);\n        }, e;\n      }(),\n          hr = \"__name__\",\n          lr = function () {\n        function n(t, e, n) {\n          this.init(t, e, n);\n        }\n\n        return n.prototype.init = function (t, e, n) {\n          void 0 === e ? e = 0 : e > t.length && gn(\"offset \" + e + \" out of range \" + t.length), void 0 === n ? n = t.length - e : n > t.length - e && gn(\"length \" + n + \" out of range \" + (t.length - e)), this.segments = t, this.offset = e, this.len = n;\n        }, n.prototype.construct = function (t, e, n) {\n          var r = Object.create(Object.getPrototypeOf(this));\n          return r.init(t, e, n), r;\n        }, Object.defineProperty(n.prototype, \"length\", {\n          get: function get() {\n            return this.len;\n          },\n          enumerable: !0,\n          configurable: !0\n        }), n.prototype.isEqual = function (t) {\n          return 0 === n.comparator(this, t);\n        }, n.prototype.child = function (t) {\n          var e = this.segments.slice(this.offset, this.limit());\n          return t instanceof n ? t.forEach(function (t) {\n            e.push(t);\n          }) : \"string\" == typeof t ? e.push(t) : gn(\"Unknown parameter type for Path.child(): \" + t), this.construct(e);\n        }, n.prototype.limit = function () {\n          return this.offset + this.length;\n        }, n.prototype.popFirst = function (t) {\n          return t = void 0 === t ? 1 : t, vn(this.length >= t, \"Can't call popFirst() with less segments\"), this.construct(this.segments, this.offset + t, this.length - t);\n        }, n.prototype.popLast = function () {\n          return vn(!this.isEmpty(), \"Can't call popLast() on empty path\"), this.construct(this.segments, this.offset, this.length - 1);\n        }, n.prototype.firstSegment = function () {\n          return vn(!this.isEmpty(), \"Can't call firstSegment() on empty path\"), this.segments[this.offset];\n        }, n.prototype.lastSegment = function () {\n          return this.get(this.length - 1);\n        }, n.prototype.get = function (t) {\n          return vn(t < this.length, \"Index out of range\"), this.segments[this.offset + t];\n        }, n.prototype.isEmpty = function () {\n          return 0 === this.length;\n        }, n.prototype.isPrefixOf = function (t) {\n          if (t.length < this.length) return !1;\n\n          for (var e = 0; e < this.length; e++) {\n            if (this.get(e) !== t.get(e)) return !1;\n          }\n\n          return !0;\n        }, n.prototype.isImmediateParentOf = function (t) {\n          if (this.length + 1 !== t.length) return !1;\n\n          for (var e = 0; e < this.length; e++) {\n            if (this.get(e) !== t.get(e)) return !1;\n          }\n\n          return !0;\n        }, n.prototype.forEach = function (t) {\n          for (var e = this.offset, n = this.limit(); e < n; e++) {\n            t(this.segments[e]);\n          }\n        }, n.prototype.toArray = function () {\n          return this.segments.slice(this.offset, this.limit());\n        }, n.comparator = function (t, e) {\n          for (var n = Math.min(t.length, e.length), r = 0; r < n; r++) {\n            var i = t.get(r),\n                o = e.get(r);\n            if (i < o) return -1;\n            if (o < i) return 1;\n          }\n\n          return t.length < e.length ? -1 : t.length > e.length ? 1 : 0;\n        }, n;\n      }(),\n          fr = function (t) {\n        function e() {\n          return null !== t && t.apply(this, arguments) || this;\n        }\n\n        return a(e, t), e.prototype.canonicalString = function () {\n          return this.toArray().join(\"/\");\n        }, e.prototype.toString = function () {\n          return this.canonicalString();\n        }, e.fromString = function (t) {\n          if (0 <= t.indexOf(\"//\")) throw new Sn(En.INVALID_ARGUMENT, \"Invalid path (\" + t + \"). Paths must not contain // in them.\");\n          return new e(t.split(\"/\").filter(function (t) {\n            return 0 < t.length;\n          }));\n        }, e.EMPTY_PATH = new e([]), e;\n      }(lr),\n          pr = /^[_a-zA-Z][_a-zA-Z0-9]*$/,\n          dr = function (t) {\n        function u() {\n          return null !== t && t.apply(this, arguments) || this;\n        }\n\n        return a(u, t), u.isValidIdentifier = function (t) {\n          return pr.test(t);\n        }, u.prototype.canonicalString = function () {\n          return this.toArray().map(function (t) {\n            return t = t.replace(\"\\\\\", \"\\\\\\\\\").replace(\"`\", \"\\\\`\"), u.isValidIdentifier(t) || (t = \"`\" + t + \"`\"), t;\n          }).join(\".\");\n        }, u.prototype.toString = function () {\n          return this.canonicalString();\n        }, u.prototype.isKeyField = function () {\n          return 1 === this.length && this.get(0) === hr;\n        }, u.keyField = function () {\n          return new u([hr]);\n        }, u.fromServerFormat = function (t) {\n          for (var e = [], n = \"\", r = 0, i = function i() {\n            if (0 === n.length) throw new Sn(En.INVALID_ARGUMENT, \"Invalid field path (\" + t + \"). Paths must not be empty, begin with '.', end with '.', or contain '..'\");\n            e.push(n), n = \"\";\n          }, o = !1; r < t.length;) {\n            var s = t[r];\n\n            if (\"\\\\\" === s) {\n              if (r + 1 === t.length) throw new Sn(En.INVALID_ARGUMENT, \"Path has trailing escape character: \" + t);\n              var a = t[r + 1];\n              if (\"\\\\\" !== a && \".\" !== a && \"`\" !== a) throw new Sn(En.INVALID_ARGUMENT, \"Path has invalid escape sequence: \" + t);\n              n += a, r += 2;\n            } else \"`\" === s ? o = !o : \".\" !== s || o ? n += s : i(), r++;\n          }\n\n          if (i(), o) throw new Sn(En.INVALID_ARGUMENT, \"Unterminated ` in path: \" + t);\n          return new u(e);\n        }, u.EMPTY_PATH = new u([]), u;\n      }(lr),\n          mr = function () {\n        function e(t) {\n          this.path = t, vn(e.isDocumentKey(t), \"Invalid DocumentKey with an odd number of segments: \" + t.toArray().join(\"/\"));\n        }\n\n        return e.prototype.hasCollectionId = function (t) {\n          return 2 <= this.path.length && this.path.get(this.path.length - 2) === t;\n        }, e.prototype.isEqual = function (t) {\n          return null !== t && 0 === fr.comparator(this.path, t.path);\n        }, e.prototype.toString = function () {\n          return this.path.toString();\n        }, e.comparator = function (t, e) {\n          return fr.comparator(t.path, e.path);\n        }, e.isDocumentKey = function (t) {\n          return t.length % 2 == 0;\n        }, e.fromSegments = function (t) {\n          return new e(new fr(t.slice()));\n        }, e.fromPathString = function (t) {\n          return new e(fr.fromString(t));\n        }, e.EMPTY = new e(new fr([])), e;\n      }(),\n          yr = function () {\n        function t(t, e) {\n          this.key = t, this.version = e;\n        }\n\n        return t.compareByKey = function (t, e) {\n          return mr.comparator(t.key, e.key);\n        }, t;\n      }(),\n          gr = function (s) {\n        function e(t, e, n, r, i) {\n          var o = s.call(this, t, e) || this;\n          return o.data = n, o.proto = i, o.hasLocalMutations = !!r.hasLocalMutations, o.hasCommittedMutations = !!r.hasCommittedMutations, o;\n        }\n\n        return a(e, s), e.prototype.field = function (t) {\n          return this.data.field(t);\n        }, e.prototype.fieldValue = function (t) {\n          var e = this.field(t);\n          return e ? e.value() : void 0;\n        }, e.prototype.value = function () {\n          return this.data.value();\n        }, e.prototype.isEqual = function (t) {\n          return t instanceof e && this.key.isEqual(t.key) && this.version.isEqual(t.version) && this.data.isEqual(t.data) && this.hasLocalMutations === t.hasLocalMutations && this.hasCommittedMutations === t.hasCommittedMutations;\n        }, e.prototype.toString = function () {\n          return \"Document(\" + this.key + \", \" + this.version + \", \" + this.data.toString() + \", {hasLocalMutations: \" + this.hasLocalMutations + \"}), {hasCommittedMutations: \" + this.hasCommittedMutations + \"})\";\n        }, Object.defineProperty(e.prototype, \"hasPendingWrites\", {\n          get: function get() {\n            return this.hasLocalMutations || this.hasCommittedMutations;\n          },\n          enumerable: !0,\n          configurable: !0\n        }), e.compareByField = function (t, e, n) {\n          var r = e.field(t),\n              i = n.field(t);\n          return void 0 !== r && void 0 !== i ? r.compareTo(i) : gn(\"Trying to compare documents on fields that don't exist\");\n        }, e;\n      }(yr),\n          vr = function (i) {\n        function e(t, e, n) {\n          var r = i.call(this, t, e) || this;\n          return r.hasCommittedMutations = !(!n || !n.hasCommittedMutations), r;\n        }\n\n        return a(e, i), e.prototype.toString = function () {\n          return \"NoDocument(\" + this.key + \", \" + this.version + \")\";\n        }, Object.defineProperty(e.prototype, \"hasPendingWrites\", {\n          get: function get() {\n            return this.hasCommittedMutations;\n          },\n          enumerable: !0,\n          configurable: !0\n        }), e.prototype.isEqual = function (t) {\n          return t instanceof e && t.hasCommittedMutations === this.hasCommittedMutations && t.version.isEqual(this.version) && t.key.isEqual(this.key);\n        }, e;\n      }(yr),\n          br = function (n) {\n        function e(t, e) {\n          return n.call(this, t, e) || this;\n        }\n\n        return a(e, n), e.prototype.toString = function () {\n          return \"UnknownDocument(\" + this.key + \", \" + this.version + \")\";\n        }, Object.defineProperty(e.prototype, \"hasPendingWrites\", {\n          get: function get() {\n            return !0;\n          },\n          enumerable: !0,\n          configurable: !0\n        }), e.prototype.isEqual = function (t) {\n          return t instanceof e && t.version.isEqual(this.version) && t.key.isEqual(this.key);\n        }, e;\n      }(yr),\n          wr = function () {\n        function n(t, e) {\n          this.comparator = t, this.root = e || Sr.EMPTY;\n        }\n\n        return n.prototype.insert = function (t, e) {\n          return new n(this.comparator, this.root.insert(t, e, this.comparator).copy(null, null, Sr.BLACK, null, null));\n        }, n.prototype.remove = function (t) {\n          return new n(this.comparator, this.root.remove(t, this.comparator).copy(null, null, Sr.BLACK, null, null));\n        }, n.prototype.get = function (t) {\n          for (var e = this.root; !e.isEmpty();) {\n            var n = this.comparator(t, e.key);\n            if (0 === n) return e.value;\n            n < 0 ? e = e.left : 0 < n && (e = e.right);\n          }\n\n          return null;\n        }, n.prototype.indexOf = function (t) {\n          for (var e = 0, n = this.root; !n.isEmpty();) {\n            var r = this.comparator(t, n.key);\n            if (0 === r) return e + n.left.size;\n            n = r < 0 ? n.left : (e += n.left.size + 1, n.right);\n          }\n\n          return -1;\n        }, n.prototype.isEmpty = function () {\n          return this.root.isEmpty();\n        }, Object.defineProperty(n.prototype, \"size\", {\n          get: function get() {\n            return this.root.size;\n          },\n          enumerable: !0,\n          configurable: !0\n        }), n.prototype.minKey = function () {\n          return this.root.minKey();\n        }, n.prototype.maxKey = function () {\n          return this.root.maxKey();\n        }, n.prototype.inorderTraversal = function (t) {\n          return this.root.inorderTraversal(t);\n        }, n.prototype.forEach = function (n) {\n          this.inorderTraversal(function (t, e) {\n            return n(t, e), !1;\n          });\n        }, n.prototype.toString = function () {\n          var n = [];\n          return this.inorderTraversal(function (t, e) {\n            return n.push(t + \":\" + e), !1;\n          }), \"{\" + n.join(\", \") + \"}\";\n        }, n.prototype.reverseTraversal = function (t) {\n          return this.root.reverseTraversal(t);\n        }, n.prototype.getIterator = function () {\n          return new Er(this.root, null, this.comparator, !1);\n        }, n.prototype.getIteratorFrom = function (t) {\n          return new Er(this.root, t, this.comparator, !1);\n        }, n.prototype.getReverseIterator = function () {\n          return new Er(this.root, null, this.comparator, !0);\n        }, n.prototype.getReverseIteratorFrom = function (t) {\n          return new Er(this.root, t, this.comparator, !0);\n        }, n;\n      }(),\n          Er = function () {\n        function t(t, e, n, r) {\n          this.isReverse = r, this.nodeStack = [];\n\n          for (var i = 1; !t.isEmpty();) {\n            if (i = e ? n(t.key, e) : 1, r && (i *= -1), i < 0) t = this.isReverse ? t.left : t.right;else {\n              if (0 === i) {\n                this.nodeStack.push(t);\n                break;\n              }\n\n              this.nodeStack.push(t), t = this.isReverse ? t.right : t.left;\n            }\n          }\n        }\n\n        return t.prototype.getNext = function () {\n          vn(0 < this.nodeStack.length, \"getNext() called on iterator when hasNext() is false.\");\n          var t = this.nodeStack.pop(),\n              e = {\n            key: t.key,\n            value: t.value\n          };\n          if (this.isReverse) for (t = t.left; !t.isEmpty();) {\n            this.nodeStack.push(t), t = t.right;\n          } else for (t = t.right; !t.isEmpty();) {\n            this.nodeStack.push(t), t = t.left;\n          }\n          return e;\n        }, t.prototype.hasNext = function () {\n          return 0 < this.nodeStack.length;\n        }, t.prototype.peek = function () {\n          if (0 === this.nodeStack.length) return null;\n          var t = this.nodeStack[this.nodeStack.length - 1];\n          return {\n            key: t.key,\n            value: t.value\n          };\n        }, t;\n      }(),\n          Sr = function () {\n        function o(t, e, n, r, i) {\n          this.key = t, this.value = e, this.color = null != n ? n : o.RED, this.left = null != r ? r : o.EMPTY, this.right = null != i ? i : o.EMPTY, this.size = this.left.size + 1 + this.right.size;\n        }\n\n        return o.prototype.copy = function (t, e, n, r, i) {\n          return new o(null != t ? t : this.key, null != e ? e : this.value, null != n ? n : this.color, null != r ? r : this.left, null != i ? i : this.right);\n        }, o.prototype.isEmpty = function () {\n          return !1;\n        }, o.prototype.inorderTraversal = function (t) {\n          return this.left.inorderTraversal(t) || t(this.key, this.value) || this.right.inorderTraversal(t);\n        }, o.prototype.reverseTraversal = function (t) {\n          return this.right.reverseTraversal(t) || t(this.key, this.value) || this.left.reverseTraversal(t);\n        }, o.prototype.min = function () {\n          return this.left.isEmpty() ? this : this.left.min();\n        }, o.prototype.minKey = function () {\n          return this.min().key;\n        }, o.prototype.maxKey = function () {\n          return this.right.isEmpty() ? this.key : this.right.maxKey();\n        }, o.prototype.insert = function (t, e, n) {\n          var r = this,\n              i = n(t, r.key);\n          return (r = i < 0 ? r.copy(null, null, null, r.left.insert(t, e, n), null) : 0 === i ? r.copy(null, e, null, null, null) : r.copy(null, null, null, null, r.right.insert(t, e, n))).fixUp();\n        }, o.prototype.removeMin = function () {\n          if (this.left.isEmpty()) return o.EMPTY;\n          var t = this;\n          return t.left.isRed() || t.left.left.isRed() || (t = t.moveRedLeft()), (t = t.copy(null, null, null, t.left.removeMin(), null)).fixUp();\n        }, o.prototype.remove = function (t, e) {\n          var n,\n              r = this;\n          if (e(t, r.key) < 0) r.left.isEmpty() || r.left.isRed() || r.left.left.isRed() || (r = r.moveRedLeft()), r = r.copy(null, null, null, r.left.remove(t, e), null);else {\n            if (r.left.isRed() && (r = r.rotateRight()), r.right.isEmpty() || r.right.isRed() || r.right.left.isRed() || (r = r.moveRedRight()), 0 === e(t, r.key)) {\n              if (r.right.isEmpty()) return o.EMPTY;\n              n = r.right.min(), r = r.copy(n.key, n.value, null, null, r.right.removeMin());\n            }\n\n            r = r.copy(null, null, null, null, r.right.remove(t, e));\n          }\n          return r.fixUp();\n        }, o.prototype.isRed = function () {\n          return this.color;\n        }, o.prototype.fixUp = function () {\n          var t = this;\n          return t.right.isRed() && !t.left.isRed() && (t = t.rotateLeft()), t.left.isRed() && t.left.left.isRed() && (t = t.rotateRight()), t.left.isRed() && t.right.isRed() && (t = t.colorFlip()), t;\n        }, o.prototype.moveRedLeft = function () {\n          var t = this.colorFlip();\n          return t.right.left.isRed() && (t = (t = (t = t.copy(null, null, null, null, t.right.rotateRight())).rotateLeft()).colorFlip()), t;\n        }, o.prototype.moveRedRight = function () {\n          var t = this.colorFlip();\n          return t.left.left.isRed() && (t = (t = t.rotateRight()).colorFlip()), t;\n        }, o.prototype.rotateLeft = function () {\n          var t = this.copy(null, null, o.RED, null, this.right.left);\n          return this.right.copy(null, null, this.color, t, null);\n        }, o.prototype.rotateRight = function () {\n          var t = this.copy(null, null, o.RED, this.left.right, null);\n          return this.left.copy(null, null, this.color, null, t);\n        }, o.prototype.colorFlip = function () {\n          var t = this.left.copy(null, null, !this.left.color, null, null),\n              e = this.right.copy(null, null, !this.right.color, null, null);\n          return this.copy(null, null, !this.color, t, e);\n        }, o.prototype.checkMaxDepth = function () {\n          var t = this.check();\n          return Math.pow(2, t) <= this.size + 1;\n        }, o.prototype.check = function () {\n          if (this.isRed() && this.left.isRed()) throw gn(\"Red node has red child(\" + this.key + \",\" + this.value + \")\");\n          if (this.right.isRed()) throw gn(\"Right child of (\" + this.key + \",\" + this.value + \") is red\");\n          var t = this.left.check();\n          if (t !== this.right.check()) throw gn(\"Black depths differ\");\n          return t + (this.isRed() ? 0 : 1);\n        }, o.EMPTY = null, o.RED = !0, o.BLACK = !1, o;\n      }(),\n          Tr = function () {\n        function t() {\n          this.size = 0;\n        }\n\n        return t.prototype.copy = function (t, e, n, r, i) {\n          return this;\n        }, t.prototype.insert = function (t, e, n) {\n          return new Sr(t, e);\n        }, t.prototype.remove = function (t, e) {\n          return this;\n        }, t.prototype.isEmpty = function () {\n          return !0;\n        }, t.prototype.inorderTraversal = function (t) {\n          return !1;\n        }, t.prototype.reverseTraversal = function (t) {\n          return !1;\n        }, t.prototype.minKey = function () {\n          return null;\n        }, t.prototype.maxKey = function () {\n          return null;\n        }, t.prototype.isRed = function () {\n          return !1;\n        }, t.prototype.checkMaxDepth = function () {\n          return !0;\n        }, t.prototype.check = function () {\n          return 0;\n        }, t;\n      }();\n\n      Sr.EMPTY = new Tr(), (tr = Zn || (Zn = {}))[tr.NullValue = 0] = \"NullValue\", tr[tr.BooleanValue = 1] = \"BooleanValue\", tr[tr.NumberValue = 2] = \"NumberValue\", tr[tr.TimestampValue = 3] = \"TimestampValue\", tr[tr.StringValue = 4] = \"StringValue\", tr[tr.BlobValue = 5] = \"BlobValue\", tr[tr.RefValue = 6] = \"RefValue\", tr[tr.GeoPointValue = 7] = \"GeoPointValue\", tr[tr.ArrayValue = 8] = \"ArrayValue\", tr[tr.ObjectValue = 9] = \"ObjectValue\", (nr = er || (er = {}))[nr.Default = 0] = \"Default\", nr[nr.Estimate = 1] = \"Estimate\", nr[nr.Previous = 2] = \"Previous\";\n\n      var Ir = function () {\n        function n(t, e) {\n          this.serverTimestampBehavior = t, this.timestampsInSnapshots = e;\n        }\n\n        return n.fromSnapshotOptions = function (t, e) {\n          switch (t.serverTimestamps) {\n            case \"estimate\":\n              return new n(er.Estimate, e);\n\n            case \"previous\":\n              return new n(er.Previous, e);\n\n            case \"none\":\n            case void 0:\n              return new n(er.Default, e);\n\n            default:\n              return gn(\"fromSnapshotOptions() called with invalid options.\");\n          }\n        }, n;\n      }(),\n          Cr = function () {\n        function t() {}\n\n        return t.prototype.toString = function () {\n          var t = this.value();\n          return null === t ? \"null\" : t.toString();\n        }, t.prototype.defaultCompareTo = function (t) {\n          return vn(this.typeOrder !== t.typeOrder, \"Default compareTo should not be used for values of same type.\"), Hn(this.typeOrder, t.typeOrder);\n        }, t;\n      }(),\n          Dr = function (e) {\n        function n() {\n          var t = e.call(this) || this;\n          return t.typeOrder = Zn.NullValue, t.internalValue = null, t;\n        }\n\n        return a(n, e), n.prototype.value = function (t) {\n          return null;\n        }, n.prototype.isEqual = function (t) {\n          return t instanceof n;\n        }, n.prototype.compareTo = function (t) {\n          return t instanceof n ? 0 : this.defaultCompareTo(t);\n        }, n.INSTANCE = new n(), n;\n      }(Cr),\n          Nr = function (n) {\n        function e(t) {\n          var e = n.call(this) || this;\n          return e.internalValue = t, e.typeOrder = Zn.BooleanValue, e;\n        }\n\n        return a(e, n), e.prototype.value = function (t) {\n          return this.internalValue;\n        }, e.prototype.isEqual = function (t) {\n          return t instanceof e && this.internalValue === t.internalValue;\n        }, e.prototype.compareTo = function (t) {\n          return t instanceof e ? Hn(this, t) : this.defaultCompareTo(t);\n        }, e.of = function (t) {\n          return t ? e.TRUE : e.FALSE;\n        }, e.TRUE = new e(!0), e.FALSE = new e(!1), e;\n      }(Cr),\n          Ar = function (n) {\n        function r(t) {\n          var e = n.call(this) || this;\n          return e.internalValue = t, e.typeOrder = Zn.NumberValue, e;\n        }\n\n        return a(r, n), r.prototype.value = function (t) {\n          return this.internalValue;\n        }, r.prototype.compareTo = function (t) {\n          return t instanceof r ? (e = this.internalValue, n = t.internalValue, e < n ? -1 : n < e ? 1 : e === n ? 0 : isNaN(e) ? isNaN(n) ? 0 : -1 : 1) : this.defaultCompareTo(t);\n          var e, n;\n        }, r;\n      }(Cr);\n\n      function kr(t, e) {\n        return t === e ? 0 !== t || 1 / t == 1 / e : t != t && e != e;\n      }\n\n      var Rr = function (e) {\n        function n(t) {\n          return e.call(this, t) || this;\n        }\n\n        return a(n, e), n.prototype.isEqual = function (t) {\n          return t instanceof n && kr(this.internalValue, t.internalValue);\n        }, n;\n      }(Ar),\n          Mr = function (n) {\n        function e(t) {\n          var e = n.call(this, t) || this;\n          return e.internalValue = t, e;\n        }\n\n        return a(e, n), e.prototype.isEqual = function (t) {\n          return t instanceof e && kr(this.internalValue, t.internalValue);\n        }, e.NAN = new e(NaN), e.POSITIVE_INFINITY = new e(1 / 0), e.NEGATIVE_INFINITY = new e(-1 / 0), e;\n      }(Ar),\n          _r = function (n) {\n        function e(t) {\n          var e = n.call(this) || this;\n          return e.internalValue = t, e.typeOrder = Zn.StringValue, e;\n        }\n\n        return a(e, n), e.prototype.value = function (t) {\n          return this.internalValue;\n        }, e.prototype.isEqual = function (t) {\n          return t instanceof e && this.internalValue === t.internalValue;\n        }, e.prototype.compareTo = function (t) {\n          return t instanceof e ? Hn(this.internalValue, t.internalValue) : this.defaultCompareTo(t);\n        }, e;\n      }(Cr),\n          Or = function (n) {\n        function e(t) {\n          var e = n.call(this) || this;\n          return e.internalValue = t, e.typeOrder = Zn.TimestampValue, e;\n        }\n\n        return a(e, n), e.prototype.value = function (t) {\n          return !t || t.timestampsInSnapshots ? this.internalValue : this.internalValue.toDate();\n        }, e.prototype.isEqual = function (t) {\n          return t instanceof e && this.internalValue.isEqual(t.internalValue);\n        }, e.prototype.compareTo = function (t) {\n          return t instanceof e ? this.internalValue._compareTo(t.internalValue) : t instanceof Pr ? -1 : this.defaultCompareTo(t);\n        }, e;\n      }(Cr),\n          Pr = function (r) {\n        function e(t, e) {\n          var n = r.call(this) || this;\n          return n.localWriteTime = t, n.previousValue = e, n.typeOrder = Zn.TimestampValue, n;\n        }\n\n        return a(e, r), e.prototype.value = function (t) {\n          return t && t.serverTimestampBehavior === er.Estimate ? new Or(this.localWriteTime).value(t) : t && t.serverTimestampBehavior === er.Previous && this.previousValue ? this.previousValue.value(t) : null;\n        }, e.prototype.isEqual = function (t) {\n          return t instanceof e && this.localWriteTime.isEqual(t.localWriteTime);\n        }, e.prototype.compareTo = function (t) {\n          return t instanceof e ? this.localWriteTime._compareTo(t.localWriteTime) : t instanceof Or ? 1 : this.defaultCompareTo(t);\n        }, e.prototype.toString = function () {\n          return \"<ServerTimestamp localTime=\" + this.localWriteTime.toString() + \">\";\n        }, e;\n      }(Cr),\n          Lr = function (n) {\n        function e(t) {\n          var e = n.call(this) || this;\n          return e.internalValue = t, e.typeOrder = Zn.BlobValue, e;\n        }\n\n        return a(e, n), e.prototype.value = function (t) {\n          return this.internalValue;\n        }, e.prototype.isEqual = function (t) {\n          return t instanceof e && this.internalValue.isEqual(t.internalValue);\n        }, e.prototype.compareTo = function (t) {\n          return t instanceof e ? this.internalValue._compareTo(t.internalValue) : this.defaultCompareTo(t);\n        }, e;\n      }(Cr),\n          xr = function (r) {\n        function n(t, e) {\n          var n = r.call(this) || this;\n          return n.databaseId = t, n.key = e, n.typeOrder = Zn.RefValue, n;\n        }\n\n        return a(n, r), n.prototype.value = function (t) {\n          return this.key;\n        }, n.prototype.isEqual = function (t) {\n          return t instanceof n && this.key.isEqual(t.key) && this.databaseId.isEqual(t.databaseId);\n        }, n.prototype.compareTo = function (t) {\n          if (t instanceof n) {\n            var e = this.databaseId.compareTo(t.databaseId);\n            return 0 !== e ? e : mr.comparator(this.key, t.key);\n          }\n\n          return this.defaultCompareTo(t);\n        }, n;\n      }(Cr),\n          qr = function (n) {\n        function e(t) {\n          var e = n.call(this) || this;\n          return e.internalValue = t, e.typeOrder = Zn.GeoPointValue, e;\n        }\n\n        return a(e, n), e.prototype.value = function (t) {\n          return this.internalValue;\n        }, e.prototype.isEqual = function (t) {\n          return t instanceof e && this.internalValue.isEqual(t.internalValue);\n        }, e.prototype.compareTo = function (t) {\n          return t instanceof e ? this.internalValue._compareTo(t.internalValue) : this.defaultCompareTo(t);\n        }, e;\n      }(Cr),\n          Fr = function (n) {\n        function s(t) {\n          var e = n.call(this) || this;\n          return e.internalValue = t, e.typeOrder = Zn.ObjectValue, e;\n        }\n\n        return a(s, n), s.prototype.value = function (n) {\n          var r = {};\n          return this.internalValue.inorderTraversal(function (t, e) {\n            r[t] = e.value(n);\n          }), r;\n        }, s.prototype.forEach = function (t) {\n          this.internalValue.inorderTraversal(t);\n        }, s.prototype.isEqual = function (t) {\n          if (t instanceof s) {\n            for (var e = this.internalValue.getIterator(), n = t.internalValue.getIterator(); e.hasNext() && n.hasNext();) {\n              var r = e.getNext(),\n                  i = n.getNext();\n              if (r.key !== i.key || !r.value.isEqual(i.value)) return !1;\n            }\n\n            return !e.hasNext() && !n.hasNext();\n          }\n\n          return !1;\n        }, s.prototype.compareTo = function (t) {\n          if (t instanceof s) {\n            for (var e = this.internalValue.getIterator(), n = t.internalValue.getIterator(); e.hasNext() && n.hasNext();) {\n              var r = e.getNext(),\n                  i = n.getNext(),\n                  o = Hn(r.key, i.key) || r.value.compareTo(i.value);\n              if (o) return o;\n            }\n\n            return Hn(e.hasNext(), n.hasNext());\n          }\n\n          return this.defaultCompareTo(t);\n        }, s.prototype.set = function (t, e) {\n          if (vn(!t.isEmpty(), \"Cannot set field for empty path on ObjectValue\"), 1 === t.length) return this.setChild(t.firstSegment(), e);\n          var n = this.child(t.firstSegment());\n          n instanceof s || (n = s.EMPTY);\n          var r = n.set(t.popFirst(), e);\n          return this.setChild(t.firstSegment(), r);\n        }, s.prototype.delete = function (t) {\n          if (vn(!t.isEmpty(), \"Cannot delete field for empty path on ObjectValue\"), 1 === t.length) return new s(this.internalValue.remove(t.firstSegment()));\n          var e = this.child(t.firstSegment());\n\n          if (e instanceof s) {\n            var n = e.delete(t.popFirst());\n            return new s(this.internalValue.insert(t.firstSegment(), n));\n          }\n\n          return this;\n        }, s.prototype.contains = function (t) {\n          return void 0 !== this.field(t);\n        }, s.prototype.field = function (t) {\n          vn(!t.isEmpty(), \"Can't get field of empty path\");\n          var e = this;\n          return t.forEach(function (t) {\n            e = e instanceof s && e.internalValue.get(t) || void 0;\n          }), e;\n        }, s.prototype.toString = function () {\n          return this.internalValue.toString();\n        }, s.prototype.child = function (t) {\n          return this.internalValue.get(t) || void 0;\n        }, s.prototype.setChild = function (t, e) {\n          return new s(this.internalValue.insert(t, e));\n        }, s.EMPTY = new s(new wr(Hn)), s;\n      }(Cr),\n          Vr = function (n) {\n        function i(t) {\n          var e = n.call(this) || this;\n          return e.internalValue = t, e.typeOrder = Zn.ArrayValue, e;\n        }\n\n        return a(i, n), i.prototype.value = function (e) {\n          return this.internalValue.map(function (t) {\n            return t.value(e);\n          });\n        }, i.prototype.forEach = function (t) {\n          this.internalValue.forEach(t);\n        }, i.prototype.isEqual = function (t) {\n          if (t instanceof i) {\n            if (this.internalValue.length !== t.internalValue.length) return !1;\n\n            for (var e = 0; e < this.internalValue.length; e++) {\n              if (!this.internalValue[e].isEqual(t.internalValue[e])) return !1;\n            }\n\n            return !0;\n          }\n\n          return !1;\n        }, i.prototype.compareTo = function (t) {\n          if (t instanceof i) {\n            for (var e = Math.min(this.internalValue.length, t.internalValue.length), n = 0; n < e; n++) {\n              var r = this.internalValue[n].compareTo(t.internalValue[n]);\n              if (r) return r;\n            }\n\n            return Hn(this.internalValue.length, t.internalValue.length);\n          }\n\n          return this.defaultCompareTo(t);\n        }, i.prototype.toString = function () {\n          return \"[\" + this.internalValue.map(function (t) {\n            return t.toString();\n          }).join(\",\") + \"]\";\n        }, i;\n      }(Cr),\n          Br = Number,\n          Ur = Br.MIN_SAFE_INTEGER || -(Math.pow(2, 53) - 1),\n          Qr = Br.MAX_SAFE_INTEGER || Math.pow(2, 53) - 1,\n          Kr = Br.isInteger || function (t) {\n        return \"number\" == typeof t && isFinite(t) && Math.floor(t) === t;\n      };\n\n      function jr(t) {\n        return null == t;\n      }\n\n      function Wr(t) {\n        return Kr(t) && t <= Qr && Ur <= t;\n      }\n\n      var Gr,\n          zr,\n          Hr = function () {\n        function n(t, e, n, r, i, o, s) {\n          void 0 === e && (e = null), void 0 === n && (n = []), void 0 === r && (r = []), void 0 === i && (i = null), void 0 === o && (o = null), void 0 === s && (s = null), this.path = t, this.collectionGroup = e, this.explicitOrderBy = n, this.filters = r, this.limit = i, this.startAt = o, this.endAt = s, this.memoizedCanonicalId = null, this.memoizedOrderBy = null, this.startAt && this.assertValidBound(this.startAt), this.endAt && this.assertValidBound(this.endAt);\n        }\n\n        return n.atPath = function (t) {\n          return new n(t);\n        }, Object.defineProperty(n.prototype, \"orderBy\", {\n          get: function get() {\n            if (null === this.memoizedOrderBy) {\n              var t = this.getInequalityFilterField(),\n                  e = this.getFirstOrderByField();\n              if (null !== t && null === e) t.isKeyField() ? this.memoizedOrderBy = [ri] : this.memoizedOrderBy = [new ni(t), ri];else {\n                vn(null === t || null !== e && t.isEqual(e), \"First orderBy should match inequality field.\");\n\n                for (var n = !(this.memoizedOrderBy = []), r = 0, i = this.explicitOrderBy; r < i.length; r++) {\n                  var o = i[r];\n                  this.memoizedOrderBy.push(o), o.field.isKeyField() && (n = !0);\n                }\n\n                if (!n) {\n                  var s = 0 < this.explicitOrderBy.length ? this.explicitOrderBy[this.explicitOrderBy.length - 1].dir : ti.ASCENDING;\n                  this.memoizedOrderBy.push(s === ti.ASCENDING ? ri : ii);\n                }\n              }\n            }\n\n            return this.memoizedOrderBy;\n          },\n          enumerable: !0,\n          configurable: !0\n        }), n.prototype.addFilter = function (t) {\n          vn(null == this.getInequalityFilterField() || !(t instanceof Jr) || !t.isInequality() || t.field.isEqual(this.getInequalityFilterField()), \"Query must only have one inequality field.\"), vn(!this.isDocumentQuery(), \"No filtering allowed for document query\");\n          var e = this.filters.concat([t]);\n          return new n(this.path, this.collectionGroup, this.explicitOrderBy.slice(), e, this.limit, this.startAt, this.endAt);\n        }, n.prototype.addOrderBy = function (t) {\n          vn(!this.startAt && !this.endAt, \"Bounds must be set after orderBy\");\n          var e = this.explicitOrderBy.concat([t]);\n          return new n(this.path, this.collectionGroup, e, this.filters.slice(), this.limit, this.startAt, this.endAt);\n        }, n.prototype.withLimit = function (t) {\n          return new n(this.path, this.collectionGroup, this.explicitOrderBy.slice(), this.filters.slice(), t, this.startAt, this.endAt);\n        }, n.prototype.withStartAt = function (t) {\n          return new n(this.path, this.collectionGroup, this.explicitOrderBy.slice(), this.filters.slice(), this.limit, t, this.endAt);\n        }, n.prototype.withEndAt = function (t) {\n          return new n(this.path, this.collectionGroup, this.explicitOrderBy.slice(), this.filters.slice(), this.limit, this.startAt, t);\n        }, n.prototype.asCollectionQueryAtPath = function (t) {\n          return new n(t, null, this.explicitOrderBy.slice(), this.filters.slice(), this.limit, this.startAt, this.endAt);\n        }, n.prototype.canonicalId = function () {\n          if (null === this.memoizedCanonicalId) {\n            var t = this.path.canonicalString();\n            this.isCollectionGroupQuery() && (t += \"|cg:\" + this.collectionGroup), t += \"|f:\";\n\n            for (var e = 0, n = this.filters; e < n.length; e++) {\n              t += n[e].canonicalId(), t += \",\";\n            }\n\n            t += \"|ob:\";\n\n            for (var r = 0, i = this.orderBy; r < i.length; r++) {\n              t += i[r].canonicalId(), t += \",\";\n            }\n\n            jr(this.limit) || (t += \"|l:\", t += this.limit), this.startAt && (t += \"|lb:\", t += this.startAt.canonicalId()), this.endAt && (t += \"|ub:\", t += this.endAt.canonicalId()), this.memoizedCanonicalId = t;\n          }\n\n          return this.memoizedCanonicalId;\n        }, n.prototype.toString = function () {\n          var t = \"Query(\" + this.path.canonicalString();\n          return this.isCollectionGroupQuery() && (t += \" collectionGroup=\" + this.collectionGroup), 0 < this.filters.length && (t += \", filters: [\" + this.filters.join(\", \") + \"]\"), jr(this.limit) || (t += \", limit: \" + this.limit), 0 < this.explicitOrderBy.length && (t += \", orderBy: [\" + this.explicitOrderBy.join(\", \") + \"]\"), this.startAt && (t += \", startAt: \" + this.startAt.canonicalId()), this.endAt && (t += \", endAt: \" + this.endAt.canonicalId()), t + \")\";\n        }, n.prototype.isEqual = function (t) {\n          if (this.limit !== t.limit) return !1;\n          if (this.orderBy.length !== t.orderBy.length) return !1;\n\n          for (var e = 0; e < this.orderBy.length; e++) {\n            if (!this.orderBy[e].isEqual(t.orderBy[e])) return !1;\n          }\n\n          if (this.filters.length !== t.filters.length) return !1;\n\n          for (e = 0; e < this.filters.length; e++) {\n            if (!this.filters[e].isEqual(t.filters[e])) return !1;\n          }\n\n          return this.collectionGroup === t.collectionGroup && !!this.path.isEqual(t.path) && !(null !== this.startAt ? !this.startAt.isEqual(t.startAt) : null !== t.startAt) && (null !== this.endAt ? this.endAt.isEqual(t.endAt) : null === t.endAt);\n        }, n.prototype.docComparator = function (t, e) {\n          for (var n = !1, r = 0, i = this.orderBy; r < i.length; r++) {\n            var o = i[r],\n                s = o.compare(t, e);\n            if (0 !== s) return s;\n            n = n || o.field.isKeyField();\n          }\n\n          return vn(n, \"orderBy used that doesn't compare on key field\"), 0;\n        }, n.prototype.matches = function (t) {\n          return this.matchesPathAndCollectionGroup(t) && this.matchesOrderBy(t) && this.matchesFilters(t) && this.matchesBounds(t);\n        }, n.prototype.hasLimit = function () {\n          return !jr(this.limit);\n        }, n.prototype.getFirstOrderByField = function () {\n          return 0 < this.explicitOrderBy.length ? this.explicitOrderBy[0].field : null;\n        }, n.prototype.getInequalityFilterField = function () {\n          for (var t = 0, e = this.filters; t < e.length; t++) {\n            var n = e[t];\n            if (n instanceof Jr && n.isInequality()) return n.field;\n          }\n\n          return null;\n        }, n.prototype.hasArrayContainsFilter = function () {\n          return void 0 !== this.filters.find(function (t) {\n            return t instanceof Jr && t.op === Xr.ARRAY_CONTAINS;\n          });\n        }, n.prototype.isDocumentQuery = function () {\n          return mr.isDocumentKey(this.path) && null === this.collectionGroup && 0 === this.filters.length;\n        }, n.prototype.isCollectionGroupQuery = function () {\n          return null !== this.collectionGroup;\n        }, n.prototype.matchesPathAndCollectionGroup = function (t) {\n          var e = t.key.path;\n          return null !== this.collectionGroup ? t.key.hasCollectionId(this.collectionGroup) && this.path.isPrefixOf(e) : mr.isDocumentKey(this.path) ? this.path.isEqual(e) : this.path.isImmediateParentOf(e);\n        }, n.prototype.matchesOrderBy = function (t) {\n          for (var e = 0, n = this.explicitOrderBy; e < n.length; e++) {\n            var r = n[e];\n            if (!r.field.isKeyField() && void 0 === t.field(r.field)) return !1;\n          }\n\n          return !0;\n        }, n.prototype.matchesFilters = function (t) {\n          for (var e = 0, n = this.filters; e < n.length; e++) {\n            if (!n[e].matches(t)) return !1;\n          }\n\n          return !0;\n        }, n.prototype.matchesBounds = function (t) {\n          return !(this.startAt && !this.startAt.sortsBeforeDocument(this.orderBy, t)) && (!this.endAt || !this.endAt.sortsBeforeDocument(this.orderBy, t));\n        }, n.prototype.assertValidBound = function (t) {\n          vn(t.position.length <= this.orderBy.length, \"Bound is longer than orderBy\");\n        }, n;\n      }(),\n          Yr = function () {\n        function t() {}\n\n        return t.create = function (t, e, n) {\n          if (n.isEqual(Dr.INSTANCE)) {\n            if (e !== Xr.EQUAL) throw new Sn(En.INVALID_ARGUMENT, \"Invalid query. You can only perform equals comparisons on null.\");\n            return new $r(t);\n          }\n\n          if (n.isEqual(Mr.NAN)) {\n            if (e !== Xr.EQUAL) throw new Sn(En.INVALID_ARGUMENT, \"Invalid query. You can only perform equals comparisons on NaN.\");\n            return new Zr(t);\n          }\n\n          return new Jr(t, e, n);\n        }, t;\n      }(),\n          Xr = function () {\n        function e(t) {\n          this.name = t;\n        }\n\n        return e.fromString = function (t) {\n          switch (t) {\n            case \"<\":\n              return e.LESS_THAN;\n\n            case \"<=\":\n              return e.LESS_THAN_OR_EQUAL;\n\n            case \"==\":\n              return e.EQUAL;\n\n            case \">=\":\n              return e.GREATER_THAN_OR_EQUAL;\n\n            case \">\":\n              return e.GREATER_THAN;\n\n            case \"array-contains\":\n              return e.ARRAY_CONTAINS;\n\n            default:\n              return gn(\"Unknown relation: \" + t);\n          }\n        }, e.prototype.toString = function () {\n          return this.name;\n        }, e.prototype.isEqual = function (t) {\n          return this.name === t.name;\n        }, e.LESS_THAN = new e(\"<\"), e.LESS_THAN_OR_EQUAL = new e(\"<=\"), e.EQUAL = new e(\"==\"), e.GREATER_THAN = new e(\">\"), e.GREATER_THAN_OR_EQUAL = new e(\">=\"), e.ARRAY_CONTAINS = new e(\"array-contains\"), e;\n      }(),\n          Jr = function (i) {\n        function e(t, e, n) {\n          var r = i.call(this) || this;\n          return r.field = t, r.op = e, r.value = n, r;\n        }\n\n        return a(e, i), e.prototype.matches = function (t) {\n          if (this.field.isKeyField()) {\n            vn(this.value instanceof xr, \"Comparing on key, but filter value not a RefValue\"), vn(this.op !== Xr.ARRAY_CONTAINS, \"array-contains queries don't make sense on document keys.\");\n            var e = this.value,\n                n = mr.comparator(t.key, e.key);\n            return this.matchesComparison(n);\n          }\n\n          var r = t.field(this.field);\n          return void 0 !== r && this.matchesValue(r);\n        }, e.prototype.matchesValue = function (t) {\n          var e = this;\n          return this.op === Xr.ARRAY_CONTAINS ? t instanceof Vr && void 0 !== t.internalValue.find(function (t) {\n            return t.isEqual(e.value);\n          }) : this.value.typeOrder === t.typeOrder && this.matchesComparison(t.compareTo(this.value));\n        }, e.prototype.matchesComparison = function (t) {\n          switch (this.op) {\n            case Xr.LESS_THAN:\n              return t < 0;\n\n            case Xr.LESS_THAN_OR_EQUAL:\n              return t <= 0;\n\n            case Xr.EQUAL:\n              return 0 === t;\n\n            case Xr.GREATER_THAN:\n              return 0 < t;\n\n            case Xr.GREATER_THAN_OR_EQUAL:\n              return 0 <= t;\n\n            default:\n              return gn(\"Unknown relation op\" + this.op);\n          }\n        }, e.prototype.isInequality = function () {\n          return this.op !== Xr.EQUAL && this.op !== Xr.ARRAY_CONTAINS;\n        }, e.prototype.canonicalId = function () {\n          return this.field.canonicalString() + this.op.toString() + this.value.toString();\n        }, e.prototype.isEqual = function (t) {\n          return t instanceof e && this.op.isEqual(t.op) && this.field.isEqual(t.field) && this.value.isEqual(t.value);\n        }, e.prototype.toString = function () {\n          return this.field.canonicalString() + \" \" + this.op + \" \" + this.value.value();\n        }, e;\n      }(Yr),\n          $r = function (n) {\n        function e(t) {\n          var e = n.call(this) || this;\n          return e.field = t, e;\n        }\n\n        return a(e, n), e.prototype.matches = function (t) {\n          var e = t.field(this.field);\n          return void 0 !== e && null === e.value();\n        }, e.prototype.canonicalId = function () {\n          return this.field.canonicalString() + \" IS null\";\n        }, e.prototype.toString = function () {\n          return this.field.canonicalString() + \" IS null\";\n        }, e.prototype.isEqual = function (t) {\n          return t instanceof e && this.field.isEqual(t.field);\n        }, e;\n      }(Yr),\n          Zr = function (n) {\n        function e(t) {\n          var e = n.call(this) || this;\n          return e.field = t, e;\n        }\n\n        return a(e, n), e.prototype.matches = function (t) {\n          var e = t.field(this.field),\n              n = e && e.value();\n          return \"number\" == typeof n && isNaN(n);\n        }, e.prototype.canonicalId = function () {\n          return this.field.canonicalString() + \" IS NaN\";\n        }, e.prototype.toString = function () {\n          return this.field.canonicalString() + \" IS NaN\";\n        }, e.prototype.isEqual = function (t) {\n          return t instanceof e && this.field.isEqual(t.field);\n        }, e;\n      }(Yr),\n          ti = function () {\n        function t(t) {\n          this.name = t;\n        }\n\n        return t.prototype.toString = function () {\n          return this.name;\n        }, t.ASCENDING = new t(\"asc\"), t.DESCENDING = new t(\"desc\"), t;\n      }(),\n          ei = function () {\n        function t(t, e) {\n          this.position = t, this.before = e;\n        }\n\n        return t.prototype.canonicalId = function () {\n          for (var t = this.before ? \"b:\" : \"a:\", e = 0, n = this.position; e < n.length; e++) {\n            t += n[e].toString();\n          }\n\n          return t;\n        }, t.prototype.sortsBeforeDocument = function (t, e) {\n          vn(this.position.length <= t.length, \"Bound has more components than query's orderBy\");\n\n          for (var n = 0, r = 0; r < this.position.length; r++) {\n            var i = t[r],\n                o = this.position[r];\n            if (i.field.isKeyField()) vn(o instanceof xr, \"Bound has a non-key value where the key path is being used.\"), n = mr.comparator(o.key, e.key);else {\n              var s = e.field(i.field);\n              vn(void 0 !== s, \"Field should exist since document matched the orderBy already.\"), n = o.compareTo(s);\n            }\n            if (i.dir === ti.DESCENDING && (n *= -1), 0 !== n) break;\n          }\n\n          return this.before ? n <= 0 : n < 0;\n        }, t.prototype.isEqual = function (t) {\n          if (null === t) return !1;\n          if (this.before !== t.before || this.position.length !== t.position.length) return !1;\n\n          for (var e = 0; e < this.position.length; e++) {\n            var n = this.position[e],\n                r = t.position[e];\n            return n.isEqual(r);\n          }\n\n          return !0;\n        }, t;\n      }(),\n          ni = function () {\n        function t(t, e) {\n          this.field = t, void 0 === e && (e = ti.ASCENDING), this.dir = e, this.isKeyOrderBy = t.isKeyField();\n        }\n\n        return t.prototype.compare = function (t, e) {\n          var n = this.isKeyOrderBy ? gr.compareByKey(t, e) : gr.compareByField(this.field, t, e);\n\n          switch (this.dir) {\n            case ti.ASCENDING:\n              return n;\n\n            case ti.DESCENDING:\n              return -1 * n;\n\n            default:\n              return gn(\"Unknown direction: \" + this.dir);\n          }\n        }, t.prototype.canonicalId = function () {\n          return this.field.canonicalString() + this.dir.toString();\n        }, t.prototype.toString = function () {\n          return this.field.canonicalString() + \" (\" + this.dir + \")\";\n        }, t.prototype.isEqual = function (t) {\n          return this.dir === t.dir && this.field.isEqual(t.field);\n        }, t;\n      }(),\n          ri = new ni(dr.keyField(), ti.ASCENDING),\n          ii = new ni(dr.keyField(), ti.DESCENDING),\n          oi = function () {\n        function n(t) {\n          this.timestamp = t;\n        }\n\n        return n.fromMicroseconds = function (t) {\n          var e = Math.floor(t / 1e6);\n          return new n(new sr(e, t % 1e6 * 1e3));\n        }, n.fromTimestamp = function (t) {\n          return new n(t);\n        }, n.forDeletedDoc = function () {\n          return n.MIN;\n        }, n.prototype.compareTo = function (t) {\n          return this.timestamp._compareTo(t.timestamp);\n        }, n.prototype.isEqual = function (t) {\n          return this.timestamp.isEqual(t.timestamp);\n        }, n.prototype.toMicroseconds = function () {\n          return 1e6 * this.timestamp.seconds + this.timestamp.nanoseconds / 1e3;\n        }, n.prototype.toString = function () {\n          return \"SnapshotVersion(\" + this.timestamp.toString() + \")\";\n        }, n.prototype.toTimestamp = function () {\n          return this.timestamp;\n        }, n.MIN = new n(new sr(0, 0)), n;\n      }();\n\n      (zr = Gr || (Gr = {}))[zr.Listen = 0] = \"Listen\", zr[zr.ExistenceFilterMismatch = 1] = \"ExistenceFilterMismatch\", zr[zr.LimboResolution = 2] = \"LimboResolution\";\n\n      var si,\n          ai,\n          ui = function () {\n        function e(t, e, n, r, i, o) {\n          void 0 === i && (i = oi.MIN), void 0 === o && (o = wn()), this.query = t, this.targetId = e, this.purpose = n, this.sequenceNumber = r, this.snapshotVersion = i, this.resumeToken = o;\n        }\n\n        return e.prototype.copy = function (t) {\n          return new e(this.query, this.targetId, this.purpose, void 0 === t.sequenceNumber ? this.sequenceNumber : t.sequenceNumber, void 0 === t.snapshotVersion ? this.snapshotVersion : t.snapshotVersion, void 0 === t.resumeToken ? this.resumeToken : t.resumeToken);\n        }, e.prototype.isEqual = function (t) {\n          return this.targetId === t.targetId && this.purpose === t.purpose && this.sequenceNumber === t.sequenceNumber && this.snapshotVersion.isEqual(t.snapshotVersion) && this.resumeToken === t.resumeToken && this.query.isEqual(t.query);\n        }, e;\n      }(),\n          ci = function () {\n        function o(t) {\n          this.comparator = t, this.data = new wr(this.comparator);\n        }\n\n        return o.fromMapKeys = function (t) {\n          var e = new o(t.comparator);\n          return t.forEach(function (t) {\n            e = e.add(t);\n          }), e;\n        }, o.prototype.has = function (t) {\n          return null !== this.data.get(t);\n        }, o.prototype.first = function () {\n          return this.data.minKey();\n        }, o.prototype.last = function () {\n          return this.data.maxKey();\n        }, Object.defineProperty(o.prototype, \"size\", {\n          get: function get() {\n            return this.data.size;\n          },\n          enumerable: !0,\n          configurable: !0\n        }), o.prototype.indexOf = function (t) {\n          return this.data.indexOf(t);\n        }, o.prototype.forEach = function (n) {\n          this.data.inorderTraversal(function (t, e) {\n            return n(t), !1;\n          });\n        }, o.prototype.forEachInRange = function (t, e) {\n          for (var n = this.data.getIteratorFrom(t[0]); n.hasNext();) {\n            var r = n.getNext();\n            if (0 <= this.comparator(r.key, t[1])) return;\n            e(r.key);\n          }\n        }, o.prototype.forEachWhile = function (t, e) {\n          var n;\n\n          for (n = void 0 !== e ? this.data.getIteratorFrom(e) : this.data.getIterator(); n.hasNext();) {\n            if (!t(n.getNext().key)) return;\n          }\n        }, o.prototype.firstAfterOrEqual = function (t) {\n          var e = this.data.getIteratorFrom(t);\n          return e.hasNext() ? e.getNext().key : null;\n        }, o.prototype.getIterator = function () {\n          return new hi(this.data.getIterator());\n        }, o.prototype.getIteratorFrom = function (t) {\n          return new hi(this.data.getIteratorFrom(t));\n        }, o.prototype.add = function (t) {\n          return this.copy(this.data.remove(t).insert(t, !0));\n        }, o.prototype.delete = function (t) {\n          return this.has(t) ? this.copy(this.data.remove(t)) : this;\n        }, o.prototype.isEmpty = function () {\n          return this.data.isEmpty();\n        }, o.prototype.unionWith = function (t) {\n          var e = this;\n          return t.forEach(function (t) {\n            e = e.add(t);\n          }), e;\n        }, o.prototype.isEqual = function (t) {\n          if (!(t instanceof o)) return !1;\n          if (this.size !== t.size) return !1;\n\n          for (var e = this.data.getIterator(), n = t.data.getIterator(); e.hasNext();) {\n            var r = e.getNext().key,\n                i = n.getNext().key;\n            if (0 !== this.comparator(r, i)) return !1;\n          }\n\n          return !0;\n        }, o.prototype.toArray = function () {\n          var e = [];\n          return this.forEach(function (t) {\n            e.push(t);\n          }), e;\n        }, o.prototype.toString = function () {\n          var e = [];\n          return this.forEach(function (t) {\n            return e.push(t);\n          }), \"SortedSet(\" + e.toString() + \")\";\n        }, o.prototype.copy = function (t) {\n          var e = new o(this.comparator);\n          return e.data = t, e;\n        }, o;\n      }(),\n          hi = function () {\n        function t(t) {\n          this.iter = t;\n        }\n\n        return t.prototype.getNext = function () {\n          return this.iter.getNext().key;\n        }, t.prototype.hasNext = function () {\n          return this.iter.hasNext();\n        }, t;\n      }(),\n          li = function () {\n        function n(t) {\n          this.fields = t;\n        }\n\n        return n.fromSet = function (t) {\n          return new n(t);\n        }, n.fromArray = function (t) {\n          var e = new ci(dr.comparator);\n          return t.forEach(function (t) {\n            return e = e.add(t);\n          }), new n(e);\n        }, n.prototype.covers = function (e) {\n          var n = !1;\n          return this.fields.forEach(function (t) {\n            t.isPrefixOf(e) && (n = !0);\n          }), n;\n        }, n.prototype.applyTo = function (n) {\n          var r = Fr.EMPTY;\n          return this.fields.forEach(function (t) {\n            if (t.isEmpty()) return n;\n            var e = n.field(t);\n            void 0 !== e && (r = r.set(t, e));\n          }), r;\n        }, n.prototype.isEqual = function (t) {\n          return this.fields.isEqual(t.fields);\n        }, n;\n      }(),\n          fi = function () {\n        function t(t, e) {\n          this.field = t, this.transform = e;\n        }\n\n        return Object.defineProperty(t.prototype, \"isIdempotent\", {\n          get: function get() {\n            return this.transform.isIdempotent;\n          },\n          enumerable: !0,\n          configurable: !0\n        }), t.prototype.isEqual = function (t) {\n          return this.field.isEqual(t.field) && this.transform.isEqual(t.transform);\n        }, t;\n      }(),\n          pi = function pi(t, e) {\n        this.version = t, this.transformResults = e;\n      };\n\n      (ai = si || (si = {}))[ai.Set = 0] = \"Set\", ai[ai.Patch = 1] = \"Patch\", ai[ai.Transform = 2] = \"Transform\", ai[ai.Delete = 3] = \"Delete\";\n\n      var di = function () {\n        function e(t, e) {\n          this.updateTime = t, this.exists = e, vn(void 0 === t || void 0 === e, 'Precondition can specify \"exists\" or \"updateTime\" but not both');\n        }\n\n        return e.exists = function (t) {\n          return new e(void 0, t);\n        }, e.updateTime = function (t) {\n          return new e(t);\n        }, Object.defineProperty(e.prototype, \"isNone\", {\n          get: function get() {\n            return void 0 === this.updateTime && void 0 === this.exists;\n          },\n          enumerable: !0,\n          configurable: !0\n        }), e.prototype.isValidFor = function (t) {\n          return void 0 !== this.updateTime ? t instanceof gr && t.version.isEqual(this.updateTime) : void 0 !== this.exists ? this.exists === t instanceof gr : (vn(this.isNone, \"Precondition should be empty\"), !0);\n        }, e.prototype.isEqual = function (t) {\n          return e = this.updateTime, n = t.updateTime, (null != e ? !(!n || !e.isEqual(n)) : e === n) && this.exists === t.exists;\n          var e, n;\n        }, e.NONE = new e(), e;\n      }(),\n          mi = function () {\n        function t() {}\n\n        return t.prototype.verifyKeyMatches = function (t) {\n          null != t && vn(t.key.isEqual(this.key), \"Can only apply a mutation to a document with the same key\");\n        }, t.getPostMutationVersion = function (t) {\n          return t instanceof gr ? t.version : oi.MIN;\n        }, t;\n      }(),\n          yi = function (i) {\n        function e(t, e, n) {\n          var r = i.call(this) || this;\n          return r.key = t, r.value = e, r.precondition = n, r.type = si.Set, r;\n        }\n\n        return a(e, i), e.prototype.applyToRemoteDocument = function (t, e) {\n          this.verifyKeyMatches(t), vn(null == e.transformResults, \"Transform results received by SetMutation.\");\n          var n = e.version;\n          return new gr(this.key, n, this.value, {\n            hasCommittedMutations: !0\n          });\n        }, e.prototype.applyToLocalView = function (t, e, n) {\n          if (this.verifyKeyMatches(t), !this.precondition.isValidFor(t)) return t;\n          var r = mi.getPostMutationVersion(t);\n          return new gr(this.key, r, this.value, {\n            hasLocalMutations: !0\n          });\n        }, Object.defineProperty(e.prototype, \"isIdempotent\", {\n          get: function get() {\n            return !0;\n          },\n          enumerable: !0,\n          configurable: !0\n        }), Object.defineProperty(e.prototype, \"fieldMask\", {\n          get: function get() {\n            return null;\n          },\n          enumerable: !0,\n          configurable: !0\n        }), e.prototype.isEqual = function (t) {\n          return t instanceof e && this.key.isEqual(t.key) && this.value.isEqual(t.value) && this.precondition.isEqual(t.precondition);\n        }, e;\n      }(mi),\n          gi = function (o) {\n        function e(t, e, n, r) {\n          var i = o.call(this) || this;\n          return i.key = t, i.data = e, i.fieldMask = n, i.precondition = r, i.type = si.Patch, i;\n        }\n\n        return a(e, o), e.prototype.applyToRemoteDocument = function (t, e) {\n          if (this.verifyKeyMatches(t), vn(null == e.transformResults, \"Transform results received by PatchMutation.\"), !this.precondition.isValidFor(t)) return new br(this.key, e.version);\n          var n = this.patchDocument(t);\n          return new gr(this.key, e.version, n, {\n            hasCommittedMutations: !0\n          });\n        }, e.prototype.applyToLocalView = function (t, e, n) {\n          if (this.verifyKeyMatches(t), !this.precondition.isValidFor(t)) return t;\n          var r = mi.getPostMutationVersion(t),\n              i = this.patchDocument(t);\n          return new gr(this.key, r, i, {\n            hasLocalMutations: !0\n          });\n        }, Object.defineProperty(e.prototype, \"isIdempotent\", {\n          get: function get() {\n            return !0;\n          },\n          enumerable: !0,\n          configurable: !0\n        }), e.prototype.isEqual = function (t) {\n          return t instanceof e && this.key.isEqual(t.key) && this.fieldMask.isEqual(t.fieldMask) && this.precondition.isEqual(t.precondition);\n        }, e.prototype.patchDocument = function (t) {\n          var e;\n          return e = t instanceof gr ? t.data : Fr.EMPTY, this.patchObject(e);\n        }, e.prototype.patchObject = function (n) {\n          var r = this;\n          return this.fieldMask.fields.forEach(function (t) {\n            if (!t.isEmpty()) {\n              var e = r.data.field(t);\n              n = void 0 !== e ? n.set(t, e) : n.delete(t);\n            }\n          }), n;\n        }, e;\n      }(mi),\n          vi = function (r) {\n        function e(t, e) {\n          var n = r.call(this) || this;\n          return n.key = t, n.fieldTransforms = e, n.type = si.Transform, n.precondition = di.exists(!0), n;\n        }\n\n        return a(e, r), e.prototype.applyToRemoteDocument = function (t, e) {\n          if (this.verifyKeyMatches(t), vn(null != e.transformResults, \"Transform results missing for TransformMutation.\"), !this.precondition.isValidFor(t)) return new br(this.key, e.version);\n          var n = this.requireDocument(t),\n              r = this.serverTransformResults(t, e.transformResults),\n              i = e.version,\n              o = this.transformObject(n.data, r);\n          return new gr(this.key, i, o, {\n            hasCommittedMutations: !0\n          });\n        }, e.prototype.applyToLocalView = function (t, e, n) {\n          if (this.verifyKeyMatches(t), !this.precondition.isValidFor(t)) return t;\n          var r = this.requireDocument(t),\n              i = this.localTransformResults(n, e),\n              o = this.transformObject(r.data, i);\n          return new gr(this.key, r.version, o, {\n            hasLocalMutations: !0\n          });\n        }, Object.defineProperty(e.prototype, \"isIdempotent\", {\n          get: function get() {\n            for (var t = 0, e = this.fieldTransforms; t < e.length; t++) {\n              if (!e[t].isIdempotent) return !1;\n            }\n\n            return !0;\n          },\n          enumerable: !0,\n          configurable: !0\n        }), Object.defineProperty(e.prototype, \"fieldMask\", {\n          get: function get() {\n            var e = new ci(dr.comparator);\n            return this.fieldTransforms.forEach(function (t) {\n              return e = e.add(t.field);\n            }), new li(e);\n          },\n          enumerable: !0,\n          configurable: !0\n        }), e.prototype.isEqual = function (t) {\n          return t instanceof e && this.key.isEqual(t.key) && Yn(this.fieldTransforms, t.fieldTransforms) && this.precondition.isEqual(t.precondition);\n        }, e.prototype.requireDocument = function (t) {\n          vn(t instanceof gr, \"Unknown MaybeDocument type \" + t);\n          var e = t;\n          return vn(e.key.isEqual(this.key), \"Can only transform a document with the same key\"), e;\n        }, e.prototype.serverTransformResults = function (t, e) {\n          var n = [];\n          vn(this.fieldTransforms.length === e.length, \"server transform result count (\" + e.length + \") should match field transform count (\" + this.fieldTransforms.length + \")\");\n\n          for (var r = 0; r < e.length; r++) {\n            var i = this.fieldTransforms[r],\n                o = i.transform,\n                s = null;\n            t instanceof gr && (s = t.field(i.field) || null), n.push(o.applyToRemoteDocument(s, e[r]));\n          }\n\n          return n;\n        }, e.prototype.localTransformResults = function (t, e) {\n          for (var n = [], r = 0, i = this.fieldTransforms; r < i.length; r++) {\n            var o = i[r],\n                s = o.transform,\n                a = null;\n            e instanceof gr && (a = e.field(o.field) || null), n.push(s.applyToLocalView(a, t));\n          }\n\n          return n;\n        }, e.prototype.transformObject = function (t, e) {\n          vn(e.length === this.fieldTransforms.length, \"TransformResults length mismatch.\");\n\n          for (var n = 0; n < this.fieldTransforms.length; n++) {\n            var r = this.fieldTransforms[n].field;\n            t = t.set(r, e[n]);\n          }\n\n          return t;\n        }, e;\n      }(mi),\n          bi = function (r) {\n        function e(t, e) {\n          var n = r.call(this) || this;\n          return n.key = t, n.precondition = e, n.type = si.Delete, n;\n        }\n\n        return a(e, r), e.prototype.applyToRemoteDocument = function (t, e) {\n          return this.verifyKeyMatches(t), vn(null == e.transformResults, \"Transform results received by DeleteMutation.\"), new vr(this.key, e.version, {\n            hasCommittedMutations: !0\n          });\n        }, e.prototype.applyToLocalView = function (t, e, n) {\n          return this.verifyKeyMatches(t), this.precondition.isValidFor(t) ? (t && vn(t.key.isEqual(this.key), \"Can only apply mutation to document with same key\"), new vr(this.key, oi.forDeletedDoc())) : t;\n        }, e.prototype.isEqual = function (t) {\n          return t instanceof e && this.key.isEqual(t.key) && this.precondition.isEqual(t.precondition);\n        }, Object.defineProperty(e.prototype, \"isIdempotent\", {\n          get: function get() {\n            return !0;\n          },\n          enumerable: !0,\n          configurable: !0\n        }), Object.defineProperty(e.prototype, \"fieldMask\", {\n          get: function get() {\n            return null;\n          },\n          enumerable: !0,\n          configurable: !0\n        }), e;\n      }(mi),\n          wi = function () {\n        function e() {\n          this.isIdempotent = !0;\n        }\n\n        return e.prototype.applyToLocalView = function (t, e) {\n          return new Pr(e, t);\n        }, e.prototype.applyToRemoteDocument = function (t, e) {\n          return e;\n        }, e.prototype.isEqual = function (t) {\n          return t instanceof e;\n        }, e.instance = new e(), e;\n      }(),\n          Ei = function () {\n        function e(t) {\n          this.elements = t, this.isIdempotent = !0;\n        }\n\n        return e.prototype.applyToLocalView = function (t, e) {\n          return this.apply(t);\n        }, e.prototype.applyToRemoteDocument = function (t, e) {\n          return this.apply(t);\n        }, e.prototype.apply = function (t) {\n          for (var n = Ii(t), e = function e(_e2) {\n            n.find(function (t) {\n              return t.isEqual(_e2);\n            }) || n.push(_e2);\n          }, r = 0, i = this.elements; r < i.length; r++) {\n            e(i[r]);\n          }\n\n          return new Vr(n);\n        }, e.prototype.isEqual = function (t) {\n          return t instanceof e && Yn(t.elements, this.elements);\n        }, e;\n      }(),\n          Si = function () {\n        function e(t) {\n          this.elements = t, this.isIdempotent = !0;\n        }\n\n        return e.prototype.applyToLocalView = function (t, e) {\n          return this.apply(t);\n        }, e.prototype.applyToRemoteDocument = function (t, e) {\n          return this.apply(t);\n        }, e.prototype.apply = function (t) {\n          for (var n = Ii(t), e = function e(_e3) {\n            n = n.filter(function (t) {\n              return !t.isEqual(_e3);\n            });\n          }, r = 0, i = this.elements; r < i.length; r++) {\n            e(i[r]);\n          }\n\n          return new Vr(n);\n        }, e.prototype.isEqual = function (t) {\n          return t instanceof e && Yn(t.elements, this.elements);\n        }, e;\n      }(),\n          Ti = function () {\n        function e(t) {\n          this.operand = t, this.isIdempotent = !1;\n        }\n\n        return e.prototype.applyToLocalView = function (t, e) {\n          if (t instanceof Rr && this.operand instanceof Rr) {\n            var n = t.internalValue + this.operand.internalValue;\n            return new Rr(n);\n          }\n\n          if (t instanceof Ar) {\n            n = t.internalValue + this.operand.internalValue;\n            return new Mr(n);\n          }\n\n          return this.operand;\n        }, e.prototype.applyToRemoteDocument = function (t, e) {\n          return vn(null !== e, \"Didn't receive transformResult for NUMERIC_ADD transform\"), e;\n        }, e.prototype.isEqual = function (t) {\n          return t instanceof e && this.operand.isEqual(t.operand);\n        }, e;\n      }();\n\n      function Ii(t) {\n        return t instanceof Vr ? t.internalValue.slice() : [];\n      }\n\n      var Ci,\n          Di,\n          Ni = function () {\n        function t(t) {\n          this.count = t;\n        }\n\n        return t.prototype.isEqual = function (t) {\n          return t && t.count === this.count;\n        }, t;\n      }();\n\n      function Ai(t) {\n        switch (t) {\n          case En.OK:\n            return gn(\"Treated status OK as error\");\n\n          case En.CANCELLED:\n          case En.UNKNOWN:\n          case En.DEADLINE_EXCEEDED:\n          case En.RESOURCE_EXHAUSTED:\n          case En.INTERNAL:\n          case En.UNAVAILABLE:\n          case En.UNAUTHENTICATED:\n            return !1;\n\n          case En.INVALID_ARGUMENT:\n          case En.NOT_FOUND:\n          case En.ALREADY_EXISTS:\n          case En.PERMISSION_DENIED:\n          case En.FAILED_PRECONDITION:\n          case En.ABORTED:\n          case En.OUT_OF_RANGE:\n          case En.UNIMPLEMENTED:\n          case En.DATA_LOSS:\n            return !0;\n\n          default:\n            return gn(\"Unknown status code: \" + t);\n        }\n      }\n\n      function ki(t) {\n        if (void 0 === t) return mn(\"GRPC error has no .code\"), En.UNKNOWN;\n\n        switch (t) {\n          case Ci.OK:\n            return En.OK;\n\n          case Ci.CANCELLED:\n            return En.CANCELLED;\n\n          case Ci.UNKNOWN:\n            return En.UNKNOWN;\n\n          case Ci.DEADLINE_EXCEEDED:\n            return En.DEADLINE_EXCEEDED;\n\n          case Ci.RESOURCE_EXHAUSTED:\n            return En.RESOURCE_EXHAUSTED;\n\n          case Ci.INTERNAL:\n            return En.INTERNAL;\n\n          case Ci.UNAVAILABLE:\n            return En.UNAVAILABLE;\n\n          case Ci.UNAUTHENTICATED:\n            return En.UNAUTHENTICATED;\n\n          case Ci.INVALID_ARGUMENT:\n            return En.INVALID_ARGUMENT;\n\n          case Ci.NOT_FOUND:\n            return En.NOT_FOUND;\n\n          case Ci.ALREADY_EXISTS:\n            return En.ALREADY_EXISTS;\n\n          case Ci.PERMISSION_DENIED:\n            return En.PERMISSION_DENIED;\n\n          case Ci.FAILED_PRECONDITION:\n            return En.FAILED_PRECONDITION;\n\n          case Ci.ABORTED:\n            return En.ABORTED;\n\n          case Ci.OUT_OF_RANGE:\n            return En.OUT_OF_RANGE;\n\n          case Ci.UNIMPLEMENTED:\n            return En.UNIMPLEMENTED;\n\n          case Ci.DATA_LOSS:\n            return En.DATA_LOSS;\n\n          default:\n            return gn(\"Unknown status code: \" + t);\n        }\n      }\n\n      (Di = Ci || (Ci = {}))[Di.OK = 0] = \"OK\", Di[Di.CANCELLED = 1] = \"CANCELLED\", Di[Di.UNKNOWN = 2] = \"UNKNOWN\", Di[Di.INVALID_ARGUMENT = 3] = \"INVALID_ARGUMENT\", Di[Di.DEADLINE_EXCEEDED = 4] = \"DEADLINE_EXCEEDED\", Di[Di.NOT_FOUND = 5] = \"NOT_FOUND\", Di[Di.ALREADY_EXISTS = 6] = \"ALREADY_EXISTS\", Di[Di.PERMISSION_DENIED = 7] = \"PERMISSION_DENIED\", Di[Di.UNAUTHENTICATED = 16] = \"UNAUTHENTICATED\", Di[Di.RESOURCE_EXHAUSTED = 8] = \"RESOURCE_EXHAUSTED\", Di[Di.FAILED_PRECONDITION = 9] = \"FAILED_PRECONDITION\", Di[Di.ABORTED = 10] = \"ABORTED\", Di[Di.OUT_OF_RANGE = 11] = \"OUT_OF_RANGE\", Di[Di.UNIMPLEMENTED = 12] = \"UNIMPLEMENTED\", Di[Di.INTERNAL = 13] = \"INTERNAL\", Di[Di.UNAVAILABLE = 14] = \"UNAVAILABLE\", Di[Di.DATA_LOSS = 15] = \"DATA_LOSS\";\n      var Ri = new wr(mr.comparator);\n\n      function Mi() {\n        return Ri;\n      }\n\n      function _i() {\n        return Mi();\n      }\n\n      var Oi = new wr(mr.comparator);\n\n      function Pi() {\n        return Oi;\n      }\n\n      var Li = new wr(mr.comparator);\n\n      function xi() {\n        return Li;\n      }\n\n      var qi = new ci(mr.comparator);\n\n      function Fi() {\n        for (var t = [], e = 0; e < arguments.length; e++) {\n          t[e] = arguments[e];\n        }\n\n        for (var n = qi, r = 0, i = t; r < i.length; r++) {\n          var o = i[r];\n          n = n.add(o);\n        }\n\n        return n;\n      }\n\n      var Vi = new ci(Hn);\n\n      function Bi() {\n        return Vi;\n      }\n\n      var Ui,\n          Qi,\n          Ki,\n          ji,\n          Wi = function () {\n        function o(n) {\n          this.comparator = n ? function (t, e) {\n            return n(t, e) || mr.comparator(t.key, e.key);\n          } : function (t, e) {\n            return mr.comparator(t.key, e.key);\n          }, this.keyedMap = Pi(), this.sortedSet = new wr(this.comparator);\n        }\n\n        return o.emptySet = function (t) {\n          return new o(t.comparator);\n        }, o.prototype.has = function (t) {\n          return null != this.keyedMap.get(t);\n        }, o.prototype.get = function (t) {\n          return this.keyedMap.get(t);\n        }, o.prototype.first = function () {\n          return this.sortedSet.minKey();\n        }, o.prototype.last = function () {\n          return this.sortedSet.maxKey();\n        }, o.prototype.isEmpty = function () {\n          return this.sortedSet.isEmpty();\n        }, o.prototype.indexOf = function (t) {\n          var e = this.keyedMap.get(t);\n          return e ? this.sortedSet.indexOf(e) : -1;\n        }, Object.defineProperty(o.prototype, \"size\", {\n          get: function get() {\n            return this.sortedSet.size;\n          },\n          enumerable: !0,\n          configurable: !0\n        }), o.prototype.forEach = function (n) {\n          this.sortedSet.inorderTraversal(function (t, e) {\n            return n(t), !1;\n          });\n        }, o.prototype.add = function (t) {\n          var e = this.delete(t.key);\n          return e.copy(e.keyedMap.insert(t.key, t), e.sortedSet.insert(t, null));\n        }, o.prototype.delete = function (t) {\n          var e = this.get(t);\n          return e ? this.copy(this.keyedMap.remove(t), this.sortedSet.remove(e)) : this;\n        }, o.prototype.isEqual = function (t) {\n          if (!(t instanceof o)) return !1;\n          if (this.size !== t.size) return !1;\n\n          for (var e = this.sortedSet.getIterator(), n = t.sortedSet.getIterator(); e.hasNext();) {\n            var r = e.getNext().key,\n                i = n.getNext().key;\n            if (!r.isEqual(i)) return !1;\n          }\n\n          return !0;\n        }, o.prototype.toString = function () {\n          var e = [];\n          return this.forEach(function (t) {\n            e.push(t.toString());\n          }), 0 === e.length ? \"DocumentSet ()\" : \"DocumentSet (\\n  \" + e.join(\"  \\n\") + \"\\n)\";\n        }, o.prototype.copy = function (t, e) {\n          var n = new o();\n          return n.comparator = this.comparator, n.keyedMap = t, n.sortedSet = e, n;\n        }, o;\n      }();\n\n      (Qi = Ui || (Ui = {}))[Qi.Added = 0] = \"Added\", Qi[Qi.Removed = 1] = \"Removed\", Qi[Qi.Modified = 2] = \"Modified\", Qi[Qi.Metadata = 3] = \"Metadata\", (ji = Ki || (Ki = {}))[ji.Local = 0] = \"Local\", ji[ji.Synced = 1] = \"Synced\";\n\n      var Gi,\n          zi,\n          Hi = function () {\n        function t() {\n          this.changeMap = new wr(mr.comparator);\n        }\n\n        return t.prototype.track = function (t) {\n          var e = t.doc.key,\n              n = this.changeMap.get(e);\n          n ? t.type !== Ui.Added && n.type === Ui.Metadata ? this.changeMap = this.changeMap.insert(e, t) : t.type === Ui.Metadata && n.type !== Ui.Removed ? this.changeMap = this.changeMap.insert(e, {\n            type: n.type,\n            doc: t.doc\n          }) : t.type === Ui.Modified && n.type === Ui.Modified ? this.changeMap = this.changeMap.insert(e, {\n            type: Ui.Modified,\n            doc: t.doc\n          }) : t.type === Ui.Modified && n.type === Ui.Added ? this.changeMap = this.changeMap.insert(e, {\n            type: Ui.Added,\n            doc: t.doc\n          }) : t.type === Ui.Removed && n.type === Ui.Added ? this.changeMap = this.changeMap.remove(e) : t.type === Ui.Removed && n.type === Ui.Modified ? this.changeMap = this.changeMap.insert(e, {\n            type: Ui.Removed,\n            doc: n.doc\n          }) : t.type === Ui.Added && n.type === Ui.Removed ? this.changeMap = this.changeMap.insert(e, {\n            type: Ui.Modified,\n            doc: t.doc\n          }) : gn(\"unsupported combination of changes: \" + JSON.stringify(t) + \" after \" + JSON.stringify(n)) : this.changeMap = this.changeMap.insert(e, t);\n        }, t.prototype.getChanges = function () {\n          var n = [];\n          return this.changeMap.inorderTraversal(function (t, e) {\n            n.push(e);\n          }), n;\n        }, t;\n      }(),\n          Yi = function () {\n        function o(t, e, n, r, i, o, s, a) {\n          this.query = t, this.docs = e, this.oldDocs = n, this.docChanges = r, this.mutatedKeys = i, this.fromCache = o, this.syncStateChanged = s, this.excludesMetadataChanges = a;\n        }\n\n        return o.fromInitialDocuments = function (t, e, n, r) {\n          var i = [];\n          return e.forEach(function (t) {\n            i.push({\n              type: Ui.Added,\n              doc: t\n            });\n          }), new o(t, e, Wi.emptySet(e), i, n, r, !0, !1);\n        }, Object.defineProperty(o.prototype, \"hasPendingWrites\", {\n          get: function get() {\n            return !this.mutatedKeys.isEmpty();\n          },\n          enumerable: !0,\n          configurable: !0\n        }), o.prototype.isEqual = function (t) {\n          if (!(this.fromCache === t.fromCache && this.syncStateChanged === t.syncStateChanged && this.mutatedKeys.isEqual(t.mutatedKeys) && this.query.isEqual(t.query) && this.docs.isEqual(t.docs) && this.oldDocs.isEqual(t.oldDocs))) return !1;\n          var e = this.docChanges,\n              n = t.docChanges;\n          if (e.length !== n.length) return !1;\n\n          for (var r = 0; r < e.length; r++) {\n            if (e[r].type !== n[r].type || !e[r].doc.isEqual(n[r].doc)) return !1;\n          }\n\n          return !0;\n        }, o;\n      }(),\n          Xi = function () {\n        function i(t, e, n, r, i) {\n          this.snapshotVersion = t, this.targetChanges = e, this.targetMismatches = n, this.documentUpdates = r, this.resolvedLimboDocuments = i;\n        }\n\n        return i.createSynthesizedRemoteEventForCurrentChange = function (t, e) {\n          var n,\n              r = ((n = {})[t] = Ji.createSynthesizedTargetChangeForCurrentChange(t, e), n);\n          return new i(oi.MIN, r, Bi(), Mi(), Fi());\n        }, i;\n      }(),\n          Ji = function () {\n        function n(t, e, n, r, i) {\n          this.resumeToken = t, this.current = e, this.addedDocuments = n, this.modifiedDocuments = r, this.removedDocuments = i;\n        }\n\n        return n.createSynthesizedTargetChangeForCurrentChange = function (t, e) {\n          return new n(wn(), e, Fi(), Fi(), Fi());\n        }, n;\n      }(),\n          $i = function $i(t, e, n, r) {\n        this.updatedTargetIds = t, this.removedTargetIds = e, this.key = n, this.newDoc = r;\n      },\n          Zi = function Zi(t, e) {\n        this.targetId = t, this.existenceFilter = e;\n      };\n\n      (zi = Gi || (Gi = {}))[zi.NoChange = 0] = \"NoChange\", zi[zi.Added = 1] = \"Added\", zi[zi.Removed = 2] = \"Removed\", zi[zi.Current = 3] = \"Current\", zi[zi.Reset = 4] = \"Reset\";\n\n      var to = function to(t, e, n, r) {\n        void 0 === n && (n = wn()), void 0 === r && (r = null), this.state = t, this.targetIds = e, this.resumeToken = n, this.cause = r;\n      },\n          eo = function () {\n        function t() {\n          this.pendingResponses = 0, this.documentChanges = io(), this._resumeToken = wn(), this._current = !1, this._hasPendingChanges = !0;\n        }\n\n        return Object.defineProperty(t.prototype, \"current\", {\n          get: function get() {\n            return this._current;\n          },\n          enumerable: !0,\n          configurable: !0\n        }), Object.defineProperty(t.prototype, \"resumeToken\", {\n          get: function get() {\n            return this._resumeToken;\n          },\n          enumerable: !0,\n          configurable: !0\n        }), Object.defineProperty(t.prototype, \"isPending\", {\n          get: function get() {\n            return 0 !== this.pendingResponses;\n          },\n          enumerable: !0,\n          configurable: !0\n        }), Object.defineProperty(t.prototype, \"hasPendingChanges\", {\n          get: function get() {\n            return this._hasPendingChanges;\n          },\n          enumerable: !0,\n          configurable: !0\n        }), t.prototype.updateResumeToken = function (t) {\n          0 < t.length && (this._hasPendingChanges = !0, this._resumeToken = t);\n        }, t.prototype.toTargetChange = function () {\n          var n = Fi(),\n              r = Fi(),\n              i = Fi();\n          return this.documentChanges.forEach(function (t, e) {\n            switch (e) {\n              case Ui.Added:\n                n = n.add(t);\n                break;\n\n              case Ui.Modified:\n                r = r.add(t);\n                break;\n\n              case Ui.Removed:\n                i = i.add(t);\n                break;\n\n              default:\n                gn(\"Encountered invalid change type: \" + e);\n            }\n          }), new Ji(this._resumeToken, this._current, n, r, i);\n        }, t.prototype.clearPendingChanges = function () {\n          this._hasPendingChanges = !1, this.documentChanges = io();\n        }, t.prototype.addDocumentChange = function (t, e) {\n          this._hasPendingChanges = !0, this.documentChanges = this.documentChanges.insert(t, e);\n        }, t.prototype.removeDocumentChange = function (t) {\n          this._hasPendingChanges = !0, this.documentChanges = this.documentChanges.remove(t);\n        }, t.prototype.recordPendingTargetRequest = function () {\n          this.pendingResponses += 1;\n        }, t.prototype.recordTargetResponse = function () {\n          this.pendingResponses -= 1;\n        }, t.prototype.markCurrent = function () {\n          this._hasPendingChanges = !0, this._current = !0;\n        }, t;\n      }(),\n          no = function () {\n        function t(t) {\n          this.metadataProvider = t, this.targetStates = {}, this.pendingDocumentUpdates = Mi(), this.pendingDocumentTargetMapping = ro(), this.pendingTargetResets = new ci(Hn);\n        }\n\n        return t.prototype.handleDocumentChange = function (t) {\n          for (var e = 0, n = t.updatedTargetIds; e < n.length; e++) {\n            var r = n[e];\n            t.newDoc instanceof gr ? this.addDocumentToTarget(r, t.newDoc) : t.newDoc instanceof vr && this.removeDocumentFromTarget(r, t.key, t.newDoc);\n          }\n\n          for (var i = 0, o = t.removedTargetIds; i < o.length; i++) {\n            r = o[i];\n            this.removeDocumentFromTarget(r, t.key, t.newDoc);\n          }\n        }, t.prototype.handleTargetChange = function (n) {\n          var r = this;\n          this.forEachTarget(n, function (t) {\n            var e = r.ensureTargetState(t);\n\n            switch (n.state) {\n              case Gi.NoChange:\n                r.isActiveTarget(t) && e.updateResumeToken(n.resumeToken);\n                break;\n\n              case Gi.Added:\n                e.recordTargetResponse(), e.isPending || e.clearPendingChanges(), e.updateResumeToken(n.resumeToken);\n                break;\n\n              case Gi.Removed:\n                e.recordTargetResponse(), e.isPending || r.removeTarget(t), vn(!n.cause, \"WatchChangeAggregator does not handle errored targets\");\n                break;\n\n              case Gi.Current:\n                r.isActiveTarget(t) && (e.markCurrent(), e.updateResumeToken(n.resumeToken));\n                break;\n\n              case Gi.Reset:\n                r.isActiveTarget(t) && (r.resetTarget(t), e.updateResumeToken(n.resumeToken));\n                break;\n\n              default:\n                gn(\"Unknown target watch change state: \" + n.state);\n            }\n          });\n        }, t.prototype.forEachTarget = function (t, e) {\n          0 < t.targetIds.length ? t.targetIds.forEach(e) : Dn(this.targetStates, e);\n        }, t.prototype.handleExistenceFilter = function (t) {\n          var e = t.targetId,\n              n = t.existenceFilter.count,\n              r = this.queryDataForActiveTarget(e);\n\n          if (r) {\n            var i = r.query;\n            if (i.isDocumentQuery()) {\n              if (0 === n) {\n                var o = new mr(i.path);\n                this.removeDocumentFromTarget(e, o, new vr(o, oi.forDeletedDoc()));\n              } else vn(1 === n, \"Single document existence filter with count: \" + n);\n            } else this.getCurrentDocumentCountForTarget(e) !== n && (this.resetTarget(e), this.pendingTargetResets = this.pendingTargetResets.add(e));\n          }\n        }, t.prototype.createRemoteEvent = function (i) {\n          var o = this,\n              s = {};\n          Dn(this.targetStates, function (t, e) {\n            var n = o.queryDataForActiveTarget(t);\n\n            if (n) {\n              if (e.current && n.query.isDocumentQuery()) {\n                var r = new mr(n.query.path);\n                null !== o.pendingDocumentUpdates.get(r) || o.targetContainsDocument(t, r) || o.removeDocumentFromTarget(t, r, new vr(r, i));\n              }\n\n              e.hasPendingChanges && (s[t] = e.toTargetChange(), e.clearPendingChanges());\n            }\n          });\n          var r = Fi();\n          this.pendingDocumentTargetMapping.forEach(function (t, e) {\n            var n = !0;\n            e.forEachWhile(function (t) {\n              var e = o.queryDataForActiveTarget(t);\n              return !e || e.purpose === Gr.LimboResolution || (n = !1);\n            }), n && (r = r.add(t));\n          });\n          var t = new Xi(i, s, this.pendingTargetResets, this.pendingDocumentUpdates, r);\n          return this.pendingDocumentUpdates = Mi(), this.pendingDocumentTargetMapping = ro(), this.pendingTargetResets = new ci(Hn), t;\n        }, t.prototype.addDocumentToTarget = function (t, e) {\n          if (this.isActiveTarget(t)) {\n            var n = this.targetContainsDocument(t, e.key) ? Ui.Modified : Ui.Added;\n            this.ensureTargetState(t).addDocumentChange(e.key, n), this.pendingDocumentUpdates = this.pendingDocumentUpdates.insert(e.key, e), this.pendingDocumentTargetMapping = this.pendingDocumentTargetMapping.insert(e.key, this.ensureDocumentTargetMapping(e.key).add(t));\n          }\n        }, t.prototype.removeDocumentFromTarget = function (t, e, n) {\n          if (this.isActiveTarget(t)) {\n            var r = this.ensureTargetState(t);\n            this.targetContainsDocument(t, e) ? r.addDocumentChange(e, Ui.Removed) : r.removeDocumentChange(e), this.pendingDocumentTargetMapping = this.pendingDocumentTargetMapping.insert(e, this.ensureDocumentTargetMapping(e).delete(t)), n && (this.pendingDocumentUpdates = this.pendingDocumentUpdates.insert(e, n));\n          }\n        }, t.prototype.removeTarget = function (t) {\n          delete this.targetStates[t];\n        }, t.prototype.getCurrentDocumentCountForTarget = function (t) {\n          var e = this.ensureTargetState(t).toTargetChange();\n          return this.metadataProvider.getRemoteKeysForTarget(t).size + e.addedDocuments.size - e.removedDocuments.size;\n        }, t.prototype.recordPendingTargetRequest = function (t) {\n          this.ensureTargetState(t).recordPendingTargetRequest();\n        }, t.prototype.ensureTargetState = function (t) {\n          return this.targetStates[t] || (this.targetStates[t] = new eo()), this.targetStates[t];\n        }, t.prototype.ensureDocumentTargetMapping = function (t) {\n          var e = this.pendingDocumentTargetMapping.get(t);\n          return e || (e = new ci(Hn), this.pendingDocumentTargetMapping = this.pendingDocumentTargetMapping.insert(t, e)), e;\n        }, t.prototype.isActiveTarget = function (t) {\n          return null !== this.queryDataForActiveTarget(t);\n        }, t.prototype.queryDataForActiveTarget = function (t) {\n          var e = this.targetStates[t];\n          return e && e.isPending ? null : this.metadataProvider.getQueryDataForTarget(t);\n        }, t.prototype.resetTarget = function (e) {\n          var n = this;\n          vn(!this.targetStates[e].isPending, \"Should only reset active targets\"), this.targetStates[e] = new eo(), this.metadataProvider.getRemoteKeysForTarget(e).forEach(function (t) {\n            n.removeDocumentFromTarget(e, t, null);\n          });\n        }, t.prototype.targetContainsDocument = function (t, e) {\n          return this.metadataProvider.getRemoteKeysForTarget(t).has(e);\n        }, t;\n      }();\n\n      function ro() {\n        return new wr(mr.comparator);\n      }\n\n      function io() {\n        return new wr(mr.comparator);\n      }\n\n      var oo,\n          so,\n          ao = ((oo = {})[ti.ASCENDING.name] = \"ASCENDING\", oo[ti.DESCENDING.name] = \"DESCENDING\", oo),\n          uo = ((so = {})[Xr.LESS_THAN.name] = \"LESS_THAN\", so[Xr.LESS_THAN_OR_EQUAL.name] = \"LESS_THAN_OR_EQUAL\", so[Xr.GREATER_THAN.name] = \"GREATER_THAN\", so[Xr.GREATER_THAN_OR_EQUAL.name] = \"GREATER_THAN_OR_EQUAL\", so[Xr.EQUAL.name] = \"EQUAL\", so[Xr.ARRAY_CONTAINS.name] = \"ARRAY_CONTAINS\", so),\n          co = new RegExp(/^\\d{4}-\\d\\d-\\d\\dT\\d\\d:\\d\\d:\\d\\d(?:\\.(\\d+))?Z$/);\n\n      function ho(t, e) {\n        vn(!jr(t), e + \" is missing\");\n      }\n\n      function lo(t) {\n        return \"number\" == typeof t ? t : \"string\" == typeof t ? Number(t) : gn(\"can't parse \" + t);\n      }\n\n      var fo = function () {\n        function t(t, e) {\n          this.databaseId = t, this.options = e;\n        }\n\n        return t.prototype.emptyByteString = function () {\n          return this.options.useProto3Json ? \"\" : new Uint8Array(0);\n        }, t.prototype.unsafeCastProtoByteString = function (t) {\n          return t;\n        }, t.prototype.fromRpcStatus = function (t) {\n          var e = void 0 === t.code ? En.UNKNOWN : ki(t.code);\n          return new Sn(e, t.message || \"\");\n        }, t.prototype.toInt32Value = function (t) {\n          return jr(t) ? void 0 : {\n            value: t\n          };\n        }, t.prototype.fromInt32Value = function (t) {\n          var e;\n          return jr(e = \"object\" == typeof t ? t.value : t) ? null : e;\n        }, t.prototype.toTimestamp = function (t) {\n          return {\n            seconds: t.seconds,\n            nanos: t.nanoseconds\n          };\n        }, t.prototype.fromTimestamp = function (t) {\n          if (\"string\" == typeof t) return this.fromIso8601String(t);\n          vn(!!t, \"Cannot deserialize null or undefined timestamp.\");\n          var e = lo(t.seconds || \"0\"),\n              n = t.nanos || 0;\n          return new sr(e, n);\n        }, t.prototype.fromIso8601String = function (t) {\n          var e = 0,\n              n = co.exec(t);\n\n          if (vn(!!n, \"invalid timestamp: \" + t), n[1]) {\n            var r = n[1];\n            r = (r + \"000000000\").substr(0, 9), e = Number(r);\n          }\n\n          var i = new Date(t),\n              o = Math.floor(i.getTime() / 1e3);\n          return new sr(o, e);\n        }, t.prototype.toBytes = function (t) {\n          return this.options.useProto3Json ? t.toBase64() : this.unsafeCastProtoByteString(t.toUint8Array());\n        }, t.prototype.fromBlob = function (t) {\n          return \"string\" == typeof t ? (vn(this.options.useProto3Json, \"Expected bytes to be passed in as Uint8Array, but got a string instead.\"), rr.fromBase64String(t)) : (vn(!this.options.useProto3Json, \"Expected bytes to be passed in as string, but got something else instead.\"), rr.fromUint8Array(t));\n        }, t.prototype.toVersion = function (t) {\n          return this.toTimestamp(t.toTimestamp());\n        }, t.prototype.fromVersion = function (t) {\n          return vn(!!t, \"Trying to deserialize version that isn't set\"), oi.fromTimestamp(this.fromTimestamp(t));\n        }, t.prototype.toResourceName = function (t, e) {\n          return this.fullyQualifiedPrefixPath(t).child(\"documents\").child(e).canonicalString();\n        }, t.prototype.fromResourceName = function (t) {\n          var e = fr.fromString(t);\n          return vn(this.isValidResourceName(e), \"Tried to deserialize invalid key \" + e.toString()), e;\n        }, t.prototype.toName = function (t) {\n          return this.toResourceName(this.databaseId, t.path);\n        }, t.prototype.fromName = function (t) {\n          var e = this.fromResourceName(t);\n          return vn(e.get(1) === this.databaseId.projectId, \"Tried to deserialize key from different project: \" + e.get(1) + \" vs \" + this.databaseId.projectId), vn(!e.get(3) && !this.databaseId.database || e.get(3) === this.databaseId.database, \"Tried to deserialize key from different database: \" + e.get(3) + \" vs \" + this.databaseId.database), new mr(this.extractLocalPathFromResourceName(e));\n        }, t.prototype.toQueryPath = function (t) {\n          return this.toResourceName(this.databaseId, t);\n        }, t.prototype.fromQueryPath = function (t) {\n          var e = this.fromResourceName(t);\n          return 4 === e.length ? fr.EMPTY_PATH : this.extractLocalPathFromResourceName(e);\n        }, Object.defineProperty(t.prototype, \"encodedDatabaseId\", {\n          get: function get() {\n            return new fr([\"projects\", this.databaseId.projectId, \"databases\", this.databaseId.database]).canonicalString();\n          },\n          enumerable: !0,\n          configurable: !0\n        }), t.prototype.fullyQualifiedPrefixPath = function (t) {\n          return new fr([\"projects\", t.projectId, \"databases\", t.database]);\n        }, t.prototype.extractLocalPathFromResourceName = function (t) {\n          return vn(4 < t.length && \"documents\" === t.get(4), \"tried to deserialize invalid key \" + t.toString()), t.popFirst(5);\n        }, t.prototype.isValidResourceName = function (t) {\n          return 4 <= t.length && \"projects\" === t.get(0) && \"databases\" === t.get(2);\n        }, t.prototype.toValue = function (t) {\n          if (t instanceof Dr) return {\n            nullValue: \"NULL_VALUE\"\n          };\n          if (t instanceof Nr) return {\n            booleanValue: t.value()\n          };\n          if (t instanceof Rr) return {\n            integerValue: \"\" + t.value()\n          };\n\n          if (t instanceof Mr) {\n            var e = t.value();\n\n            if (this.options.useProto3Json) {\n              if (isNaN(e)) return {\n                doubleValue: \"NaN\"\n              };\n              if (e === 1 / 0) return {\n                doubleValue: \"Infinity\"\n              };\n              if (e === -1 / 0) return {\n                doubleValue: \"-Infinity\"\n              };\n            }\n\n            return {\n              doubleValue: t.value()\n            };\n          }\n\n          return t instanceof _r ? {\n            stringValue: t.value()\n          } : t instanceof Fr ? {\n            mapValue: this.toMapValue(t)\n          } : t instanceof Vr ? {\n            arrayValue: this.toArrayValue(t)\n          } : t instanceof Or ? {\n            timestampValue: this.toTimestamp(t.internalValue)\n          } : t instanceof qr ? {\n            geoPointValue: {\n              latitude: t.value().latitude,\n              longitude: t.value().longitude\n            }\n          } : t instanceof Lr ? {\n            bytesValue: this.toBytes(t.value())\n          } : t instanceof xr ? {\n            referenceValue: this.toResourceName(t.databaseId, t.key.path)\n          } : gn(\"Unknown FieldValue \" + JSON.stringify(t));\n        }, t.prototype.fromValue = function (t) {\n          var e = this,\n              n = t.value_type;\n          if (po(t, n, \"nullValue\")) return Dr.INSTANCE;\n          if (po(t, n, \"booleanValue\")) return Nr.of(t.booleanValue);\n          if (po(t, n, \"integerValue\")) return new Rr(lo(t.integerValue));\n\n          if (po(t, n, \"doubleValue\")) {\n            if (this.options.useProto3Json) {\n              if (\"NaN\" === t.doubleValue) return Mr.NAN;\n              if (\"Infinity\" === t.doubleValue) return Mr.POSITIVE_INFINITY;\n              if (\"-Infinity\" === t.doubleValue) return Mr.NEGATIVE_INFINITY;\n            }\n\n            return new Mr(t.doubleValue);\n          }\n\n          if (po(t, n, \"stringValue\")) return new _r(t.stringValue);\n          if (po(t, n, \"mapValue\")) return this.fromFields(t.mapValue.fields || {});\n\n          if (po(t, n, \"arrayValue\")) {\n            ho(t.arrayValue, \"arrayValue\");\n            var r = t.arrayValue.values || [];\n            return new Vr(r.map(function (t) {\n              return e.fromValue(t);\n            }));\n          }\n\n          if (po(t, n, \"timestampValue\")) return ho(t.timestampValue, \"timestampValue\"), new Or(this.fromTimestamp(t.timestampValue));\n\n          if (po(t, n, \"geoPointValue\")) {\n            ho(t.geoPointValue, \"geoPointValue\");\n            var i = t.geoPointValue.latitude || 0,\n                o = t.geoPointValue.longitude || 0;\n            return new qr(new or(i, o));\n          }\n\n          if (po(t, n, \"bytesValue\")) {\n            ho(t.bytesValue, \"bytesValue\");\n            var s = this.fromBlob(t.bytesValue);\n            return new Lr(s);\n          }\n\n          if (po(t, n, \"referenceValue\")) {\n            ho(t.referenceValue, \"referenceValue\");\n            var a = this.fromResourceName(t.referenceValue),\n                u = new cr(a.get(1), a.get(3)),\n                c = new mr(this.extractLocalPathFromResourceName(a));\n            return new xr(u, c);\n          }\n\n          return gn(\"Unknown Value proto \" + JSON.stringify(t));\n        }, t.prototype.toMutationDocument = function (t, e) {\n          return {\n            name: this.toName(t),\n            fields: this.toFields(e)\n          };\n        }, t.prototype.toDocument = function (t) {\n          return vn(!t.hasLocalMutations, \"Can't serialize documents with mutations.\"), {\n            name: this.toName(t.key),\n            fields: this.toFields(t.data),\n            updateTime: this.toTimestamp(t.version.toTimestamp())\n          };\n        }, t.prototype.fromDocument = function (t, e) {\n          return new gr(this.fromName(t.name), this.fromVersion(t.updateTime), this.fromFields(t.fields || {}), {\n            hasCommittedMutations: !!e\n          });\n        }, t.prototype.toFields = function (t) {\n          var n = this,\n              r = {};\n          return t.forEach(function (t, e) {\n            r[t] = n.toValue(e);\n          }), r;\n        }, t.prototype.fromFields = function (t) {\n          var n = this,\n              e = t,\n              r = Fr.EMPTY;\n          return Nn(e, function (t, e) {\n            r = r.set(new dr([t]), n.fromValue(e));\n          }), r;\n        }, t.prototype.toMapValue = function (t) {\n          return {\n            fields: this.toFields(t)\n          };\n        }, t.prototype.toArrayValue = function (t) {\n          var e = this,\n              n = [];\n          return t.forEach(function (t) {\n            n.push(e.toValue(t));\n          }), {\n            values: n\n          };\n        }, t.prototype.fromFound = function (t) {\n          vn(!!t.found, \"Tried to deserialize a found document from a missing document.\"), ho(t.found.name, \"doc.found.name\"), ho(t.found.updateTime, \"doc.found.updateTime\");\n          var e = this.fromName(t.found.name),\n              n = this.fromVersion(t.found.updateTime),\n              r = this.fromFields(t.found.fields || {});\n          return new gr(e, n, r, {}, t.found);\n        }, t.prototype.fromMissing = function (t) {\n          vn(!!t.missing, \"Tried to deserialize a missing document from a found document.\"), vn(!!t.readTime, \"Tried to deserialize a missing document without a read time.\");\n          var e = this.fromName(t.missing),\n              n = this.fromVersion(t.readTime);\n          return new vr(e, n);\n        }, t.prototype.fromMaybeDocument = function (t) {\n          var e = t.result;\n          return po(t, e, \"found\") ? this.fromFound(t) : po(t, e, \"missing\") ? this.fromMissing(t) : gn(\"invalid batch get response: \" + JSON.stringify(t));\n        }, t.prototype.toWatchTargetChangeState = function (t) {\n          switch (t) {\n            case Gi.Added:\n              return \"ADD\";\n\n            case Gi.Current:\n              return \"CURRENT\";\n\n            case Gi.NoChange:\n              return \"NO_CHANGE\";\n\n            case Gi.Removed:\n              return \"REMOVE\";\n\n            case Gi.Reset:\n              return \"RESET\";\n\n            default:\n              return gn(\"Unknown WatchTargetChangeState: \" + t);\n          }\n        }, t.prototype.toTestWatchChange = function (t) {\n          if (t instanceof Zi) return {\n            filter: {\n              count: t.existenceFilter.count,\n              targetId: t.targetId\n            }\n          };\n\n          if (t instanceof $i) {\n            if (t.newDoc instanceof gr) {\n              var e = t.newDoc;\n              return {\n                documentChange: {\n                  document: {\n                    name: this.toName(e.key),\n                    fields: this.toFields(e.data),\n                    updateTime: this.toVersion(e.version)\n                  },\n                  targetIds: t.updatedTargetIds,\n                  removedTargetIds: t.removedTargetIds\n                }\n              };\n            }\n\n            if (t.newDoc instanceof vr) {\n              e = t.newDoc;\n              return {\n                documentDelete: {\n                  document: this.toName(e.key),\n                  readTime: this.toVersion(e.version),\n                  removedTargetIds: t.removedTargetIds\n                }\n              };\n            }\n\n            if (null === t.newDoc) return {\n              documentRemove: {\n                document: this.toName(t.key),\n                removedTargetIds: t.removedTargetIds\n              }\n            };\n          }\n\n          if (t instanceof to) {\n            var n = void 0;\n            return t.cause && (n = {\n              code: function (t) {\n                if (void 0 === t) return Ci.OK;\n\n                switch (t) {\n                  case En.OK:\n                    return Ci.OK;\n\n                  case En.CANCELLED:\n                    return Ci.CANCELLED;\n\n                  case En.UNKNOWN:\n                    return Ci.UNKNOWN;\n\n                  case En.DEADLINE_EXCEEDED:\n                    return Ci.DEADLINE_EXCEEDED;\n\n                  case En.RESOURCE_EXHAUSTED:\n                    return Ci.RESOURCE_EXHAUSTED;\n\n                  case En.INTERNAL:\n                    return Ci.INTERNAL;\n\n                  case En.UNAVAILABLE:\n                    return Ci.UNAVAILABLE;\n\n                  case En.UNAUTHENTICATED:\n                    return Ci.UNAUTHENTICATED;\n\n                  case En.INVALID_ARGUMENT:\n                    return Ci.INVALID_ARGUMENT;\n\n                  case En.NOT_FOUND:\n                    return Ci.NOT_FOUND;\n\n                  case En.ALREADY_EXISTS:\n                    return Ci.ALREADY_EXISTS;\n\n                  case En.PERMISSION_DENIED:\n                    return Ci.PERMISSION_DENIED;\n\n                  case En.FAILED_PRECONDITION:\n                    return Ci.FAILED_PRECONDITION;\n\n                  case En.ABORTED:\n                    return Ci.ABORTED;\n\n                  case En.OUT_OF_RANGE:\n                    return Ci.OUT_OF_RANGE;\n\n                  case En.UNIMPLEMENTED:\n                    return Ci.UNIMPLEMENTED;\n\n                  case En.DATA_LOSS:\n                    return Ci.DATA_LOSS;\n\n                  default:\n                    return gn(\"Unknown status code: \" + t);\n                }\n              }(t.cause.code),\n              message: t.cause.message\n            }), {\n              targetChange: {\n                targetChangeType: this.toWatchTargetChangeState(t.state),\n                targetIds: t.targetIds,\n                resumeToken: this.unsafeCastProtoByteString(t.resumeToken),\n                cause: n\n              }\n            };\n          }\n\n          return gn(\"Unrecognized watch change: \" + JSON.stringify(t));\n        }, t.prototype.fromWatchChange = function (t) {\n          var e,\n              n = t.response_type;\n\n          if (po(t, n, \"targetChange\")) {\n            ho(t.targetChange, \"targetChange\");\n            var r = this.fromWatchTargetChangeState(t.targetChange.targetChangeType || \"NO_CHANGE\"),\n                i = t.targetChange.targetIds || [],\n                o = t.targetChange.resumeToken || this.emptyByteString(),\n                s = t.targetChange.cause,\n                a = s && this.fromRpcStatus(s);\n            e = new to(r, i, o, a || null);\n          } else if (po(t, n, \"documentChange\")) {\n            ho(t.documentChange, \"documentChange\"), ho(t.documentChange.document, \"documentChange.name\"), ho(t.documentChange.document.name, \"documentChange.document.name\"), ho(t.documentChange.document.updateTime, \"documentChange.document.updateTime\");\n            var u = t.documentChange,\n                c = this.fromName(u.document.name),\n                h = this.fromVersion(u.document.updateTime),\n                l = this.fromFields(u.document.fields || {}),\n                f = new gr(c, h, l, {}, u.document),\n                p = u.targetIds || [],\n                d = u.removedTargetIds || [];\n            e = new $i(p, d, f.key, f);\n          } else if (po(t, n, \"documentDelete\")) {\n            ho(t.documentDelete, \"documentDelete\"), ho(t.documentDelete.document, \"documentDelete.document\");\n            var m = t.documentDelete;\n            c = this.fromName(m.document), h = m.readTime ? this.fromVersion(m.readTime) : oi.forDeletedDoc(), f = new vr(c, h), d = m.removedTargetIds || [];\n            e = new $i([], d, f.key, f);\n          } else if (po(t, n, \"documentRemove\")) {\n            ho(t.documentRemove, \"documentRemove\"), ho(t.documentRemove.document, \"documentRemove\");\n            var y = t.documentRemove;\n            c = this.fromName(y.document), d = y.removedTargetIds || [];\n            e = new $i([], d, c, null);\n          } else {\n            if (!po(t, n, \"filter\")) return gn(\"Unknown change type \" + JSON.stringify(t));\n            ho(t.filter, \"filter\"), ho(t.filter.targetId, \"filter.targetId\");\n            var g = t.filter,\n                v = g.count || 0,\n                b = new Ni(v),\n                w = g.targetId;\n            e = new Zi(w, b);\n          }\n\n          return e;\n        }, t.prototype.fromWatchTargetChangeState = function (t) {\n          return \"NO_CHANGE\" === t ? Gi.NoChange : \"ADD\" === t ? Gi.Added : \"REMOVE\" === t ? Gi.Removed : \"CURRENT\" === t ? Gi.Current : \"RESET\" === t ? Gi.Reset : gn(\"Got unexpected TargetChange.state: \" + t);\n        }, t.prototype.versionFromListenResponse = function (t) {\n          if (!po(t, t.response_type, \"targetChange\")) return oi.MIN;\n          var e = t.targetChange;\n          return e.targetIds && e.targetIds.length ? oi.MIN : e.readTime ? this.fromVersion(e.readTime) : oi.MIN;\n        }, t.prototype.toMutation = function (t) {\n          var e,\n              n = this;\n          if (t instanceof yi) e = {\n            update: this.toMutationDocument(t.key, t.value)\n          };else if (t instanceof bi) e = {\n            delete: this.toName(t.key)\n          };else if (t instanceof gi) e = {\n            update: this.toMutationDocument(t.key, t.data),\n            updateMask: this.toDocumentMask(t.fieldMask)\n          };else {\n            if (!(t instanceof vi)) return gn(\"Unknown mutation type \" + t.type);\n            e = {\n              transform: {\n                document: this.toName(t.key),\n                fieldTransforms: t.fieldTransforms.map(function (t) {\n                  return n.toFieldTransform(t);\n                })\n              }\n            };\n          }\n          return t.precondition.isNone || (e.currentDocument = this.toPrecondition(t.precondition)), e;\n        }, t.prototype.fromMutation = function (t) {\n          var e = this,\n              n = t.currentDocument ? this.fromPrecondition(t.currentDocument) : di.NONE;\n\n          if (t.update) {\n            ho(t.update.name, \"name\");\n            var r = this.fromName(t.update.name),\n                i = this.fromFields(t.update.fields || {});\n\n            if (t.updateMask) {\n              var o = this.fromDocumentMask(t.updateMask);\n              return new gi(r, i, o, n);\n            }\n\n            return new yi(r, i, n);\n          }\n\n          if (t.delete) {\n            r = this.fromName(t.delete);\n            return new bi(r, n);\n          }\n\n          if (t.transform) {\n            r = this.fromName(t.transform.document);\n            var s = t.transform.fieldTransforms.map(function (t) {\n              return e.fromFieldTransform(t);\n            });\n            return vn(!0 === n.exists, 'Transforms only support precondition \"exists == true\"'), new vi(r, s);\n          }\n\n          return gn(\"unknown mutation proto: \" + JSON.stringify(t));\n        }, t.prototype.toPrecondition = function (t) {\n          return vn(!t.isNone, \"Can't serialize an empty precondition\"), void 0 !== t.updateTime ? {\n            updateTime: this.toVersion(t.updateTime)\n          } : void 0 !== t.exists ? {\n            exists: t.exists\n          } : gn(\"Unknown precondition\");\n        }, t.prototype.fromPrecondition = function (t) {\n          return void 0 !== t.updateTime ? di.updateTime(this.fromVersion(t.updateTime)) : void 0 !== t.exists ? di.exists(t.exists) : di.NONE;\n        }, t.prototype.fromWriteResult = function (t, e) {\n          var n = this,\n              r = t.updateTime ? this.fromVersion(t.updateTime) : this.fromVersion(e),\n              i = null;\n          return t.transformResults && 0 < t.transformResults.length && (i = t.transformResults.map(function (t) {\n            return n.fromValue(t);\n          })), new pi(r, i);\n        }, t.prototype.fromWriteResults = function (t, e) {\n          var n = this;\n          return t && 0 < t.length ? (vn(void 0 !== e, \"Received a write result without a commit time\"), t.map(function (t) {\n            return n.fromWriteResult(t, e);\n          })) : [];\n        }, t.prototype.toFieldTransform = function (t) {\n          var e = this,\n              n = t.transform;\n          if (n instanceof wi) return {\n            fieldPath: t.field.canonicalString(),\n            setToServerValue: \"REQUEST_TIME\"\n          };\n          if (n instanceof Ei) return {\n            fieldPath: t.field.canonicalString(),\n            appendMissingElements: {\n              values: n.elements.map(function (t) {\n                return e.toValue(t);\n              })\n            }\n          };\n          if (n instanceof Si) return {\n            fieldPath: t.field.canonicalString(),\n            removeAllFromArray: {\n              values: n.elements.map(function (t) {\n                return e.toValue(t);\n              })\n            }\n          };\n          if (n instanceof Ti) return {\n            fieldPath: t.field.canonicalString(),\n            increment: this.toValue(n.operand)\n          };\n          throw gn(\"Unknown transform: \" + t.transform);\n        }, t.prototype.fromFieldTransform = function (t) {\n          var e = this,\n              n = t.transform_type,\n              r = null;\n          if (po(t, n, \"setToServerValue\")) vn(\"REQUEST_TIME\" === t.setToServerValue, \"Unknown server value transform proto: \" + JSON.stringify(t)), r = wi.instance;else if (po(t, n, \"appendMissingElements\")) {\n            var i = t.appendMissingElements.values || [];\n            r = new Ei(i.map(function (t) {\n              return e.fromValue(t);\n            }));\n          } else if (po(t, n, \"removeAllFromArray\")) {\n            i = t.removeAllFromArray.values || [];\n            r = new Si(i.map(function (t) {\n              return e.fromValue(t);\n            }));\n          } else if (po(t, n, \"increment\")) {\n            var o = this.fromValue(t.increment);\n            vn(o instanceof Ar, \"NUMERIC_ADD transform requires a NumberValue\"), r = new Ti(o);\n          } else gn(\"Unknown transform proto: \" + JSON.stringify(t));\n          var s = dr.fromServerFormat(t.fieldPath);\n          return new fi(s, r);\n        }, t.prototype.toDocumentsTarget = function (t) {\n          return {\n            documents: [this.toQueryPath(t.path)]\n          };\n        }, t.prototype.fromDocumentsTarget = function (t) {\n          var e = t.documents.length;\n          vn(1 === e, \"DocumentsTarget contained other than 1 document: \" + e);\n          var n = t.documents[0];\n          return Hr.atPath(this.fromQueryPath(n));\n        }, t.prototype.toQueryTarget = function (t) {\n          var e = {\n            structuredQuery: {}\n          },\n              n = t.path;\n          null !== t.collectionGroup ? (vn(n.length % 2 == 0, \"Collection Group queries should be within a document path or root.\"), e.parent = this.toQueryPath(n), e.structuredQuery.from = [{\n            collectionId: t.collectionGroup,\n            allDescendants: !0\n          }]) : (vn(n.length % 2 != 0, \"Document queries with filters are not supported.\"), e.parent = this.toQueryPath(n.popLast()), e.structuredQuery.from = [{\n            collectionId: n.lastSegment()\n          }]);\n          var r = this.toFilter(t.filters);\n          r && (e.structuredQuery.where = r);\n          var i = this.toOrder(t.orderBy);\n          i && (e.structuredQuery.orderBy = i);\n          var o = this.toInt32Value(t.limit);\n          return void 0 !== o && (e.structuredQuery.limit = o), t.startAt && (e.structuredQuery.startAt = this.toCursor(t.startAt)), t.endAt && (e.structuredQuery.endAt = this.toCursor(t.endAt)), e;\n        }, t.prototype.fromQueryTarget = function (t) {\n          var e = this.fromQueryPath(t.parent),\n              n = t.structuredQuery,\n              r = n.from ? n.from.length : 0,\n              i = null;\n\n          if (0 < r) {\n            vn(1 === r, \"StructuredQuery.from with more than one collection is not supported.\");\n            var o = n.from[0];\n            o.allDescendants ? i = o.collectionId : e = e.child(o.collectionId);\n          }\n\n          var s = [];\n          n.where && (s = this.fromFilter(n.where));\n          var a = [];\n          n.orderBy && (a = this.fromOrder(n.orderBy));\n          var u = null;\n          n.limit && (u = this.fromInt32Value(n.limit));\n          var c = null;\n          n.startAt && (c = this.fromCursor(n.startAt));\n          var h = null;\n          return n.endAt && (h = this.fromCursor(n.endAt)), new Hr(e, i, a, s, u, c, h);\n        }, t.prototype.toListenRequestLabels = function (t) {\n          var e = this.toLabel(t.purpose);\n          return null == e ? null : {\n            \"goog-listen-tags\": e\n          };\n        }, t.prototype.toLabel = function (t) {\n          switch (t) {\n            case Gr.Listen:\n              return null;\n\n            case Gr.ExistenceFilterMismatch:\n              return \"existence-filter-mismatch\";\n\n            case Gr.LimboResolution:\n              return \"limbo-document\";\n\n            default:\n              return gn(\"Unrecognized query purpose: \" + t);\n          }\n        }, t.prototype.toTarget = function (t) {\n          var e,\n              n = t.query;\n          return (e = n.isDocumentQuery() ? {\n            documents: this.toDocumentsTarget(n)\n          } : {\n            query: this.toQueryTarget(n)\n          }).targetId = t.targetId, 0 < t.resumeToken.length && (e.resumeToken = this.unsafeCastProtoByteString(t.resumeToken)), e;\n        }, t.prototype.toFilter = function (t) {\n          var e = this;\n\n          if (0 !== t.length) {\n            var n = t.map(function (t) {\n              return t instanceof Jr ? e.toRelationFilter(t) : e.toUnaryFilter(t);\n            });\n            return 1 === n.length ? n[0] : {\n              compositeFilter: {\n                op: \"AND\",\n                filters: n\n              }\n            };\n          }\n        }, t.prototype.fromFilter = function (t) {\n          var e = this;\n          return t ? void 0 !== t.unaryFilter ? [this.fromUnaryFilter(t)] : void 0 !== t.fieldFilter ? [this.fromRelationFilter(t)] : void 0 !== t.compositeFilter ? t.compositeFilter.filters.map(function (t) {\n            return e.fromFilter(t);\n          }).reduce(function (t, e) {\n            return t.concat(e);\n          }) : gn(\"Unknown filter: \" + JSON.stringify(t)) : [];\n        }, t.prototype.toOrder = function (t) {\n          var e = this;\n          if (0 !== t.length) return t.map(function (t) {\n            return e.toPropertyOrder(t);\n          });\n        }, t.prototype.fromOrder = function (t) {\n          var e = this;\n          return t.map(function (t) {\n            return e.fromPropertyOrder(t);\n          });\n        }, t.prototype.toCursor = function (t) {\n          var e = this;\n          return {\n            before: t.before,\n            values: t.position.map(function (t) {\n              return e.toValue(t);\n            })\n          };\n        }, t.prototype.fromCursor = function (t) {\n          var e = this,\n              n = !!t.before,\n              r = t.values.map(function (t) {\n            return e.fromValue(t);\n          });\n          return new ei(r, n);\n        }, t.prototype.toDirection = function (t) {\n          return ao[t.name];\n        }, t.prototype.fromDirection = function (t) {\n          switch (t) {\n            case \"ASCENDING\":\n              return ti.ASCENDING;\n\n            case \"DESCENDING\":\n              return ti.DESCENDING;\n\n            default:\n              return;\n          }\n        }, t.prototype.toOperatorName = function (t) {\n          return uo[t.name];\n        }, t.prototype.fromOperatorName = function (t) {\n          switch (t) {\n            case \"EQUAL\":\n              return Xr.EQUAL;\n\n            case \"GREATER_THAN\":\n              return Xr.GREATER_THAN;\n\n            case \"GREATER_THAN_OR_EQUAL\":\n              return Xr.GREATER_THAN_OR_EQUAL;\n\n            case \"LESS_THAN\":\n              return Xr.LESS_THAN;\n\n            case \"LESS_THAN_OR_EQUAL\":\n              return Xr.LESS_THAN_OR_EQUAL;\n\n            case \"ARRAY_CONTAINS\":\n              return Xr.ARRAY_CONTAINS;\n\n            case \"OPERATOR_UNSPECIFIED\":\n              return gn(\"Unspecified relation\");\n\n            default:\n              return gn(\"Unknown relation\");\n          }\n        }, t.prototype.toFieldPathReference = function (t) {\n          return {\n            fieldPath: t.canonicalString()\n          };\n        }, t.prototype.fromFieldPathReference = function (t) {\n          return dr.fromServerFormat(t.fieldPath);\n        }, t.prototype.toPropertyOrder = function (t) {\n          return {\n            field: this.toFieldPathReference(t.field),\n            direction: this.toDirection(t.dir)\n          };\n        }, t.prototype.fromPropertyOrder = function (t) {\n          return new ni(this.fromFieldPathReference(t.field), this.fromDirection(t.direction));\n        }, t.prototype.toRelationFilter = function (t) {\n          return t instanceof Jr ? {\n            fieldFilter: {\n              field: this.toFieldPathReference(t.field),\n              op: this.toOperatorName(t.op),\n              value: this.toValue(t.value)\n            }\n          } : gn(\"Unrecognized filter: \" + JSON.stringify(t));\n        }, t.prototype.fromRelationFilter = function (t) {\n          return new Jr(this.fromFieldPathReference(t.fieldFilter.field), this.fromOperatorName(t.fieldFilter.op), this.fromValue(t.fieldFilter.value));\n        }, t.prototype.toUnaryFilter = function (t) {\n          return t instanceof Zr ? {\n            unaryFilter: {\n              field: this.toFieldPathReference(t.field),\n              op: \"IS_NAN\"\n            }\n          } : t instanceof $r ? {\n            unaryFilter: {\n              field: this.toFieldPathReference(t.field),\n              op: \"IS_NULL\"\n            }\n          } : gn(\"Unrecognized filter: \" + JSON.stringify(t));\n        }, t.prototype.fromUnaryFilter = function (t) {\n          switch (t.unaryFilter.op) {\n            case \"IS_NAN\":\n              var e = this.fromFieldPathReference(t.unaryFilter.field);\n              return new Zr(e);\n\n            case \"IS_NULL\":\n              var n = this.fromFieldPathReference(t.unaryFilter.field);\n              return new $r(n);\n\n            case \"OPERATOR_UNSPECIFIED\":\n              return gn(\"Unspecified filter\");\n\n            default:\n              return gn(\"Unknown filter\");\n          }\n        }, t.prototype.toDocumentMask = function (t) {\n          var e = [];\n          return t.fields.forEach(function (t) {\n            return e.push(t.canonicalString());\n          }), {\n            fieldPaths: e\n          };\n        }, t.prototype.fromDocumentMask = function (t) {\n          var e = (t.fieldPaths || []).map(function (t) {\n            return dr.fromServerFormat(t);\n          });\n          return li.fromArray(e);\n        }, t;\n      }();\n\n      function po(t, e, n) {\n        return e === n || !e && n in t;\n      }\n\n      var mo = function () {\n        function t(t) {\n          this.sendFn = t.sendFn, this.closeFn = t.closeFn;\n        }\n\n        return t.prototype.onOpen = function (t) {\n          vn(!this.wrappedOnOpen, \"Called onOpen on stream twice!\"), this.wrappedOnOpen = t;\n        }, t.prototype.onClose = function (t) {\n          vn(!this.wrappedOnClose, \"Called onClose on stream twice!\"), this.wrappedOnClose = t;\n        }, t.prototype.onMessage = function (t) {\n          vn(!this.wrappedOnMessage, \"Called onMessage on stream twice!\"), this.wrappedOnMessage = t;\n        }, t.prototype.close = function () {\n          this.closeFn();\n        }, t.prototype.send = function (t) {\n          this.sendFn(t);\n        }, t.prototype.callOnOpen = function () {\n          vn(void 0 !== this.wrappedOnOpen, \"Cannot call onOpen because no callback was set\"), this.wrappedOnOpen();\n        }, t.prototype.callOnClose = function (t) {\n          vn(void 0 !== this.wrappedOnClose, \"Cannot call onClose because no callback was set\"), this.wrappedOnClose(t);\n        }, t.prototype.callOnMessage = function (t) {\n          vn(void 0 !== this.wrappedOnMessage, \"Cannot call onMessage because no callback was set\"), this.wrappedOnMessage(t);\n        }, t;\n      }(),\n          yo = \"Connection\",\n          go = {\n        BatchGetDocuments: \"batchGet\",\n        Commit: \"commit\"\n      },\n          vo = \"gl-js/ fire/\" + hn,\n          bo = function () {\n        function t(t) {\n          this.databaseId = t.databaseId;\n          var e = t.ssl ? \"https\" : \"http\";\n          this.baseUrl = e + \"://\" + t.host;\n        }\n\n        return t.prototype.modifyHeadersForRequest = function (t, e) {\n          if (e) for (var n in e.authHeaders) {\n            e.authHeaders.hasOwnProperty(n) && (t[n] = e.authHeaders[n]);\n          }\n          t[\"X-Goog-Api-Client\"] = vo;\n        }, t.prototype.invokeRPC = function (o, s, a) {\n          var u = this,\n              c = this.makeUrl(o);\n          return new Promise(function (n, r) {\n            var i = new nn();\n            i.listenOnce(tn.COMPLETE, function () {\n              try {\n                switch (i.getLastErrorCode()) {\n                  case Ze.NO_ERROR:\n                    var t = i.getResponseJson();\n                    dn(yo, \"XHR received:\", JSON.stringify(t)), n(t);\n                    break;\n\n                  case Ze.TIMEOUT:\n                    dn(yo, 'RPC \"' + o + '\" timed out'), r(new Sn(En.DEADLINE_EXCEEDED, \"Request time out\"));\n                    break;\n\n                  case Ze.HTTP_ERROR:\n                    var e = i.getStatus();\n                    dn(yo, 'RPC \"' + o + '\" failed with status:', e, \"response text:\", i.getResponseText()), 0 < e ? r(new Sn(function (t) {\n                      switch (t) {\n                        case 200:\n                          return En.OK;\n\n                        case 400:\n                          return En.INVALID_ARGUMENT;\n\n                        case 401:\n                          return En.UNAUTHENTICATED;\n\n                        case 403:\n                          return En.PERMISSION_DENIED;\n\n                        case 404:\n                          return En.NOT_FOUND;\n\n                        case 409:\n                          return En.ABORTED;\n\n                        case 416:\n                          return En.OUT_OF_RANGE;\n\n                        case 429:\n                          return En.RESOURCE_EXHAUSTED;\n\n                        case 499:\n                          return En.CANCELLED;\n\n                        case 500:\n                          return En.UNKNOWN;\n\n                        case 501:\n                          return En.UNIMPLEMENTED;\n\n                        case 503:\n                          return En.UNAVAILABLE;\n\n                        case 504:\n                          return En.DEADLINE_EXCEEDED;\n\n                        default:\n                          return 200 <= t && t < 300 ? En.OK : 400 <= t && t < 500 ? En.FAILED_PRECONDITION : 500 <= t && t < 600 ? En.INTERNAL : En.UNKNOWN;\n                      }\n                    }(e), \"Server responded with status \" + i.getStatusText())) : (dn(yo, 'RPC \"' + o + '\" failed'), r(new Sn(En.UNAVAILABLE, \"Connection failed.\")));\n                    break;\n\n                  default:\n                    gn('RPC \"' + o + '\" failed with unanticipated webchannel error ' + i.getLastErrorCode() + \": \" + i.getLastError() + \", giving up.\");\n                }\n              } finally {\n                dn(yo, 'RPC \"' + o + '\" completed.');\n              }\n            });\n            var t = JSON.stringify(s);\n            dn(yo, \"XHR sending: \", c + \" \" + t);\n            var e = {\n              \"Content-Type\": \"text/plain\"\n            };\n            u.modifyHeadersForRequest(e, a), i.send(c, \"POST\", t, e, 15);\n          });\n        }, t.prototype.invokeStreamingRPC = function (t, e, n) {\n          return this.invokeRPC(t, e, n);\n        }, t.prototype.openStream = function (t, e) {\n          var n = [this.baseUrl, \"/\", \"google.firestore.v1.Firestore\", \"/\", t, \"/channel\"],\n              r = $e(),\n              i = {\n            backgroundChannelTest: !0,\n            httpSessionIdParam: \"gsessionid\",\n            initMessageHeaders: {},\n            messageUrlParams: {\n              database: \"projects/\" + this.databaseId.projectId + \"/databases/\" + this.databaseId.database\n            },\n            sendRawJson: !0,\n            supportsCrossDomainXhr: !0,\n            internalChannelParams: {\n              forwardChannelRequestTimeoutMs: 6e5\n            }\n          };\n          this.modifyHeadersForRequest(i.initMessageHeaders, e), \"object\" == typeof navigator && \"ReactNative\" === navigator.product || (i.httpHeadersOverwriteParam = \"$httpHeaders\");\n          var o = n.join(\"\");\n          dn(yo, \"Creating WebChannel: \" + o + \" \" + i);\n\n          var s = r.createWebChannel(o, i),\n              a = !1,\n              u = !1,\n              c = new mo({\n            sendFn: function sendFn(t) {\n              u ? dn(yo, \"Not sending because WebChannel is closed:\", t) : (a || (dn(yo, \"Opening WebChannel transport.\"), s.open(), a = !0), dn(yo, \"WebChannel sending:\", t), s.send(t));\n            },\n            closeFn: function closeFn() {\n              return s.close();\n            }\n          }),\n              h = function h(t, e) {\n            s.listen(t, function (t) {\n              try {\n                e(t);\n              } catch (t) {\n                setTimeout(function () {\n                  throw t;\n                }, 0);\n              }\n            });\n          };\n\n          return h(en.EventType.OPEN, function () {\n            u || dn(yo, \"WebChannel transport opened.\");\n          }), h(en.EventType.CLOSE, function () {\n            u || (u = !0, dn(yo, \"WebChannel transport closed\"), c.callOnClose());\n          }), h(en.EventType.ERROR, function (t) {\n            u || (u = !0, dn(yo, \"WebChannel transport errored:\", t), c.callOnClose(new Sn(En.UNAVAILABLE, \"The operation could not be completed\")));\n          }), h(en.EventType.MESSAGE, function (t) {\n            if (!u) {\n              var e = t.data[0];\n              vn(!!e, \"Got a webchannel message without data.\");\n              var n = e.error || e[0] && e[0].error;\n\n              if (n) {\n                dn(yo, \"WebChannel received error:\", n);\n\n                var r = n.status,\n                    i = function (t) {\n                  var e = Ci[t];\n                  if (void 0 !== e) return ki(e);\n                }(r),\n                    o = n.message;\n\n                void 0 === i && (i = En.INTERNAL, o = \"Unknown error status: \" + r + \" with message \" + n.message), u = !0, c.callOnClose(new Sn(i, o)), s.close();\n              } else dn(yo, \"WebChannel received:\", e), c.callOnMessage(e);\n            }\n          }), setTimeout(function () {\n            c.callOnOpen();\n          }, 0), c;\n        }, t.prototype.makeUrl = function (t) {\n          var e = go[t];\n          vn(void 0 !== e, \"Unknown REST mapping for: \" + t);\n          var n = [this.baseUrl, \"/\", \"v1\"];\n          return n.push(\"/projects/\"), n.push(this.databaseId.projectId), n.push(\"/databases/\"), n.push(this.databaseId.database), n.push(\"/documents\"), n.push(\":\"), n.push(e), n.join(\"\");\n        }, t;\n      }(),\n          wo = function () {\n        function t() {\n          this.emptyByteString = \"\", this.base64Available = \"undefined\" != typeof atob;\n        }\n\n        return Object.defineProperty(t.prototype, \"document\", {\n          get: function get() {\n            return \"undefined\" != typeof document ? document : null;\n          },\n          enumerable: !0,\n          configurable: !0\n        }), Object.defineProperty(t.prototype, \"window\", {\n          get: function get() {\n            return \"undefined\" != typeof window ? window : null;\n          },\n          enumerable: !0,\n          configurable: !0\n        }), t.prototype.loadConnection = function (t) {\n          return Promise.resolve(new bo(t));\n        }, t.prototype.newSerializer = function (t) {\n          return new fo(t, {\n            useProto3Json: !0\n          });\n        }, t.prototype.formatJSON = function (t) {\n          return JSON.stringify(t);\n        }, t.prototype.atob = function (t) {\n          return atob(t);\n        }, t.prototype.btoa = function (t) {\n          return btoa(t);\n        }, t;\n      }();\n\n      bn.setPlatform(new wo());\n\n      var Eo,\n          So,\n          To = function () {\n        function t(t, e) {\n          var n = this;\n          this.previousValue = t, e && (e.sequenceNumberHandler = function (t) {\n            return n.setPreviousValue(t);\n          }, this.writeNewSequenceNumber = function (t) {\n            return e.writeSequenceNumber(t);\n          });\n        }\n\n        return t.prototype.setPreviousValue = function (t) {\n          return this.previousValue = Math.max(t, this.previousValue), this.previousValue;\n        }, t.prototype.next = function () {\n          var t = ++this.previousValue;\n          return this.writeNewSequenceNumber && this.writeNewSequenceNumber(t), t;\n        }, t.INVALID = -1, t;\n      }(),\n          Io = function Io() {\n        var n = this;\n        this.promise = new Promise(function (t, e) {\n          n.resolve = t, n.reject = e;\n        });\n      };\n\n      (So = Eo || (Eo = {})).All = \"all\", So.ListenStreamIdle = \"listen_stream_idle\", So.ListenStreamConnectionBackoff = \"listen_stream_connection_backoff\", So.WriteStreamIdle = \"write_stream_idle\", So.WriteStreamConnectionBackoff = \"write_stream_connection_backoff\", So.OnlineStateTimeout = \"online_state_timeout\", So.ClientMetadataRefresh = \"client_metadata_refresh\", So.LruGarbageCollection = \"lru_garbage_collection\";\n\n      var Co = function () {\n        function s(t, e, n, r, i) {\n          this.asyncQueue = t, this.timerId = e, this.targetTimeMs = n, this.op = r, this.removalCallback = i, this.deferred = new Io(), this.then = this.deferred.promise.then.bind(this.deferred.promise), this.catch = this.deferred.promise.catch.bind(this.deferred.promise), this.deferred.promise.catch(function (t) {});\n        }\n\n        return s.createAndSchedule = function (t, e, n, r, i) {\n          var o = new s(t, e, Date.now() + n, r, i);\n          return o.start(n), o;\n        }, s.prototype.start = function (t) {\n          var e = this;\n          this.timerHandle = setTimeout(function () {\n            return e.handleDelayElapsed();\n          }, t);\n        }, s.prototype.skipDelay = function () {\n          return this.handleDelayElapsed();\n        }, s.prototype.cancel = function (t) {\n          null !== this.timerHandle && (this.clearTimeout(), this.deferred.reject(new Sn(En.CANCELLED, \"Operation cancelled\" + (t ? \": \" + t : \"\"))));\n        }, s.prototype.handleDelayElapsed = function () {\n          var e = this;\n          this.asyncQueue.enqueueAndForget(function () {\n            return null !== e.timerHandle ? (e.clearTimeout(), e.op().then(function (t) {\n              return e.deferred.resolve(t);\n            })) : Promise.resolve();\n          });\n        }, s.prototype.clearTimeout = function () {\n          null !== this.timerHandle && (this.removalCallback(this), clearTimeout(this.timerHandle), this.timerHandle = null);\n        }, s;\n      }(),\n          Do = function () {\n        function t() {\n          this.tail = Promise.resolve(), this.delayedOperations = [], this.operationInProgress = !1;\n        }\n\n        return t.prototype.enqueueAndForget = function (t) {\n          this.enqueue(t);\n        }, t.prototype.enqueue = function (t) {\n          var n = this;\n          this.verifyNotFailed();\n          var e = this.tail.then(function () {\n            return n.operationInProgress = !0, t().catch(function (t) {\n              n.failure = t, n.operationInProgress = !1;\n              var e = t.stack || t.message || \"\";\n              throw mn(\"INTERNAL UNHANDLED ERROR: \", e), e.indexOf(\"Firestore Test Simulated Error\") < 0 && setTimeout(function () {\n                throw t;\n              }, 0), t;\n            }).then(function (t) {\n              return n.operationInProgress = !1, t;\n            });\n          });\n          return this.tail = e;\n        }, t.prototype.enqueueAfterDelay = function (t, e, n) {\n          var r = this;\n          this.verifyNotFailed(), vn(0 <= e, \"Attempted to schedule an operation with a negative delay of \" + e), vn(!this.containsDelayedOperation(t), \"Attempted to schedule multiple operations with timer id \" + t + \".\");\n          var i = Co.createAndSchedule(this, t, e, n, function (t) {\n            return r.removeDelayedOperation(t);\n          });\n          return this.delayedOperations.push(i), i;\n        }, t.prototype.verifyNotFailed = function () {\n          this.failure && gn(\"AsyncQueue is already failed: \" + (this.failure.stack || this.failure.message));\n        }, t.prototype.verifyOperationInProgress = function () {\n          vn(this.operationInProgress, \"verifyOpInProgress() called when no op in progress on this queue.\");\n        }, t.prototype.drain = function () {\n          return this.enqueue(function () {\n            return Promise.resolve();\n          });\n        }, t.prototype.containsDelayedOperation = function (t) {\n          for (var e = 0, n = this.delayedOperations; e < n.length; e++) {\n            if (n[e].timerId === t) return !0;\n          }\n\n          return !1;\n        }, t.prototype.runDelayedOperationsEarly = function (r) {\n          var i = this;\n          return this.drain().then(function () {\n            vn(r === Eo.All || i.containsDelayedOperation(r), \"Attempted to drain to missing operation \" + r), i.delayedOperations.sort(function (t, e) {\n              return t.targetTimeMs - e.targetTimeMs;\n            });\n\n            for (var t = 0, e = i.delayedOperations; t < e.length; t++) {\n              var n = e[t];\n              if (n.skipDelay(), r !== Eo.All && n.timerId === r) break;\n            }\n\n            return i.drain();\n          });\n        }, t.prototype.removeDelayedOperation = function (t) {\n          var e = this.delayedOperations.indexOf(t);\n          vn(0 <= e, \"Delayed operation not found.\"), this.delayedOperations.splice(e, 1);\n        }, t;\n      }(),\n          No = \"\u0001\",\n          Ao = \"\u0001\",\n          ko = \"\u0010\",\n          Ro = \"\u0011\";\n\n      function Mo(t) {\n        for (var e = \"\", n = 0; n < t.length; n++) {\n          0 < e.length && (e = Oo(e)), e = _o(t.get(n), e);\n        }\n\n        return Oo(e);\n      }\n\n      function _o(t, e) {\n        for (var n = e, r = t.length, i = 0; i < r; i++) {\n          var o = t.charAt(i);\n\n          switch (o) {\n            case \"\\0\":\n              n += No + ko;\n              break;\n\n            case No:\n              n += No + Ro;\n              break;\n\n            default:\n              n += o;\n          }\n        }\n\n        return n;\n      }\n\n      function Oo(t) {\n        return t + No + Ao;\n      }\n\n      function Po(t) {\n        var e = t.length;\n        if (vn(2 <= e, \"Invalid path \" + t), 2 === e) return vn(t.charAt(0) === No && t.charAt(1) === Ao, \"Non-empty path \" + t + \" had length 2\"), fr.EMPTY_PATH;\n\n        for (var n = e - 2, r = [], i = \"\", o = 0; o < e;) {\n          var s = t.indexOf(No, o);\n\n          switch ((s < 0 || n < s) && gn('Invalid encoded resource path: \"' + t + '\"'), t.charAt(s + 1)) {\n            case Ao:\n              var a = t.substring(o, s),\n                  u = void 0;\n              0 === i.length ? u = a : (u = i += a, i = \"\"), r.push(u);\n              break;\n\n            case ko:\n              i += t.substring(o, s), i += \"\\0\";\n              break;\n\n            case Ro:\n              i += t.substring(o, s + 1);\n              break;\n\n            default:\n              gn('Invalid encoded resource path: \"' + t + '\"');\n          }\n\n          o = s + 2;\n        }\n\n        return new fr(r);\n      }\n\n      var Lo = function () {\n        function t(t, e, n, r) {\n          this.batchId = t, this.localWriteTime = e, this.baseMutations = n, vn(0 < (this.mutations = r).length, \"Cannot create an empty mutation batch\");\n        }\n\n        return t.prototype.applyToRemoteDocument = function (t, e, n) {\n          e && vn(e.key.isEqual(t), \"applyToRemoteDocument: key \" + t + \" should match maybeDoc key\\n        \" + e.key);\n          var r = n.mutationResults;\n          vn(r.length === this.mutations.length, \"Mismatch between mutations length\\n      (\" + this.mutations.length + \") and mutation results length\\n      (\" + r.length + \").\");\n\n          for (var i = 0; i < this.mutations.length; i++) {\n            var o = this.mutations[i];\n\n            if (o.key.isEqual(t)) {\n              var s = r[i];\n              e = o.applyToRemoteDocument(e, s);\n            }\n          }\n\n          return e;\n        }, t.prototype.applyToLocalView = function (t, e) {\n          e && vn(e.key.isEqual(t), \"applyToLocalDocument: key \" + t + \" should match maybeDoc key\\n        \" + e.key);\n\n          for (var n = 0, r = this.baseMutations; n < r.length; n++) {\n            (a = r[n]).key.isEqual(t) && (e = a.applyToLocalView(e, e, this.localWriteTime));\n          }\n\n          for (var i = e, o = 0, s = this.mutations; o < s.length; o++) {\n            var a;\n            (a = s[o]).key.isEqual(t) && (e = a.applyToLocalView(e, i, this.localWriteTime));\n          }\n\n          return e;\n        }, t.prototype.applyToLocalDocumentSet = function (n) {\n          var r = this,\n              i = n;\n          return this.mutations.forEach(function (t) {\n            var e = r.applyToLocalView(t.key, n.get(t.key));\n            e && (i = i.insert(t.key, e));\n          }), i;\n        }, t.prototype.keys = function () {\n          return this.mutations.reduce(function (t, e) {\n            return t.add(e.key);\n          }, Fi());\n        }, t.prototype.isEqual = function (t) {\n          return this.batchId === t.batchId && Yn(this.mutations, t.mutations) && Yn(this.baseMutations, t.baseMutations);\n        }, t;\n      }(),\n          xo = function () {\n        function a(t, e, n, r, i) {\n          this.batch = t, this.commitVersion = e, this.mutationResults = n, this.streamToken = r, this.docVersions = i;\n        }\n\n        return a.from = function (t, e, n, r) {\n          vn(t.mutations.length === n.length, \"Mutations sent \" + t.mutations.length + \" must equal results received \" + n.length);\n\n          for (var i = xi(), o = t.mutations, s = 0; s < o.length; s++) {\n            i = i.insert(o[s].key, n[s].version);\n          }\n\n          return new a(t, e, n, r, i);\n        }, a;\n      }(),\n          qo = function () {\n        function s(t) {\n          var e = this;\n          this.nextCallback = null, this.catchCallback = null, this.result = void 0, this.error = void 0, this.isDone = !1, this.callbackAttached = !1, t(function (t) {\n            e.isDone = !0, e.result = t, e.nextCallback && e.nextCallback(t);\n          }, function (t) {\n            e.isDone = !0, e.error = t, e.catchCallback && e.catchCallback(t);\n          });\n        }\n\n        return s.prototype.catch = function (t) {\n          return this.next(void 0, t);\n        }, s.prototype.next = function (r, i) {\n          var o = this;\n          return this.callbackAttached && gn(\"Called next() or catch() twice for PersistencePromise\"), this.callbackAttached = !0, this.isDone ? this.error ? this.wrapFailure(i, this.error) : this.wrapSuccess(r, this.result) : new s(function (e, n) {\n            o.nextCallback = function (t) {\n              o.wrapSuccess(r, t).next(e, n);\n            }, o.catchCallback = function (t) {\n              o.wrapFailure(i, t).next(e, n);\n            };\n          });\n        }, s.prototype.toPromise = function () {\n          var n = this;\n          return new Promise(function (t, e) {\n            n.next(t, e);\n          });\n        }, s.prototype.wrapUserFunction = function (t) {\n          try {\n            var e = t();\n            return e instanceof s ? e : s.resolve(e);\n          } catch (t) {\n            return s.reject(t);\n          }\n        }, s.prototype.wrapSuccess = function (t, e) {\n          return t ? this.wrapUserFunction(function () {\n            return t(e);\n          }) : s.resolve(e);\n        }, s.prototype.wrapFailure = function (t, e) {\n          return t ? this.wrapUserFunction(function () {\n            return t(e);\n          }) : s.reject(e);\n        }, s.resolve = function (n) {\n          return new s(function (t, e) {\n            t(n);\n          });\n        }, s.reject = function (n) {\n          return new s(function (t, e) {\n            e(n);\n          });\n        }, s.waitFor = function (t) {\n          return new s(function (e, n) {\n            var r = 0,\n                i = 0,\n                o = !1;\n            t.forEach(function (t) {\n              ++r, t.next(function () {\n                ++i, o && i === r && e();\n              }, function (t) {\n                return n(t);\n              });\n            }), o = !0, i === r && e();\n          });\n        }, s.or = function (t) {\n          for (var n = s.resolve(!1), e = function e(_e4) {\n            n = n.next(function (t) {\n              return t ? s.resolve(t) : _e4();\n            });\n          }, r = 0, i = t; r < i.length; r++) {\n            e(i[r]);\n          }\n\n          return n;\n        }, s.forEach = function (t, n) {\n          var r = this,\n              i = [];\n          return t.forEach(function (t, e) {\n            i.push(n.call(r, t, e));\n          }), this.waitFor(i);\n        }, s;\n      }(),\n          Fo = function () {\n        function i(t, e, n, r) {\n          this.userId = t, this.serializer = e, this.indexManager = n, this.referenceDelegate = r, this.documentKeysByBatchId = {};\n        }\n\n        return i.forUser = function (t, e, n, r) {\n          return vn(\"\" !== t.uid, \"UserID must not be an empty string.\"), new i(t.isAuthenticated() ? t.uid : \"\", e, n, r);\n        }, i.prototype.checkEmpty = function (t) {\n          var r = !0,\n              e = IDBKeyRange.bound([this.userId, Number.NEGATIVE_INFINITY], [this.userId, Number.POSITIVE_INFINITY]);\n          return Qo(t).iterate({\n            index: Ss.userMutationsIndex,\n            range: e\n          }, function (t, e, n) {\n            r = !1, n.done();\n          }).next(function () {\n            return r;\n          });\n        }, i.prototype.acknowledgeBatch = function (e, t, n) {\n          return this.getMutationQueueMetadata(e).next(function (t) {\n            return t.lastStreamToken = Uo(n), jo(e).put(t);\n          });\n        }, i.prototype.getLastStreamToken = function (t) {\n          return this.getMutationQueueMetadata(t).next(function (t) {\n            return t.lastStreamToken;\n          });\n        }, i.prototype.setLastStreamToken = function (e, n) {\n          return this.getMutationQueueMetadata(e).next(function (t) {\n            return t.lastStreamToken = Uo(n), jo(e).put(t);\n          });\n        }, i.prototype.addMutationBatch = function (u, c, h, l) {\n          var f = this,\n              p = Ko(u),\n              d = Qo(u);\n          return d.add({}).next(function (t) {\n            vn(\"number\" == typeof t, \"Auto-generated key is not a number\");\n            var e = new Lo(t, c, h, l),\n                n = f.serializer.toDbMutationBatch(f.userId, e);\n            f.documentKeysByBatchId[t] = e.keys();\n\n            for (var r = [], i = 0, o = l; i < o.length; i++) {\n              var s = o[i],\n                  a = Ts.key(f.userId, s.key.path, t);\n              r.push(d.put(n)), r.push(p.put(a, Ts.PLACEHOLDER)), r.push(f.indexManager.addToCollectionParentIndex(u, s.key.path.popLast()));\n            }\n\n            return qo.waitFor(r).next(function () {\n              return e;\n            });\n          });\n        }, i.prototype.lookupMutationBatch = function (t, e) {\n          var n = this;\n          return Qo(t).get(e).next(function (t) {\n            return t ? (vn(t.userId === n.userId, \"Unexpected user '\" + t.userId + \"' for mutation batch \" + e), n.serializer.fromDbMutationBatch(t)) : null;\n          });\n        }, i.prototype.lookupMutationKeys = function (t, n) {\n          var r = this;\n          return this.documentKeysByBatchId[n] ? qo.resolve(this.documentKeysByBatchId[n]) : this.lookupMutationBatch(t, n).next(function (t) {\n            if (t) {\n              var e = t.keys();\n              return r.documentKeysByBatchId[n] = e;\n            }\n\n            return null;\n          });\n        }, i.prototype.getNextMutationBatchAfterBatchId = function (n, o) {\n          var s = this;\n          return this.getMutationQueueMetadata(n).next(function (t) {\n            var r = o + 1,\n                e = IDBKeyRange.lowerBound([s.userId, r]),\n                i = null;\n            return Qo(n).iterate({\n              index: Ss.userMutationsIndex,\n              range: e\n            }, function (t, e, n) {\n              e.userId === s.userId && (vn(e.batchId >= r, \"Should have found mutation after \" + r), i = s.serializer.fromDbMutationBatch(e)), n.done();\n            }).next(function () {\n              return i;\n            });\n          });\n        }, i.prototype.getAllMutationBatches = function (t) {\n          var e = this,\n              n = IDBKeyRange.bound([this.userId, -1], [this.userId, Number.POSITIVE_INFINITY]);\n          return Qo(t).loadAll(Ss.userMutationsIndex, n).next(function (t) {\n            return t.map(function (t) {\n              return e.serializer.fromDbMutationBatch(t);\n            });\n          });\n        }, i.prototype.getAllMutationBatchesAffectingDocumentKey = function (a, u) {\n          var c = this,\n              t = Ts.prefixForPath(this.userId, u.path),\n              e = IDBKeyRange.lowerBound(t),\n              h = [];\n          return Ko(a).iterate({\n            range: e\n          }, function (e, t, n) {\n            var r = e[0],\n                i = e[1],\n                o = e[2],\n                s = Po(i);\n            if (r === c.userId && u.path.isEqual(s)) return Qo(a).get(o).next(function (t) {\n              if (!t) throw gn(\"Dangling document-mutation reference found: \" + e + \" which points to \" + o);\n              vn(t.userId === c.userId, \"Unexpected user '\" + t.userId + \"' for mutation batch \" + o), h.push(c.serializer.fromDbMutationBatch(t));\n            });\n            n.done();\n          }).next(function () {\n            return h;\n          });\n        }, i.prototype.getAllMutationBatchesAffectingDocumentKeys = function (r, t) {\n          var u = this,\n              c = new ci(Hn),\n              i = [];\n          return t.forEach(function (a) {\n            var t = Ts.prefixForPath(u.userId, a.path),\n                e = IDBKeyRange.lowerBound(t),\n                n = Ko(r).iterate({\n              range: e\n            }, function (t, e, n) {\n              var r = t[0],\n                  i = t[1],\n                  o = t[2],\n                  s = Po(i);\n              r === u.userId && a.path.isEqual(s) ? c = c.add(o) : n.done();\n            });\n            i.push(n);\n          }), qo.waitFor(i).next(function () {\n            return u.lookupMutationBatches(r, c);\n          });\n        }, i.prototype.getAllMutationBatchesAffectingQuery = function (t, e) {\n          var a = this;\n          vn(!e.isDocumentQuery(), \"Document queries shouldn't go down this path\"), vn(!e.isCollectionGroupQuery(), \"CollectionGroup queries should be handled in LocalDocumentsView\");\n          var u = e.path,\n              c = u.length + 1,\n              n = Ts.prefixForPath(this.userId, u),\n              r = IDBKeyRange.lowerBound(n),\n              h = new ci(Hn);\n          return Ko(t).iterate({\n            range: r\n          }, function (t, e, n) {\n            var r = t[0],\n                i = t[1],\n                o = t[2],\n                s = Po(i);\n            r === a.userId && u.isPrefixOf(s) ? s.length === c && (h = h.add(o)) : n.done();\n          }).next(function () {\n            return a.lookupMutationBatches(t, h);\n          });\n        }, i.prototype.lookupMutationBatches = function (t, e) {\n          var n = this,\n              r = [],\n              i = [];\n          return e.forEach(function (e) {\n            i.push(Qo(t).get(e).next(function (t) {\n              if (null === t) throw gn(\"Dangling document-mutation reference found, which points to \" + e);\n              vn(t.userId === n.userId, \"Unexpected user '\" + t.userId + \"' for mutation batch \" + e), r.push(n.serializer.fromDbMutationBatch(t));\n            }));\n          }), qo.waitFor(i).next(function () {\n            return r;\n          });\n        }, i.prototype.removeMutationBatch = function (e, n) {\n          var r = this;\n          return Bo(e.simpleDbTransaction, this.userId, n).next(function (t) {\n            return r.removeCachedMutationKeys(n.batchId), qo.forEach(t, function (t) {\n              return r.referenceDelegate.removeMutationReference(e, t);\n            });\n          });\n        }, i.prototype.removeCachedMutationKeys = function (t) {\n          delete this.documentKeysByBatchId[t];\n        }, i.prototype.performConsistencyCheck = function (n) {\n          var o = this;\n          return this.checkEmpty(n).next(function (t) {\n            if (!t) return qo.resolve();\n            var e = IDBKeyRange.lowerBound(Ts.prefixForUser(o.userId)),\n                i = [];\n            return Ko(n).iterate({\n              range: e\n            }, function (t, e, n) {\n              if (t[0] === o.userId) {\n                var r = Po(t[1]);\n                i.push(r);\n              } else n.done();\n            }).next(function () {\n              vn(0 === i.length, \"Document leak -- detected dangling mutation references when queue is empty. Dangling keys: \" + i.map(function (t) {\n                return t.canonicalString();\n              }));\n            });\n          });\n        }, i.prototype.containsKey = function (t, e) {\n          return Vo(t, this.userId, e);\n        }, i.prototype.getMutationQueueMetadata = function (t) {\n          var e = this;\n          return jo(t).get(this.userId).next(function (t) {\n            return t || new Es(e.userId, -1, \"\");\n          });\n        }, i;\n      }();\n\n      function Vo(t, o, e) {\n        var n = Ts.prefixForPath(o, e.path),\n            s = n[1],\n            r = IDBKeyRange.lowerBound(n),\n            a = !1;\n        return Ko(t).iterate({\n          range: r,\n          keysOnly: !0\n        }, function (t, e, n) {\n          var r = t[0],\n              i = t[1];\n          t[2];\n          r === o && i === s && (a = !0), n.done();\n        }).next(function () {\n          return a;\n        });\n      }\n\n      function Bo(t, e, n) {\n        var r = t.store(Ss.store),\n            i = t.store(Ts.store),\n            o = [],\n            s = IDBKeyRange.only(n.batchId),\n            a = 0,\n            u = r.iterate({\n          range: s\n        }, function (t, e, n) {\n          return a++, n.delete();\n        });\n        o.push(u.next(function () {\n          vn(1 === a, \"Dangling document-mutation reference found: Missing batch \" + n.batchId);\n        }));\n\n        for (var c = [], h = 0, l = n.mutations; h < l.length; h++) {\n          var f = l[h],\n              p = Ts.key(e, f.key.path, n.batchId);\n          o.push(i.delete(p)), c.push(f.key);\n        }\n\n        return qo.waitFor(o).next(function () {\n          return c;\n        });\n      }\n\n      function Uo(t) {\n        return t instanceof Uint8Array ? (vn(\"YES\" === process.env.USE_MOCK_PERSISTENCE, \"Persisting non-string stream tokens is only supported with mock persistence.\"), t.toString()) : t;\n      }\n\n      function Qo(t) {\n        return Ys.getStore(t, Ss.store);\n      }\n\n      function Ko(t) {\n        return Ys.getStore(t, Ts.store);\n      }\n\n      function jo(t) {\n        return Ys.getStore(t, Es.store);\n      }\n\n      var Wo, Go;\n      (Go = Wo || (Wo = {}))[Go.QueryCache = 0] = \"QueryCache\", Go[Go.SyncEngine = 1] = \"SyncEngine\";\n\n      var zo = function () {\n        function t(t, e) {\n          vn((1 & (this.generatorId = t)) === t, \"Generator ID \" + t + \" contains more than 1 reserved bits\"), this.seek(void 0 !== e ? e : this.generatorId);\n        }\n\n        return t.prototype.next = function () {\n          var t = this.nextId;\n          return this.nextId += 2, t;\n        }, t.prototype.after = function (t) {\n          return this.seek(t + 2), this.next();\n        }, t.prototype.seek = function (t) {\n          vn((1 & t) === this.generatorId, \"Cannot supply target ID from different generator ID\"), this.nextId = t;\n        }, t.forQueryCache = function () {\n          return new t(Wo.QueryCache, 2);\n        }, t.forSyncEngine = function () {\n          return new t(Wo.SyncEngine);\n        }, t;\n      }(),\n          Ho = \"SimpleDb\",\n          Yo = function () {\n        function a(t) {\n          this.db = t;\n        }\n\n        return a.openOrCreate = function (o, t, s) {\n          return vn(a.isAvailable(), \"IndexedDB not supported in current environment.\"), dn(Ho, \"Opening database:\", o), new qo(function (n, r) {\n            var i = window.indexedDB.open(o, t);\n            i.onsuccess = function (t) {\n              var e = t.target.result;\n              n(new a(e));\n            }, i.onblocked = function () {\n              r(new Sn(En.FAILED_PRECONDITION, \"Cannot upgrade IndexedDB schema while another tab is open. Close all tabs that access Firestore and reload this page to proceed.\"));\n            }, i.onerror = function (t) {\n              var e = t.target.error;\n              \"VersionError\" === e.name ? r(new Sn(En.FAILED_PRECONDITION, \"A newer version of the Firestore SDK was previously used and so the persisted data is not compatible with the version of the SDK you are now using. The SDK will operate with persistence disabled. If you need persistence, please re-upgrade to a newer version of the SDK or else clear the persisted IndexedDB data for your app to start fresh.\")) : r(e);\n            }, i.onupgradeneeded = function (t) {\n              dn(Ho, 'Database \"' + o + '\" requires upgrade from version:', t.oldVersion);\n              var e = t.target.result,\n                  n = new Jo(i.transaction);\n              s.createOrUpgrade(e, n, t.oldVersion, gs).next(function () {\n                dn(Ho, \"Database upgrade to version \" + gs + \" complete\");\n              });\n            };\n          }).toPromise();\n        }, a.delete = function (t) {\n          return dn(Ho, \"Removing database:\", t), Zo(window.indexedDB.deleteDatabase(t)).toPromise();\n        }, a.isAvailable = function () {\n          if (\"undefined\" == typeof window || null == window.indexedDB) return !1;\n          if (void 0 === window.navigator) return \"YES\" === process.env.USE_MOCK_PERSISTENCE;\n          var t = window.navigator.userAgent;\n          return !(0 < t.indexOf(\"MSIE \") || 0 < t.indexOf(\"Trident/\") || 0 < t.indexOf(\"Edge/\"));\n        }, a.getStore = function (t, e) {\n          return t.store(e);\n        }, a.prototype.runTransaction = function (t, e, n) {\n          var r = Jo.open(this.db, t, e),\n              i = n(r).catch(function (t) {\n            return r.abort(t), qo.reject(t);\n          }).toPromise();\n          return i.catch(function () {}), r.completionPromise.then(function () {\n            return i;\n          });\n        }, a.prototype.close = function () {\n          this.db.close();\n        }, a;\n      }(),\n          Xo = function () {\n        function t(t) {\n          this.dbCursor = t, this.shouldStop = !1, this.nextKey = null;\n        }\n\n        return Object.defineProperty(t.prototype, \"isDone\", {\n          get: function get() {\n            return this.shouldStop;\n          },\n          enumerable: !0,\n          configurable: !0\n        }), Object.defineProperty(t.prototype, \"skipToKey\", {\n          get: function get() {\n            return this.nextKey;\n          },\n          enumerable: !0,\n          configurable: !0\n        }), Object.defineProperty(t.prototype, \"cursor\", {\n          set: function set(t) {\n            this.dbCursor = t;\n          },\n          enumerable: !0,\n          configurable: !0\n        }), t.prototype.done = function () {\n          this.shouldStop = !0;\n        }, t.prototype.skip = function (t) {\n          this.nextKey = t;\n        }, t.prototype.delete = function () {\n          return Zo(this.dbCursor.delete());\n        }, t;\n      }(),\n          Jo = function () {\n        function r(t) {\n          var e = this;\n          this.transaction = t, this.aborted = !1, this.completionDeferred = new Io(), this.transaction.oncomplete = function () {\n            e.completionDeferred.resolve();\n          }, this.transaction.onabort = function () {\n            t.error ? e.completionDeferred.reject(t.error) : e.completionDeferred.resolve();\n          }, this.transaction.onerror = function (t) {\n            e.completionDeferred.reject(t.target.error);\n          };\n        }\n\n        return r.open = function (t, e, n) {\n          return new r(t.transaction(n, e));\n        }, Object.defineProperty(r.prototype, \"completionPromise\", {\n          get: function get() {\n            return this.completionDeferred.promise;\n          },\n          enumerable: !0,\n          configurable: !0\n        }), r.prototype.abort = function (t) {\n          t && this.completionDeferred.reject(t), this.aborted || (dn(Ho, \"Aborting transaction:\", t ? t.message : \"Client-initiated abort\"), this.aborted = !0, this.transaction.abort());\n        }, r.prototype.store = function (t) {\n          var e = this.transaction.objectStore(t);\n          return vn(!!e, \"Object store not part of transaction: \" + t), new $o(e);\n        }, r;\n      }(),\n          $o = function () {\n        function t(t) {\n          this.store = t;\n        }\n\n        return t.prototype.put = function (t, e) {\n          return Zo(void 0 !== e ? (dn(Ho, \"PUT\", this.store.name, t, e), this.store.put(e, t)) : (dn(Ho, \"PUT\", this.store.name, \"<auto-key>\", t), this.store.put(t)));\n        }, t.prototype.add = function (t) {\n          return dn(Ho, \"ADD\", this.store.name, t, t), Zo(this.store.add(t));\n        }, t.prototype.get = function (e) {\n          var n = this;\n          return Zo(this.store.get(e)).next(function (t) {\n            return void 0 === t && (t = null), dn(Ho, \"GET\", n.store.name, e, t), t;\n          });\n        }, t.prototype.delete = function (t) {\n          return dn(Ho, \"DELETE\", this.store.name, t), Zo(this.store.delete(t));\n        }, t.prototype.count = function () {\n          return dn(Ho, \"COUNT\", this.store.name), Zo(this.store.count());\n        }, t.prototype.loadAll = function (t, e) {\n          var n = this.cursor(this.options(t, e)),\n              r = [];\n          return this.iterateCursor(n, function (t, e) {\n            r.push(e);\n          }).next(function () {\n            return r;\n          });\n        }, t.prototype.deleteAll = function (t, e) {\n          dn(Ho, \"DELETE ALL\", this.store.name);\n          var n = this.options(t, e);\n          n.keysOnly = !1;\n          var r = this.cursor(n);\n          return this.iterateCursor(r, function (t, e, n) {\n            return n.delete();\n          });\n        }, t.prototype.iterate = function (t, e) {\n          var n;\n          e ? n = t : (n = {}, e = t);\n          var r = this.cursor(n);\n          return this.iterateCursor(r, e);\n        }, t.prototype.iterateSerial = function (r) {\n          var t = this.cursor({});\n          return new qo(function (n, e) {\n            t.onerror = function (t) {\n              e(t.target.error);\n            }, t.onsuccess = function (t) {\n              var e = t.target.result;\n              e ? r(e.primaryKey, e.value).next(function (t) {\n                t ? e.continue() : n();\n              }) : n();\n            };\n          });\n        }, t.prototype.iterateCursor = function (t, s) {\n          var a = [];\n          return new qo(function (o, e) {\n            t.onerror = function (t) {\n              e(t.target.error);\n            }, t.onsuccess = function (t) {\n              var e = t.target.result;\n\n              if (e) {\n                var n = new Xo(e),\n                    r = s(e.primaryKey, e.value, n);\n\n                if (r instanceof qo) {\n                  var i = r.catch(function (t) {\n                    return n.done(), qo.reject(t);\n                  });\n                  a.push(i);\n                }\n\n                n.isDone ? o() : null === n.skipToKey ? e.continue() : e.continue(n.skipToKey);\n              } else o();\n            };\n          }).next(function () {\n            return qo.waitFor(a);\n          });\n        }, t.prototype.options = function (t, e) {\n          var n = void 0;\n          return void 0 !== t && (\"string\" == typeof t ? n = t : (vn(void 0 === e, \"3rd argument must not be defined if 2nd is a range.\"), e = t)), {\n            index: n,\n            range: e\n          };\n        }, t.prototype.cursor = function (t) {\n          var e = \"next\";\n\n          if (t.reverse && (e = \"prev\"), t.index) {\n            var n = this.store.index(t.index);\n            return t.keysOnly ? n.openKeyCursor(t.range, e) : n.openCursor(t.range, e);\n          }\n\n          return this.store.openCursor(t.range, e);\n        }, t;\n      }();\n\n      function Zo(t) {\n        return new qo(function (n, e) {\n          t.onsuccess = function (t) {\n            var e = t.target.result;\n            n(e);\n          }, t.onerror = function (t) {\n            e(t.target.error);\n          };\n        });\n      }\n\n      var ts = function () {\n        function t(t, e) {\n          this.referenceDelegate = t, this.serializer = e, this.targetIdGenerator = zo.forQueryCache();\n        }\n\n        return t.prototype.allocateTargetId = function (e) {\n          var n = this;\n          return this.retrieveMetadata(e).next(function (t) {\n            return t.highestTargetId = n.targetIdGenerator.after(t.highestTargetId), n.saveMetadata(e, t).next(function () {\n              return t.highestTargetId;\n            });\n          });\n        }, t.prototype.getLastRemoteSnapshotVersion = function (t) {\n          return this.retrieveMetadata(t).next(function (t) {\n            return oi.fromTimestamp(new sr(t.lastRemoteSnapshotVersion.seconds, t.lastRemoteSnapshotVersion.nanoseconds));\n          });\n        }, t.prototype.getHighestSequenceNumber = function (t) {\n          return rs(t.simpleDbTransaction);\n        }, t.prototype.setTargetsMetadata = function (e, n, r) {\n          var i = this;\n          return this.retrieveMetadata(e).next(function (t) {\n            return t.highestListenSequenceNumber = n, r && (t.lastRemoteSnapshotVersion = r.toTimestamp()), n > t.highestListenSequenceNumber && (t.highestListenSequenceNumber = n), i.saveMetadata(e, t);\n          });\n        }, t.prototype.addQueryData = function (e, n) {\n          var r = this;\n          return this.saveQueryData(e, n).next(function () {\n            return r.retrieveMetadata(e).next(function (t) {\n              return t.targetCount += 1, r.updateMetadataFromQueryData(n, t), r.saveMetadata(e, t);\n            });\n          });\n        }, t.prototype.updateQueryData = function (t, e) {\n          return this.saveQueryData(t, e);\n        }, t.prototype.removeQueryData = function (e, t) {\n          var n = this;\n          return this.removeMatchingKeysForTargetId(e, t.targetId).next(function () {\n            return es(e).delete(t.targetId);\n          }).next(function () {\n            return n.retrieveMetadata(e);\n          }).next(function (t) {\n            return vn(0 < t.targetCount, \"Removing from an empty query cache\"), t.targetCount -= 1, n.saveMetadata(e, t);\n          });\n        }, t.prototype.removeTargets = function (r, i, o) {\n          var s = this,\n              a = 0,\n              u = [];\n          return es(r).iterate(function (t, e) {\n            var n = s.serializer.fromDbTarget(e);\n            n.sequenceNumber <= i && void 0 === o[n.targetId] && (a++, u.push(s.removeQueryData(r, n)));\n          }).next(function () {\n            return qo.waitFor(u);\n          }).next(function () {\n            return a;\n          });\n        }, t.prototype.forEachTarget = function (t, r) {\n          var i = this;\n          return es(t).iterate(function (t, e) {\n            var n = i.serializer.fromDbTarget(e);\n            r(n);\n          });\n        }, t.prototype.retrieveMetadata = function (t) {\n          return ns(t.simpleDbTransaction);\n        }, t.prototype.saveMetadata = function (t, e) {\n          return (n = t, Ys.getStore(n, Rs.store)).put(Rs.key, e);\n          var n;\n        }, t.prototype.saveQueryData = function (t, e) {\n          return es(t).put(this.serializer.toDbTarget(e));\n        }, t.prototype.updateMetadataFromQueryData = function (t, e) {\n          var n = !1;\n          return t.targetId > e.highestTargetId && (e.highestTargetId = t.targetId, n = !0), t.sequenceNumber > e.highestListenSequenceNumber && (e.highestListenSequenceNumber = t.sequenceNumber, n = !0), n;\n        }, t.prototype.getQueryCount = function (t) {\n          return this.retrieveMetadata(t).next(function (t) {\n            return t.targetCount;\n          });\n        }, t.prototype.getQueryData = function (t, i) {\n          var o = this,\n              e = i.canonicalId(),\n              n = IDBKeyRange.bound([e, Number.NEGATIVE_INFINITY], [e, Number.POSITIVE_INFINITY]),\n              s = null;\n          return es(t).iterate({\n            range: n,\n            index: As.queryTargetsIndexName\n          }, function (t, e, n) {\n            var r = o.serializer.fromDbTarget(e);\n            i.isEqual(r.query) && (s = r, n.done());\n          }).next(function () {\n            return s;\n          });\n        }, t.prototype.addMatchingKeys = function (n, t, r) {\n          var i = this,\n              o = [],\n              s = is(n);\n          return t.forEach(function (t) {\n            var e = Mo(t.path);\n            o.push(s.put(new ks(r, e))), o.push(i.referenceDelegate.addReference(n, t));\n          }), qo.waitFor(o);\n        }, t.prototype.removeMatchingKeys = function (n, t, r) {\n          var i = this,\n              o = is(n);\n          return qo.forEach(t, function (t) {\n            var e = Mo(t.path);\n            return qo.waitFor([o.delete([r, e]), i.referenceDelegate.removeReference(n, t)]);\n          });\n        }, t.prototype.removeMatchingKeysForTargetId = function (t, e) {\n          var n = is(t),\n              r = IDBKeyRange.bound([e], [e + 1], !1, !0);\n          return n.delete(r);\n        }, t.prototype.getMatchingKeysForTargetId = function (t, e) {\n          var n = IDBKeyRange.bound([e], [e + 1], !1, !0),\n              r = is(t),\n              o = Fi();\n          return r.iterate({\n            range: n,\n            keysOnly: !0\n          }, function (t, e, n) {\n            var r = Po(t[1]),\n                i = new mr(r);\n            o = o.add(i);\n          }).next(function () {\n            return o;\n          });\n        }, t.prototype.containsKey = function (t, e) {\n          var n = Mo(e.path),\n              r = IDBKeyRange.bound([n], [Xn(n)], !1, !0),\n              i = 0;\n          return is(t).iterate({\n            index: ks.documentTargetsIndex,\n            keysOnly: !0,\n            range: r\n          }, function (t, e, n) {\n            var r = t[0];\n            t[1];\n            0 !== r && (i++, n.done());\n          }).next(function () {\n            return 0 < i;\n          });\n        }, t.prototype.getQueryDataForTarget = function (t, e) {\n          var n = this;\n          return es(t).get(e).next(function (t) {\n            return t ? n.serializer.fromDbTarget(t) : null;\n          });\n        }, t;\n      }();\n\n      function es(t) {\n        return Ys.getStore(t, As.store);\n      }\n\n      function ns(t) {\n        return Yo.getStore(t, Rs.store).get(Rs.key).next(function (t) {\n          return vn(null !== t, \"Missing metadata row.\"), t;\n        });\n      }\n\n      function rs(t) {\n        return ns(t).next(function (t) {\n          return t.highestListenSequenceNumber;\n        });\n      }\n\n      function is(t) {\n        return Ys.getStore(t, ks.store);\n      }\n\n      var os = function () {\n        function t(t) {\n          this.mapKeyFn = t, this.inner = {};\n        }\n\n        return t.prototype.get = function (t) {\n          var e = this.mapKeyFn(t),\n              n = this.inner[e];\n          if (void 0 !== n) for (var r = 0, i = n; r < i.length; r++) {\n            var o = i[r],\n                s = o[0],\n                a = o[1];\n            if (s.isEqual(t)) return a;\n          }\n        }, t.prototype.has = function (t) {\n          return void 0 !== this.get(t);\n        }, t.prototype.set = function (t, e) {\n          var n = this.mapKeyFn(t),\n              r = this.inner[n];\n\n          if (void 0 !== r) {\n            for (var i = 0; i < r.length; i++) {\n              if (r[i][0].isEqual(t)) return void (r[i] = [t, e]);\n            }\n\n            r.push([t, e]);\n          } else this.inner[n] = [[t, e]];\n        }, t.prototype.delete = function (t) {\n          var e = this.mapKeyFn(t),\n              n = this.inner[e];\n          if (void 0 === n) return !1;\n\n          for (var r = 0; r < n.length; r++) {\n            if (n[r][0].isEqual(t)) return 1 === n.length ? delete this.inner[e] : n.splice(r, 1), !0;\n          }\n\n          return !1;\n        }, t.prototype.forEach = function (a) {\n          Nn(this.inner, function (t, e) {\n            for (var n = 0, r = e; n < r.length; n++) {\n              var i = r[n],\n                  o = i[0],\n                  s = i[1];\n              a(o, s);\n            }\n          });\n        }, t.prototype.isEmpty = function () {\n          return An(this.inner);\n        }, t;\n      }(),\n          ss = function () {\n        function t() {\n          this.changes = Mi(), this.documentSizes = new os(function (t) {\n            return t.toString();\n          });\n        }\n\n        return t.prototype.addEntry = function (t) {\n          var e = this.assertChanges();\n          this.changes = e.insert(t.key, t);\n        }, t.prototype.getEntry = function (t, e) {\n          var n = this,\n              r = this.assertChanges().get(e);\n          return r ? qo.resolve(r) : this.getFromCache(t, e).next(function (t) {\n            return null === t ? (n.documentSizes.set(e, 0), null) : (n.documentSizes.set(e, t.size), t.maybeDocument);\n          });\n        }, t.prototype.getEntries = function (t, e) {\n          var n = this;\n          return this.getAllFromCache(t, e).next(function (t) {\n            var e = t.maybeDocuments;\n            return t.sizeMap.forEach(function (t, e) {\n              n.documentSizes.set(t, e);\n            }), e;\n          });\n        }, t.prototype.apply = function (t) {\n          var e = this.applyChanges(t);\n          return this.changes = null, e;\n        }, t.prototype.assertChanges = function () {\n          return vn(null !== this.changes, \"Changes have already been applied.\"), this.changes;\n        }, t;\n      }(),\n          as = \"The remote document changelog no longer contains all changes for all local query views. It may be necessary to rebuild these views.\",\n          us = function () {\n        function t(t, e, n) {\n          this.serializer = t, this.indexManager = e, this.keepDocumentChangeLog = n, this._lastProcessedDocumentChangeId = 0;\n        }\n\n        return Object.defineProperty(t.prototype, \"lastProcessedDocumentChangeId\", {\n          get: function get() {\n            return this._lastProcessedDocumentChangeId;\n          },\n          enumerable: !0,\n          configurable: !0\n        }), t.prototype.start = function (t) {\n          var e = Yo.getStore(t, Os.store);\n          return this.synchronizeLastDocumentChangeId(e);\n        }, t.prototype.addEntries = function (t, e, n) {\n          var r = [];\n\n          if (0 < e.length) {\n            for (var i = ls(t), o = Fi(), s = 0, a = e; s < a.length; s++) {\n              var u = a[s],\n                  c = u.key,\n                  h = u.doc;\n              r.push(i.put(ps(c), h)), o = o.add(c), r.push(this.indexManager.addToCollectionParentIndex(t, c.path.popLast()));\n            }\n\n            this.keepDocumentChangeLog && r.push(fs(t).put({\n              changes: this.serializer.toDbResourcePaths(o)\n            })), r.push(this.updateSize(t, n));\n          }\n\n          return qo.waitFor(r);\n        }, t.prototype.removeEntry = function (t, e) {\n          var n = ls(t),\n              r = ps(e);\n          return n.get(r).next(function (t) {\n            return t ? n.delete(r).next(function () {\n              return ds(t);\n            }) : qo.resolve(0);\n          });\n        }, t.prototype.getEntry = function (t, e) {\n          var n = this;\n          return ls(t).get(ps(e)).next(function (t) {\n            return t ? n.serializer.fromDbRemoteDocument(t) : null;\n          });\n        }, t.prototype.getSizedEntry = function (t, e) {\n          var n = this;\n          return ls(t).get(ps(e)).next(function (t) {\n            return t ? {\n              maybeDocument: n.serializer.fromDbRemoteDocument(t),\n              size: ds(t)\n            } : null;\n          });\n        }, t.prototype.getEntries = function (t, e) {\n          var n = this,\n              r = _i();\n\n          return this.forEachDbEntry(t, e, function (t, e) {\n            r = e ? r.insert(t, n.serializer.fromDbRemoteDocument(e)) : r.insert(t, null);\n          }).next(function () {\n            return r;\n          });\n        }, t.prototype.getSizedEntries = function (t, e) {\n          var n = this,\n              r = _i(),\n              i = new wr(mr.comparator);\n\n          return this.forEachDbEntry(t, e, function (t, e) {\n            i = e ? (r = r.insert(t, n.serializer.fromDbRemoteDocument(e)), i.insert(t, ds(e))) : (r = r.insert(t, null), i.insert(t, 0));\n          }).next(function () {\n            return {\n              maybeDocuments: r,\n              sizeMap: i\n            };\n          });\n        }, t.prototype.forEachDbEntry = function (t, e, i) {\n          if (e.isEmpty()) return qo.resolve();\n          var n = IDBKeyRange.bound(e.first().path.toArray(), e.last().path.toArray()),\n              o = e.getIterator(),\n              s = o.getNext();\n          return ls(t).iterate({\n            range: n\n          }, function (t, e, n) {\n            for (var r = mr.fromSegments(t); s && mr.comparator(s, r) < 0;) {\n              i(s, null), s = o.getNext();\n            }\n\n            s && s.isEqual(r) && (i(s, e), s = o.hasNext() ? o.getNext() : null), s ? n.skip(s.path.toArray()) : n.done();\n          }).next(function () {\n            for (; s;) {\n              i(s, null), s = o.hasNext() ? o.getNext() : null;\n            }\n          });\n        }, t.prototype.getDocumentsMatchingQuery = function (t, i) {\n          var o = this;\n          vn(!i.isCollectionGroupQuery(), \"CollectionGroup queries should be handled in LocalDocumentsView\");\n          var s = Pi(),\n              a = i.path.length + 1,\n              e = i.path.toArray(),\n              n = IDBKeyRange.lowerBound(e);\n          return ls(t).iterate({\n            range: n\n          }, function (t, e, n) {\n            if (t.length === a) {\n              var r = o.serializer.fromDbRemoteDocument(e);\n              i.path.isPrefixOf(r.key.path) ? r instanceof gr && i.matches(r) && (s = s.insert(r.key, r)) : n.done();\n            }\n          }).next(function () {\n            return s;\n          });\n        }, t.prototype.getNewDocumentChanges = function (e) {\n          var r = this;\n          vn(this.keepDocumentChangeLog, \"Can only call getNewDocumentChanges() when document change log is enabled\");\n          var n = Fi(),\n              i = Mi(),\n              t = IDBKeyRange.lowerBound(this._lastProcessedDocumentChangeId + 1),\n              o = !0,\n              s = fs(e);\n          return s.iterate({\n            range: t\n          }, function (t, e) {\n            if (o && (o = !1, r._lastProcessedDocumentChangeId + 1 !== e.id)) return r.synchronizeLastDocumentChangeId(s).next(function () {\n              return qo.reject(new Sn(En.DATA_LOSS, as));\n            });\n            n = n.unionWith(r.serializer.fromDbResourcePaths(e.changes)), r._lastProcessedDocumentChangeId = e.id;\n          }).next(function () {\n            var t = [];\n            return n.forEach(function (n) {\n              t.push(r.getEntry(e, n).next(function (t) {\n                var e = t || new vr(n, oi.forDeletedDoc());\n                i = i.insert(n, e);\n              }));\n            }), qo.waitFor(t);\n          }).next(function () {\n            return i;\n          });\n        }, t.prototype.removeDocumentChangesThroughChangeId = function (t, e) {\n          var n = IDBKeyRange.upperBound(e);\n          return fs(t).delete(n);\n        }, t.prototype.synchronizeLastDocumentChangeId = function (t) {\n          var r = this;\n          return this._lastProcessedDocumentChangeId = 0, t.iterate({\n            keysOnly: !0,\n            reverse: !0\n          }, function (t, e, n) {\n            r._lastProcessedDocumentChangeId = t, n.done();\n          });\n        }, t.prototype.newChangeBuffer = function () {\n          return new hs(this);\n        }, t.prototype.getSize = function (t) {\n          return this.getMetadata(t).next(function (t) {\n            return t.byteSize;\n          });\n        }, t.prototype.getMetadata = function (t) {\n          return cs(t).get(Ns.key).next(function (t) {\n            return vn(!!t, \"Missing document cache metadata\"), t;\n          });\n        }, t.prototype.setMetadata = function (t, e) {\n          return cs(t).put(Ns.key, e);\n        }, t.prototype.updateSize = function (e, n) {\n          var r = this;\n          return this.getMetadata(e).next(function (t) {\n            return t.byteSize += n, r.setMetadata(e, t);\n          });\n        }, t;\n      }();\n\n      function cs(t) {\n        return Ys.getStore(t, Ns.store);\n      }\n\n      var hs = function (n) {\n        function t(t) {\n          var e = n.call(this) || this;\n          return e.documentCache = t, e;\n        }\n\n        return a(t, n), t.prototype.applyChanges = function (t) {\n          var o = this,\n              e = this.assertChanges(),\n              s = 0,\n              a = [];\n          return e.forEach(function (t, e) {\n            var n = o.documentCache.serializer.toDbRemoteDocument(e),\n                r = o.documentSizes.get(t);\n            vn(void 0 !== r, \"Attempting to change document \" + t.toString() + \" without having read it first\");\n            var i = ds(n);\n            s += i - r, a.push({\n              key: t,\n              doc: n\n            });\n          }), this.documentCache.addEntries(t, a, s);\n        }, t.prototype.getFromCache = function (t, e) {\n          return this.documentCache.getSizedEntry(t, e);\n        }, t.prototype.getAllFromCache = function (t, e) {\n          return this.documentCache.getSizedEntries(t, e);\n        }, t;\n      }(ss);\n\n      function ls(t) {\n        return Ys.getStore(t, Ds.store);\n      }\n\n      function fs(t) {\n        return Ys.getStore(t, Os.store);\n      }\n\n      function ps(t) {\n        return t.path.toArray();\n      }\n\n      function ds(t) {\n        var e;\n        if (t.document) e = t.document;else if (t.unknownDocument) e = t.unknownDocument;else {\n          if (!t.noDocument) throw gn(\"Unknown remote document type\");\n          e = t.noDocument;\n        }\n        return JSON.stringify(e).length;\n      }\n\n      var ms = function () {\n        function t() {\n          this.collectionParentIndex = new ys();\n        }\n\n        return t.prototype.addToCollectionParentIndex = function (t, e) {\n          return this.collectionParentIndex.add(e), qo.resolve();\n        }, t.prototype.getCollectionParents = function (t, e) {\n          return qo.resolve(this.collectionParentIndex.getEntries(e));\n        }, t;\n      }(),\n          ys = function () {\n        function t() {\n          this.index = {};\n        }\n\n        return t.prototype.add = function (t) {\n          vn(t.length % 2 == 1, \"Expected a collection path.\");\n          var e = t.lastSegment(),\n              n = t.popLast(),\n              r = this.index[e] || new ci(fr.comparator),\n              i = !r.has(n);\n          return this.index[e] = r.add(n), i;\n        }, t.prototype.getEntries = function (t) {\n          return (this.index[t] || new ci(fr.comparator)).toArray();\n        }, t;\n      }(),\n          gs = 8,\n          vs = function () {\n        function t(t) {\n          this.serializer = t;\n        }\n\n        return t.prototype.createOrUpgrade = function (t, n, e, r) {\n          var i,\n              o = this;\n          vn(e < r && 0 <= e && r <= gs, \"Unexpected schema upgrade from v\" + e + \" to v{toVersion}.\"), e < 1 && 1 <= r && (t.createObjectStore(ws.store), (i = t).createObjectStore(Es.store, {\n            keyPath: Es.keyPath\n          }), i.createObjectStore(Ss.store, {\n            keyPath: Ss.keyPath,\n            autoIncrement: !0\n          }).createIndex(Ss.userMutationsIndex, Ss.userMutationsKeyPath, {\n            unique: !0\n          }), i.createObjectStore(Ts.store), _s(t), t.createObjectStore(Ds.store));\n          var s,\n              a = qo.resolve();\n          return e < 3 && 3 <= r && (0 !== e && ((s = t).deleteObjectStore(ks.store), s.deleteObjectStore(As.store), s.deleteObjectStore(Rs.store), _s(t)), a = a.next(function () {\n            return t = n.store(Rs.store), e = new Rs(0, 0, oi.MIN.toTimestamp(), 0), t.put(Rs.key, e);\n            var t, e;\n          })), e < 4 && 4 <= r && (0 !== e && (a = a.next(function () {\n            return i = t, (o = n).store(Ss.store).loadAll().next(function (t) {\n              i.deleteObjectStore(Ss.store);\n              var e = i.createObjectStore(Ss.store, {\n                keyPath: Ss.keyPath,\n                autoIncrement: !0\n              });\n              e.createIndex(Ss.userMutationsIndex, Ss.userMutationsKeyPath, {\n                unique: !0\n              });\n              var n = o.store(Ss.store),\n                  r = t.map(function (t) {\n                return n.put(t);\n              });\n              return qo.waitFor(r);\n            });\n            var i, o;\n          })), a = a.next(function () {\n            t.createObjectStore(Ps.store, {\n              keyPath: Ps.keyPath\n            }), t.createObjectStore(Os.store, {\n              keyPath: \"id\",\n              autoIncrement: !0\n            });\n          })), e < 5 && 5 <= r && (a = a.next(function () {\n            return o.removeAcknowledgedMutations(n);\n          })), e < 6 && 6 <= r && (a = a.next(function () {\n            return t.createObjectStore(Ns.store), o.addDocumentGlobal(n);\n          })), e < 7 && 7 <= r && (a = a.next(function () {\n            return o.ensureSequenceNumbers(n);\n          })), e < 8 && 8 <= r && (a = a.next(function () {\n            return o.createCollectionParentIndex(t, n);\n          })), a;\n        }, t.prototype.addDocumentGlobal = function (e) {\n          var n = 0;\n          return e.store(Ds.store).iterate(function (t, e) {\n            n += ds(e);\n          }).next(function () {\n            var t = new Ns(n);\n            return e.store(Ns.store).put(Ns.key, t);\n          });\n        }, t.prototype.removeAcknowledgedMutations = function (r) {\n          var i = this,\n              t = r.store(Es.store),\n              e = r.store(Ss.store);\n          return t.loadAll().next(function (t) {\n            return qo.forEach(t, function (n) {\n              var t = IDBKeyRange.bound([n.userId, -1], [n.userId, n.lastAcknowledgedBatchId]);\n              return e.loadAll(Ss.userMutationsIndex, t).next(function (t) {\n                return qo.forEach(t, function (t) {\n                  vn(t.userId === n.userId, \"Cannot process batch \" + t.batchId + \" from unexpected user\");\n                  var e = i.serializer.fromDbMutationBatch(t);\n                  return Bo(r, n.userId, e).next(function () {});\n                });\n              });\n            });\n          });\n        }, t.prototype.ensureSequenceNumbers = function (t) {\n          var s = t.store(ks.store),\n              e = t.store(Ds.store);\n          return rs(t).next(function (i) {\n            var o = [];\n            return e.iterate(function (t, e) {\n              var n = new fr(t),\n                  r = [0, Mo(n)];\n              o.push(s.get(r).next(function (t) {\n                return t ? qo.resolve() : (e = n, s.put(new ks(0, Mo(e), i)));\n                var e;\n              }));\n            }).next(function () {\n              return qo.waitFor(o);\n            });\n          });\n        }, t.prototype.createCollectionParentIndex = function (t, e) {\n          t.createObjectStore(Ms.store, {\n            keyPath: Ms.keyPath\n          });\n\n          var r = e.store(Ms.store),\n              i = new ys(),\n              o = function o(t) {\n            if (i.add(t)) {\n              var e = t.lastSegment(),\n                  n = t.popLast();\n              return r.put({\n                collectionId: e,\n                parent: Mo(n)\n              });\n            }\n          };\n\n          return e.store(Ds.store).iterate({\n            keysOnly: !0\n          }, function (t, e) {\n            var n = new fr(t);\n            return o(n.popLast());\n          }).next(function () {\n            return e.store(Ts.store).iterate({\n              keysOnly: !0\n            }, function (t, e) {\n              t[0];\n              var n = t[1],\n                  r = (t[2], Po(n));\n              return o(r.popLast());\n            });\n          });\n        }, t;\n      }();\n\n      var bs = function bs(t, e) {\n        this.seconds = t, this.nanoseconds = e;\n      },\n          ws = function () {\n        function t(t, e, n) {\n          this.ownerId = t, this.allowTabSynchronization = e, this.leaseTimestampMs = n;\n        }\n\n        return t.store = \"owner\", t.key = \"owner\", t;\n      }();\n\n      var Es = function () {\n        function t(t, e, n) {\n          this.userId = t, this.lastAcknowledgedBatchId = e, this.lastStreamToken = n;\n        }\n\n        return t.store = \"mutationQueues\", t.keyPath = \"userId\", t;\n      }(),\n          Ss = function () {\n        function t(t, e, n, r, i) {\n          this.userId = t, this.batchId = e, this.localWriteTimeMs = n, this.baseMutations = r, this.mutations = i;\n        }\n\n        return t.store = \"mutations\", t.keyPath = \"batchId\", t.userMutationsIndex = \"userMutationsIndex\", t.userMutationsKeyPath = [\"userId\", \"batchId\"], t;\n      }();\n\n      var Ts = function () {\n        function t() {}\n\n        return t.prefixForUser = function (t) {\n          return [t];\n        }, t.prefixForPath = function (t, e) {\n          return [t, Mo(e)];\n        }, t.key = function (t, e, n) {\n          return [t, Mo(e), n];\n        }, t.store = \"documentMutations\", t.PLACEHOLDER = new t(), t;\n      }();\n\n      var Is = function Is(t, e) {\n        this.path = t, this.readTime = e;\n      },\n          Cs = function Cs(t, e) {\n        this.path = t, this.version = e;\n      },\n          Ds = function () {\n        function t(t, e, n, r) {\n          this.unknownDocument = t, this.noDocument = e, this.document = n, this.hasCommittedMutations = r;\n        }\n\n        return t.store = \"remoteDocuments\", t;\n      }(),\n          Ns = function () {\n        function t(t) {\n          this.byteSize = t;\n        }\n\n        return t.store = \"remoteDocumentGlobal\", t.key = \"remoteDocumentGlobalKey\", t;\n      }();\n\n      var As = function () {\n        function t(t, e, n, r, i, o) {\n          this.targetId = t, this.canonicalId = e, this.readTime = n, this.resumeToken = r, this.lastListenSequenceNumber = i, this.query = o;\n        }\n\n        return t.store = \"targets\", t.keyPath = \"targetId\", t.queryTargetsIndexName = \"queryTargetsIndex\", t.queryTargetsKeyPath = [\"canonicalId\", \"targetId\"], t;\n      }(),\n          ks = function () {\n        function t(t, e, n) {\n          this.targetId = t, this.path = e, vn(0 === t == (void 0 !== (this.sequenceNumber = n)), \"A target-document row must either have targetId == 0 and a defined sequence number, or a non-zero targetId and no sequence number\");\n        }\n\n        return t.store = \"targetDocuments\", t.keyPath = [\"targetId\", \"path\"], t.documentTargetsIndex = \"documentTargetsIndex\", t.documentTargetsKeyPath = [\"path\", \"targetId\"], t;\n      }(),\n          Rs = function () {\n        function t(t, e, n, r) {\n          this.highestTargetId = t, this.highestListenSequenceNumber = e, this.lastRemoteSnapshotVersion = n, this.targetCount = r;\n        }\n\n        return t.key = \"targetGlobalKey\", t.store = \"targetGlobal\", t;\n      }(),\n          Ms = function () {\n        function t(t, e) {\n          this.collectionId = t, this.parent = e;\n        }\n\n        return t.store = \"collectionParents\", t.keyPath = [\"collectionId\", \"parent\"], t;\n      }();\n\n      function _s(t) {\n        t.createObjectStore(ks.store, {\n          keyPath: ks.keyPath\n        }).createIndex(ks.documentTargetsIndex, ks.documentTargetsKeyPath, {\n          unique: !0\n        }), t.createObjectStore(As.store, {\n          keyPath: As.keyPath\n        }).createIndex(As.queryTargetsIndexName, As.queryTargetsKeyPath, {\n          unique: !0\n        }), t.createObjectStore(Rs.store);\n      }\n\n      var Os = function () {\n        function t(t) {\n          this.changes = t;\n        }\n\n        return t.store = \"remoteDocumentChanges\", t.keyPath = \"id\", t;\n      }();\n\n      var Ps = function () {\n        function t(t, e, n, r, i) {\n          this.clientId = t, this.updateTimeMs = e, this.networkEnabled = n, this.inForeground = r, this.lastProcessedDocumentChangeId = i;\n        }\n\n        return t.store = \"clientMetadata\", t.keyPath = \"clientId\", t;\n      }();\n\n      var Ls = [Es.store, Ss.store, Ts.store, Ds.store, As.store, ws.store, Rs.store, ks.store].concat([Ps.store, Os.store]).concat([Ns.store]).concat([Ms.store]),\n          xs = function () {\n        function t() {\n          this.collectionParentsCache = new ys();\n        }\n\n        return t.prototype.addToCollectionParentIndex = function (t, e) {\n          if (vn(e.length % 2 == 1, \"Expected a collection path.\"), this.collectionParentsCache.add(e)) {\n            vn(1 <= e.length, \"Invalid collection path.\");\n            var n = e.lastSegment(),\n                r = e.popLast();\n            return qs(t).put({\n              collectionId: n,\n              parent: Mo(r)\n            });\n          }\n\n          return qo.resolve();\n        }, t.prototype.getCollectionParents = function (t, i) {\n          var o = [],\n              e = IDBKeyRange.bound([i, \"\"], [Xn(i), \"\"], !1, !0);\n          return qs(t).loadAll(e).next(function (t) {\n            for (var e = 0, n = t; e < n.length; e++) {\n              var r = n[e];\n              if (r.collectionId !== i) break;\n              o.push(Po(r.parent));\n            }\n\n            return o;\n          });\n        }, t;\n      }();\n\n      function qs(t) {\n        return Ys.getStore(t, Ms.store);\n      }\n\n      var Fs = function () {\n        function t(t) {\n          this.remoteSerializer = t;\n        }\n\n        return t.prototype.fromDbRemoteDocument = function (t) {\n          if (t.document) return this.remoteSerializer.fromDocument(t.document, !!t.hasCommittedMutations);\n\n          if (t.noDocument) {\n            var e = mr.fromSegments(t.noDocument.path),\n                n = this.fromDbTimestamp(t.noDocument.readTime);\n            return new vr(e, n, {\n              hasCommittedMutations: !!t.hasCommittedMutations\n            });\n          }\n\n          if (t.unknownDocument) {\n            e = mr.fromSegments(t.unknownDocument.path), n = this.fromDbTimestamp(t.unknownDocument.version);\n            return new br(e, n);\n          }\n\n          return gn(\"Unexpected DbRemoteDocument\");\n        }, t.prototype.toDbRemoteDocument = function (t) {\n          if (t instanceof gr) {\n            var e = t.proto ? t.proto : this.remoteSerializer.toDocument(t),\n                n = t.hasCommittedMutations;\n            return new Ds(null, null, e, n);\n          }\n\n          if (t instanceof vr) {\n            var r = t.key.path.toArray(),\n                i = this.toDbTimestamp(t.version);\n            n = t.hasCommittedMutations;\n            return new Ds(null, new Is(r, i), null, n);\n          }\n\n          if (t instanceof br) {\n            r = t.key.path.toArray(), i = this.toDbTimestamp(t.version);\n            return new Ds(new Cs(r, i), null, null, !0);\n          }\n\n          return gn(\"Unexpected MaybeDocumment\");\n        }, t.prototype.toDbTimestamp = function (t) {\n          var e = t.toTimestamp();\n          return new bs(e.seconds, e.nanoseconds);\n        }, t.prototype.fromDbTimestamp = function (t) {\n          var e = new sr(t.seconds, t.nanoseconds);\n          return oi.fromTimestamp(e);\n        }, t.prototype.toDbMutationBatch = function (t, e) {\n          var n = this,\n              r = e.baseMutations.map(function (t) {\n            return n.remoteSerializer.toMutation(t);\n          }),\n              i = e.mutations.map(function (t) {\n            return n.remoteSerializer.toMutation(t);\n          });\n          return new Ss(t, e.batchId, e.localWriteTime.toMillis(), r, i);\n        }, t.prototype.fromDbMutationBatch = function (t) {\n          var e = this,\n              n = (t.baseMutations || []).map(function (t) {\n            return e.remoteSerializer.fromMutation(t);\n          }),\n              r = t.mutations.map(function (t) {\n            return e.remoteSerializer.fromMutation(t);\n          }),\n              i = sr.fromMillis(t.localWriteTimeMs);\n          return new Lo(t.batchId, i, n, r);\n        }, t.prototype.toDbResourcePaths = function (t) {\n          var e = [];\n          return t.forEach(function (t) {\n            e.push(Mo(t.path));\n          }), e;\n        }, t.prototype.fromDbResourcePaths = function (t) {\n          for (var e = Fi(), n = 0, r = t; n < r.length; n++) {\n            var i = r[n];\n            e = e.add(new mr(Po(i)));\n          }\n\n          return e;\n        }, t.prototype.fromDbTarget = function (t) {\n          var e,\n              n = this.fromDbTimestamp(t.readTime);\n          return e = void 0 !== t.query.documents ? this.remoteSerializer.fromDocumentsTarget(t.query) : this.remoteSerializer.fromQueryTarget(t.query), new ui(e, t.targetId, Gr.Listen, t.lastListenSequenceNumber, n, t.resumeToken);\n        }, t.prototype.toDbTarget = function (t) {\n          vn(Gr.Listen === t.purpose, \"Only queries with purpose \" + Gr.Listen + \" may be stored, got \" + t.purpose);\n          var e,\n              n,\n              r = this.toDbTimestamp(t.snapshotVersion);\n          return e = t.query.isDocumentQuery() ? this.remoteSerializer.toDocumentsTarget(t.query) : this.remoteSerializer.toQueryTarget(t.query), n = t.resumeToken instanceof Uint8Array ? (vn(\"YES\" === process.env.USE_MOCK_PERSISTENCE, \"Persisting non-string stream tokens is only supported with mock persistence .\"), t.resumeToken.toString()) : t.resumeToken, new As(t.targetId, t.query.canonicalId(), r, n, t.sequenceNumber, e);\n        }, t;\n      }();\n\n      function Vs(t, e) {\n        var n = t[0],\n            r = t[1],\n            i = e[0],\n            o = e[1],\n            s = Hn(n, i);\n        return 0 === s ? Hn(r, o) : s;\n      }\n\n      var Bs = function () {\n        function t(t) {\n          this.maxElements = t, this.buffer = new ci(Vs), this.previousIndex = 0;\n        }\n\n        return t.prototype.nextIndex = function () {\n          return ++this.previousIndex;\n        }, t.prototype.addElement = function (t) {\n          var e = [t, this.nextIndex()];\n          if (this.buffer.size < this.maxElements) this.buffer = this.buffer.add(e);else {\n            var n = this.buffer.last();\n            Vs(e, n) < 0 && (this.buffer = this.buffer.delete(n).add(e));\n          }\n        }, Object.defineProperty(t.prototype, \"maxValue\", {\n          get: function get() {\n            return this.buffer.last()[0];\n          },\n          enumerable: !0,\n          configurable: !0\n        }), t;\n      }(),\n          Us = {\n        didRun: !1,\n        sequenceNumbersCollected: 0,\n        targetsRemoved: 0,\n        documentsRemoved: 0\n      },\n          Qs = function () {\n        function e(t, e, n) {\n          this.cacheSizeCollectionThreshold = t, this.percentileToCollect = e, this.maximumSequenceNumbersToCollect = n;\n        }\n\n        return e.withCacheSize = function (t) {\n          return new e(t, e.DEFAULT_COLLECTION_PERCENTILE, e.DEFAULT_MAX_SEQUENCE_NUMBERS_TO_COLLECT);\n        }, e.COLLECTION_DISABLED = -1, e.MINIMUM_CACHE_SIZE_BYTES = 1048576, e.DEFAULT = new e(e.DEFAULT_CACHE_SIZE_BYTES = 41943040, e.DEFAULT_COLLECTION_PERCENTILE = 10, e.DEFAULT_MAX_SEQUENCE_NUMBERS_TO_COLLECT = 1e3), e.DISABLED = new e(e.COLLECTION_DISABLED, 0, 0), e;\n      }(),\n          Ks = function () {\n        function t(t, e, n) {\n          this.garbageCollector = t, this.asyncQueue = e, this.localStore = n, this.gcTask = null;\n        }\n\n        return t.prototype.start = function () {\n          vn(null === this.gcTask, \"Cannot start an already started LruScheduler\"), this.garbageCollector.params.cacheSizeCollectionThreshold !== Qs.COLLECTION_DISABLED && this.scheduleGC();\n        }, t.prototype.stop = function () {\n          this.gcTask && (this.gcTask.cancel(), this.gcTask = null);\n        }, Object.defineProperty(t.prototype, \"started\", {\n          get: function get() {\n            return null !== this.gcTask;\n          },\n          enumerable: !0,\n          configurable: !0\n        }), t.prototype.scheduleGC = function () {\n          var t = this;\n          vn(null === this.gcTask, \"Cannot schedule GC while a task is pending\");\n          var e = this.hasRun ? 3e5 : 6e4;\n          dn(\"LruGarbageCollector\", \"Garbage collection scheduled in \" + e + \"ms\"), this.gcTask = this.asyncQueue.enqueueAfterDelay(Eo.LruGarbageCollection, e, function () {\n            return t.gcTask = null, t.hasRun = !0, t.localStore.collectGarbage(t.garbageCollector).then(function () {\n              return t.scheduleGC();\n            }).catch(Xs);\n          });\n        }, t;\n      }(),\n          js = function () {\n        function t(t, e) {\n          this.delegate = t, this.params = e;\n        }\n\n        return t.prototype.calculateTargetCount = function (t, e) {\n          return this.delegate.getSequenceNumberCount(t).next(function (t) {\n            return Math.floor(e / 100 * t);\n          });\n        }, t.prototype.nthSequenceNumber = function (t, e) {\n          var n = this;\n          if (0 === e) return qo.resolve(To.INVALID);\n          var r = new Bs(e);\n          return this.delegate.forEachTarget(t, function (t) {\n            return r.addElement(t.sequenceNumber);\n          }).next(function () {\n            return n.delegate.forEachOrphanedDocumentSequenceNumber(t, function (t) {\n              return r.addElement(t);\n            });\n          }).next(function () {\n            return r.maxValue;\n          });\n        }, t.prototype.removeTargets = function (t, e, n) {\n          return this.delegate.removeTargets(t, e, n);\n        }, t.prototype.removeOrphanedDocuments = function (t, e) {\n          return this.delegate.removeOrphanedDocuments(t, e);\n        }, t.prototype.collect = function (e, n) {\n          var r = this;\n          return this.params.cacheSizeCollectionThreshold === Qs.COLLECTION_DISABLED ? (dn(\"LruGarbageCollector\", \"Garbage collection skipped; disabled\"), qo.resolve(Us)) : this.getCacheSize(e).next(function (t) {\n            return t < r.params.cacheSizeCollectionThreshold ? (dn(\"LruGarbageCollector\", \"Garbage collection skipped; Cache size \" + t + \" is lower than threshold \" + r.params.cacheSizeCollectionThreshold), Us) : r.runGarbageCollection(e, n);\n          });\n        }, t.prototype.getCacheSize = function (t) {\n          return this.delegate.getCacheSize(t);\n        }, t.prototype.runGarbageCollection = function (e, n) {\n          var r,\n              i,\n              o,\n              s,\n              a,\n              u,\n              c,\n              h,\n              l = this;\n          return s = Date.now(), this.calculateTargetCount(e, this.params.percentileToCollect).next(function (t) {\n            return i = t > l.params.maximumSequenceNumbersToCollect ? (dn(\"LruGarbageCollector\", \"Capping sequence numbers to collect down to the maximum of \" + l.params.maximumSequenceNumbersToCollect + \" from \" + t), l.params.maximumSequenceNumbersToCollect) : t, a = Date.now(), l.nthSequenceNumber(e, i);\n          }).next(function (t) {\n            return r = t, u = Date.now(), l.removeTargets(e, r, n);\n          }).next(function (t) {\n            return o = t, c = Date.now(), l.removeOrphanedDocuments(e, r);\n          }).next(function (t) {\n            (h = Date.now(), fn() <= an.DEBUG) && dn(\"LruGarbageCollector\", \"LRU Garbage Collection\\n\\tCounted targets in \" + (a - s) + \"ms\\n\\tDetermined least recently used \" + i + \" in \" + (u - a) + \"ms\\n\\tRemoved \" + o + \" targets in \" + (c - u) + \"ms\\n\\tRemoved \" + t + \" documents in \" + (h - c) + \"ms\\nTotal Duration: \" + (h - s) + \"ms\");\n            return qo.resolve({\n              didRun: !0,\n              sequenceNumbersCollected: i,\n              targetsRemoved: o,\n              documentsRemoved: t\n            });\n          });\n        }, t;\n      }(),\n          Ws = \"IndexedDbPersistence\",\n          Gs = \"The current tab is not in the required state to perform this operation. It might be necessary to refresh the browser tab.\",\n          zs = \"Another tab has exclusive access to the persistence layer. To allow shared access, make sure to invoke `enablePersistence()` with `experimentalTabSynchronization:true` in all tabs.\",\n          Hs = function (r) {\n        function t(t, e) {\n          var n = r.call(this) || this;\n          return n.simpleDbTransaction = t, n.currentSequenceNumber = e, n;\n        }\n\n        return a(t, r), t;\n      }(function () {}),\n          Ys = function () {\n        function c(t, e, n, r, i, o, s) {\n          if (this.persistenceKey = t, this.clientId = e, this.queue = r, this.multiClientParams = s, this._started = !1, this.isPrimary = !1, this.networkEnabled = !0, this.inForeground = !1, this.lastGarbageCollectionTime = Number.NEGATIVE_INFINITY, this.primaryStateListener = function (t) {\n            return Promise.resolve();\n          }, !c.isAvailable()) throw new Sn(En.UNIMPLEMENTED, \"This platform is either missing IndexedDB or is known to have an incomplete implementation. Offline persistence has been disabled.\");\n          if (this.referenceDelegate = new Zs(this, o), this.dbName = t + c.MAIN_DATABASE, this.serializer = new Fs(i), this.document = n.document, this.allowTabSynchronization = void 0 !== s, this.queryCache = new ts(this.referenceDelegate, this.serializer), this.indexManager = new xs(), this.remoteDocumentCache = new us(this.serializer, this.indexManager, this.allowTabSynchronization), !n.window || !n.window.localStorage) throw new Sn(En.UNIMPLEMENTED, \"IndexedDB persistence is only available on platforms that support LocalStorage.\");\n          this.window = n.window, this.webStorage = this.window.localStorage;\n        }\n\n        return c.getStore = function (t, e) {\n          if (t instanceof Hs) return Yo.getStore(t.simpleDbTransaction, e);\n          throw gn(\"IndexedDbPersistence must use instances of IndexedDbTransaction\");\n        }, c.createIndexedDbPersistence = function (n, r, i, o, s, a) {\n          return h(this, void 0, void 0, function () {\n            var e;\n            return p(this, function (t) {\n              switch (t.label) {\n                case 0:\n                  return [4, (e = new c(n, r, i, o, s, a)).start()];\n\n                case 1:\n                  return t.sent(), [2, e];\n              }\n            });\n          });\n        }, c.createMultiClientIndexedDbPersistence = function (n, r, i, o, s, a, u) {\n          return h(this, void 0, void 0, function () {\n            var e;\n            return p(this, function (t) {\n              switch (t.label) {\n                case 0:\n                  return [4, (e = new c(n, r, i, o, s, a, u)).start()];\n\n                case 1:\n                  return t.sent(), [2, e];\n              }\n            });\n          });\n        }, c.prototype.start = function () {\n          var n = this;\n          return vn(!this.started, \"IndexedDbPersistence double-started!\"), vn(null !== this.window, \"Expected 'window' to be defined\"), Yo.openOrCreate(this.dbName, gs, new vs(this.serializer)).then(function (t) {\n            return n.simpleDb = t, n.updateClientMetadataAndTryBecomePrimary();\n          }).then(function () {\n            return n.attachVisibilityHandler(), n.attachWindowUnloadHook(), n.scheduleClientMetadataAndPrimaryLeaseRefreshes(), n.startRemoteDocumentCache();\n          }).then(function () {\n            return n.simpleDb.runTransaction(\"readonly\", [Rs.store], function (t) {\n              return rs(t).next(function (t) {\n                var e = n.multiClientParams ? n.multiClientParams.sequenceNumberSyncer : void 0;\n                n.listenSequence = new To(t, e);\n              });\n            });\n          }).then(function () {\n            n._started = !0;\n          }).catch(function (t) {\n            return n.simpleDb && n.simpleDb.close(), Promise.reject(t);\n          });\n        }, c.prototype.startRemoteDocumentCache = function () {\n          var e = this;\n          return this.simpleDb.runTransaction(\"readonly\", Ls, function (t) {\n            return e.remoteDocumentCache.start(t);\n          });\n        }, c.prototype.setPrimaryStateListener = function (n) {\n          var t = this;\n          return this.primaryStateListener = function (e) {\n            return h(t, void 0, void 0, function () {\n              return p(this, function (t) {\n                return this.started ? [2, n(e)] : [2];\n              });\n            });\n          }, n(this.isPrimary);\n        }, c.prototype.setNetworkEnabled = function (t) {\n          var e = this;\n          this.networkEnabled !== t && (this.networkEnabled = t, this.queue.enqueueAndForget(function () {\n            return h(e, void 0, void 0, function () {\n              return p(this, function (t) {\n                switch (t.label) {\n                  case 0:\n                    return this.started ? [4, this.updateClientMetadataAndTryBecomePrimary()] : [3, 2];\n\n                  case 1:\n                    t.sent(), t.label = 2;\n\n                  case 2:\n                    return [2];\n                }\n              });\n            });\n          }));\n        }, c.prototype.updateClientMetadataAndTryBecomePrimary = function () {\n          var r = this;\n          return this.simpleDb.runTransaction(\"readwrite\", Ls, function (n) {\n            return $s(n).put(new Ps(r.clientId, Date.now(), r.networkEnabled, r.inForeground, r.remoteDocumentCache.lastProcessedDocumentChangeId)).next(function () {\n              if (r.isPrimary) return r.verifyPrimaryLease(n).next(function (t) {\n                t || (r.isPrimary = !1, r.queue.enqueueAndForget(function () {\n                  return r.primaryStateListener(!1);\n                }));\n              });\n            }).next(function () {\n              return r.canActAsPrimary(n);\n            }).next(function (t) {\n              var e = r.isPrimary;\n              return r.isPrimary = t, e !== r.isPrimary && r.queue.enqueueAndForget(function () {\n                return r.primaryStateListener(r.isPrimary);\n              }), e && !r.isPrimary ? r.releasePrimaryLeaseIfHeld(n) : r.isPrimary ? r.acquireOrExtendPrimaryLease(n) : void 0;\n            });\n          });\n        }, c.prototype.verifyPrimaryLease = function (t) {\n          var e = this;\n          return Js(t).get(ws.key).next(function (t) {\n            return qo.resolve(e.isLocalClient(t));\n          });\n        }, c.prototype.removeClientMetadata = function (t) {\n          return $s(t).delete(this.clientId);\n        }, c.prototype.maybeGarbageCollectMultiClientState = function () {\n          return h(this, void 0, void 0, function () {\n            var r,\n                i,\n                o = this;\n            return p(this, function (t) {\n              switch (t.label) {\n                case 0:\n                  return !this.isPrimary || this.isWithinAge(this.lastGarbageCollectionTime, 18e5) ? [3, 2] : (this.lastGarbageCollectionTime = Date.now(), i = [], [4, this.runTransaction(\"maybeGarbageCollectMultiClientState\", \"readwrite-primary\", function (n) {\n                    var e = c.getStore(n, Ps.store);\n                    return e.loadAll().next(function (t) {\n                      r = o.filterActiveClients(t, 18e5), i = t.filter(function (t) {\n                        return -1 === r.indexOf(t);\n                      });\n                    }).next(function () {\n                      return qo.forEach(i, function (t) {\n                        return e.delete(t.clientId);\n                      });\n                    }).next(function () {\n                      if (0 < (r = r.filter(function (t) {\n                        return t.clientId !== o.clientId;\n                      })).length) {\n                        var t = r.map(function (t) {\n                          return t.lastProcessedDocumentChangeId || 0;\n                        }),\n                            e = Math.min.apply(Math, t);\n                        return o.remoteDocumentCache.removeDocumentChangesThroughChangeId(n, e);\n                      }\n                    });\n                  })]);\n\n                case 1:\n                  t.sent(), i.forEach(function (t) {\n                    o.window.localStorage.removeItem(o.zombiedClientLocalStorageKey(t.clientId));\n                  }), t.label = 2;\n\n                case 2:\n                  return [2];\n              }\n            });\n          });\n        }, c.prototype.scheduleClientMetadataAndPrimaryLeaseRefreshes = function () {\n          var t = this;\n          this.clientMetadataRefresher = this.queue.enqueueAfterDelay(Eo.ClientMetadataRefresh, 4e3, function () {\n            return t.updateClientMetadataAndTryBecomePrimary().then(function () {\n              return t.maybeGarbageCollectMultiClientState();\n            }).then(function () {\n              return t.scheduleClientMetadataAndPrimaryLeaseRefreshes();\n            });\n          });\n        }, c.prototype.isLocalClient = function (t) {\n          return !!t && t.ownerId === this.clientId;\n        }, c.prototype.canActAsPrimary = function (e) {\n          var i = this;\n          return Js(e).get(ws.key).next(function (t) {\n            if (null !== t && i.isWithinAge(t.leaseTimestampMs, 5e3) && !i.isClientZombied(t.ownerId)) {\n              if (i.isLocalClient(t) && i.networkEnabled) return !0;\n\n              if (!i.isLocalClient(t)) {\n                if (!t.allowTabSynchronization) throw new Sn(En.FAILED_PRECONDITION, zs);\n                return !1;\n              }\n            }\n\n            return !(!i.networkEnabled || !i.inForeground) || $s(e).loadAll().next(function (t) {\n              return void 0 === i.filterActiveClients(t, 5e3).find(function (t) {\n                if (i.clientId !== t.clientId) {\n                  var e = !i.networkEnabled && t.networkEnabled,\n                      n = !i.inForeground && t.inForeground,\n                      r = i.networkEnabled === t.networkEnabled;\n                  if (e || n && r) return !0;\n                }\n\n                return !1;\n              });\n            });\n          }).next(function (t) {\n            return i.isPrimary !== t && dn(Ws, \"Client \" + (t ? \"is\" : \"is not\") + \" eligible for a primary lease.\"), t;\n          });\n        }, c.prototype.shutdown = function (n) {\n          return h(this, void 0, void 0, function () {\n            var e = this;\n            return p(this, function (t) {\n              switch (t.label) {\n                case 0:\n                  return this._started = !1, this.markClientZombied(), this.clientMetadataRefresher && this.clientMetadataRefresher.cancel(), this.detachVisibilityHandler(), this.detachWindowUnloadHook(), [4, this.simpleDb.runTransaction(\"readwrite\", [ws.store, Ps.store], function (t) {\n                    return e.releasePrimaryLeaseIfHeld(t).next(function () {\n                      return e.removeClientMetadata(t);\n                    });\n                  })];\n\n                case 1:\n                  return t.sent(), this.simpleDb.close(), this.removeClientZombiedEntry(), n ? [4, Yo.delete(this.dbName)] : [3, 3];\n\n                case 2:\n                  t.sent(), t.label = 3;\n\n                case 3:\n                  return [2];\n              }\n            });\n          });\n        }, c.prototype.filterActiveClients = function (t, e) {\n          var n = this;\n          return t.filter(function (t) {\n            return n.isWithinAge(t.updateTimeMs, e) && !n.isClientZombied(t.clientId);\n          });\n        }, c.prototype.getActiveClients = function () {\n          var e = this;\n          return this.simpleDb.runTransaction(\"readonly\", [Ps.store], function (t) {\n            return $s(t).loadAll().next(function (t) {\n              return e.filterActiveClients(t, 18e5).map(function (t) {\n                return t.clientId;\n              });\n            });\n          });\n        }, Object.defineProperty(c.prototype, \"started\", {\n          get: function get() {\n            return this._started;\n          },\n          enumerable: !0,\n          configurable: !0\n        }), c.prototype.getMutationQueue = function (t) {\n          return vn(this.started, \"Cannot initialize MutationQueue before persistence is started.\"), Fo.forUser(t, this.serializer, this.indexManager, this.referenceDelegate);\n        }, c.prototype.getQueryCache = function () {\n          return vn(this.started, \"Cannot initialize QueryCache before persistence is started.\"), this.queryCache;\n        }, c.prototype.getRemoteDocumentCache = function () {\n          return vn(this.started, \"Cannot initialize RemoteDocumentCache before persistence is started.\"), this.remoteDocumentCache;\n        }, c.prototype.getIndexManager = function () {\n          return vn(this.started, \"Cannot initialize IndexManager before persistence is started.\"), this.indexManager;\n        }, c.prototype.runTransaction = function (n, t, r) {\n          var i = this;\n          return dn(Ws, \"Starting transaction:\", n), this.simpleDb.runTransaction(\"readonly\" === t ? \"readonly\" : \"readwrite\", Ls, function (e) {\n            return \"readwrite-primary\" === t ? i.verifyPrimaryLease(e).next(function (t) {\n              if (!t) throw mn(\"Failed to obtain primary lease for action '\" + n + \"'.\"), i.isPrimary = !1, i.queue.enqueueAndForget(function () {\n                return i.primaryStateListener(!1);\n              }), new Sn(En.FAILED_PRECONDITION, Gs);\n              return r(new Hs(e, i.listenSequence.next()));\n            }).next(function (t) {\n              return i.acquireOrExtendPrimaryLease(e).next(function () {\n                return t;\n              });\n            }) : i.verifyAllowTabSynchronization(e).next(function () {\n              return r(new Hs(e, i.listenSequence.next()));\n            });\n          });\n        }, c.prototype.verifyAllowTabSynchronization = function (t) {\n          var e = this;\n          return Js(t).get(ws.key).next(function (t) {\n            if (null !== t && e.isWithinAge(t.leaseTimestampMs, 5e3) && !e.isClientZombied(t.ownerId) && !e.isLocalClient(t) && !t.allowTabSynchronization) throw new Sn(En.FAILED_PRECONDITION, zs);\n          });\n        }, c.prototype.acquireOrExtendPrimaryLease = function (t) {\n          var e = new ws(this.clientId, this.allowTabSynchronization, Date.now());\n          return Js(t).put(ws.key, e);\n        }, c.isAvailable = function () {\n          return Yo.isAvailable();\n        }, c.buildStoragePrefix = function (t) {\n          var e = t.databaseId.projectId;\n          return t.databaseId.isDefaultDatabase || (e += \".\" + t.databaseId.database), \"firestore/\" + t.persistenceKey + \"/\" + e + \"/\";\n        }, c.prototype.releasePrimaryLeaseIfHeld = function (t) {\n          var e = this,\n              n = Js(t);\n          return n.get(ws.key).next(function (t) {\n            return e.isLocalClient(t) ? (dn(Ws, \"Releasing primary lease.\"), n.delete(ws.key)) : qo.resolve();\n          });\n        }, c.prototype.isWithinAge = function (t, e) {\n          var n = Date.now();\n          return !(t < n - e) && (!(n < t) || (mn(\"Detected an update time that is in the future: \" + t + \" > \" + n), !1));\n        }, c.prototype.attachVisibilityHandler = function () {\n          var t = this;\n          null !== this.document && \"function\" == typeof this.document.addEventListener && (this.documentVisibilityHandler = function () {\n            t.queue.enqueueAndForget(function () {\n              return t.inForeground = \"visible\" === t.document.visibilityState, t.updateClientMetadataAndTryBecomePrimary();\n            });\n          }, this.document.addEventListener(\"visibilitychange\", this.documentVisibilityHandler), this.inForeground = \"visible\" === this.document.visibilityState);\n        }, c.prototype.detachVisibilityHandler = function () {\n          this.documentVisibilityHandler && (vn(null !== this.document && \"function\" == typeof this.document.addEventListener, \"Expected 'document.addEventListener' to be a function\"), this.document.removeEventListener(\"visibilitychange\", this.documentVisibilityHandler), this.documentVisibilityHandler = null);\n        }, c.prototype.attachWindowUnloadHook = function () {\n          var t = this;\n          \"function\" == typeof this.window.addEventListener && (this.windowUnloadHandler = function () {\n            t.markClientZombied(), t.queue.enqueueAndForget(function () {\n              return t.shutdown();\n            });\n          }, this.window.addEventListener(\"unload\", this.windowUnloadHandler));\n        }, c.prototype.detachWindowUnloadHook = function () {\n          this.windowUnloadHandler && (vn(\"function\" == typeof this.window.removeEventListener, \"Expected 'window.removeEventListener' to be a function\"), this.window.removeEventListener(\"unload\", this.windowUnloadHandler), this.windowUnloadHandler = null);\n        }, c.prototype.isClientZombied = function (t) {\n          try {\n            var e = null !== this.webStorage.getItem(this.zombiedClientLocalStorageKey(t));\n            return dn(Ws, \"Client '\" + t + \"' \" + (e ? \"is\" : \"is not\") + \" zombied in LocalStorage\"), e;\n          } catch (t) {\n            return mn(Ws, \"Failed to get zombied client id.\", t), !1;\n          }\n        }, c.prototype.markClientZombied = function () {\n          try {\n            this.webStorage.setItem(this.zombiedClientLocalStorageKey(this.clientId), String(Date.now()));\n          } catch (t) {\n            mn(\"Failed to set zombie client id.\", t);\n          }\n        }, c.prototype.removeClientZombiedEntry = function () {\n          try {\n            this.webStorage.removeItem(this.zombiedClientLocalStorageKey(this.clientId));\n          } catch (t) {}\n        }, c.prototype.zombiedClientLocalStorageKey = function (t) {\n          return \"firestore_zombie_\" + this.persistenceKey + \"_\" + t;\n        }, c.MAIN_DATABASE = \"main\", c;\n      }();\n\n      function Xs(n) {\n        return h(this, void 0, void 0, function () {\n          return p(this, function (t) {\n            if ((e = n).code !== En.FAILED_PRECONDITION || e.message !== Gs) throw n;\n            var e;\n            return dn(Ws, \"Unexpectedly lost primary lease\"), [2];\n          });\n        });\n      }\n\n      function Js(t) {\n        return t.store(ws.store);\n      }\n\n      function $s(t) {\n        return t.store(Ps.store);\n      }\n\n      var Zs = function () {\n        function t(t, e) {\n          this.db = t, this.garbageCollector = new js(this, e);\n        }\n\n        return t.prototype.getSequenceNumberCount = function (t) {\n          var n = this.orphanedDocmentCount(t);\n          return this.db.getQueryCache().getQueryCount(t).next(function (e) {\n            return n.next(function (t) {\n              return e + t;\n            });\n          });\n        }, t.prototype.orphanedDocmentCount = function (t) {\n          var e = 0;\n          return this.forEachOrphanedDocumentSequenceNumber(t, function (t) {\n            e++;\n          }).next(function () {\n            return e;\n          });\n        }, t.prototype.forEachTarget = function (t, e) {\n          return this.db.getQueryCache().forEachTarget(t, e);\n        }, t.prototype.forEachOrphanedDocumentSequenceNumber = function (t, n) {\n          return this.forEachOrphanedDocument(t, function (t, e) {\n            return n(e);\n          });\n        }, t.prototype.setInMemoryPins = function (t) {\n          this.inMemoryPins = t;\n        }, t.prototype.addReference = function (t, e) {\n          return ta(t, e);\n        }, t.prototype.removeReference = function (t, e) {\n          return ta(t, e);\n        }, t.prototype.removeTargets = function (t, e, n) {\n          return this.db.getQueryCache().removeTargets(t, e, n);\n        }, t.prototype.removeMutationReference = function (t, e) {\n          return ta(t, e);\n        }, t.prototype.isPinned = function (t, e) {\n          return this.inMemoryPins.containsKey(e) ? qo.resolve(!0) : (r = e, i = !1, jo(n = t).iterateSerial(function (t) {\n            return Vo(n, t, r).next(function (t) {\n              return t && (i = !0), qo.resolve(!t);\n            });\n          }).next(function () {\n            return i;\n          }));\n          var n, r, i;\n        }, t.prototype.removeOrphanedDocuments = function (r, i) {\n          var o = this,\n              s = 0,\n              a = 0,\n              u = [];\n          return this.forEachOrphanedDocument(r, function (e, t) {\n            if (t <= i) {\n              var n = o.isPinned(r, e).next(function (t) {\n                if (!t) return s++, o.removeOrphanedDocument(r, e).next(function (t) {\n                  a += t;\n                });\n              });\n              u.push(n);\n            }\n          }).next(function () {\n            return qo.waitFor(u);\n          }).next(function () {\n            return o.db.getRemoteDocumentCache().updateSize(r, -a);\n          }).next(function () {\n            return s;\n          });\n        }, t.prototype.removeOrphanedDocument = function (t, e) {\n          var n,\n              r = 0,\n              i = this.db.getRemoteDocumentCache();\n          return qo.waitFor([is(t).delete((n = e, [0, Mo(n.path)])), i.removeEntry(t, e).next(function (t) {\n            r += t;\n          })]).next(function () {\n            return r;\n          });\n        }, t.prototype.removeTarget = function (t, e) {\n          var n = e.copy({\n            sequenceNumber: t.currentSequenceNumber\n          });\n          return this.db.getQueryCache().updateQueryData(t, n);\n        }, t.prototype.updateLimboDocument = function (t, e) {\n          return ta(t, e);\n        }, t.prototype.forEachOrphanedDocument = function (t, o) {\n          var s,\n              e = is(t),\n              a = To.INVALID;\n          return e.iterate({\n            index: ks.documentTargetsIndex\n          }, function (t, e) {\n            var n = t[0],\n                r = (t[1], e.path),\n                i = e.sequenceNumber;\n            0 === n ? (a !== To.INVALID && o(new mr(Po(s)), a), a = i, s = r) : a = To.INVALID;\n          }).next(function () {\n            a !== To.INVALID && o(new mr(Po(s)), a);\n          });\n        }, t.prototype.getCacheSize = function (t) {\n          return this.db.getRemoteDocumentCache().getSize(t);\n        }, t;\n      }();\n\n      function ta(t, e) {\n        return is(t).put((n = e, r = t.currentSequenceNumber, new ks(0, Mo(n.path), r)));\n        var n, r;\n      }\n\n      var ea = function () {\n        function t(t, e, n) {\n          this.remoteDocumentCache = t, this.mutationQueue = e, this.indexManager = n;\n        }\n\n        return t.prototype.getDocument = function (e, n) {\n          var r = this;\n          return this.mutationQueue.getAllMutationBatchesAffectingDocumentKey(e, n).next(function (t) {\n            return r.getDocumentInternal(e, n, t);\n          });\n        }, t.prototype.getDocumentInternal = function (t, r, i) {\n          return this.remoteDocumentCache.getEntry(t, r).next(function (t) {\n            for (var e = 0, n = i; e < n.length; e++) {\n              t = n[e].applyToLocalView(r, t);\n            }\n\n            return t;\n          });\n        }, t.prototype.applyLocalMutationsToDocuments = function (t, e, i) {\n          var o = _i();\n\n          return e.forEach(function (t, e) {\n            for (var n = 0, r = i; n < r.length; n++) {\n              e = r[n].applyToLocalView(t, e);\n            }\n\n            o = o.insert(t, e);\n          }), o;\n        }, t.prototype.getDocuments = function (e, t) {\n          var n = this;\n          return this.remoteDocumentCache.getEntries(e, t).next(function (t) {\n            return n.getLocalViewOfDocuments(e, t);\n          });\n        }, t.prototype.getLocalViewOfDocuments = function (r, i) {\n          var o = this;\n          return this.mutationQueue.getAllMutationBatchesAffectingDocumentKeys(r, i).next(function (t) {\n            var e = o.applyLocalMutationsToDocuments(r, i, t),\n                n = Mi();\n            return e.forEach(function (t, e) {\n              e || (e = new vr(t, oi.forDeletedDoc())), n = n.insert(t, e);\n            }), n;\n          });\n        }, t.prototype.getDocumentsMatchingQuery = function (t, e) {\n          return e.isDocumentQuery() ? this.getDocumentsMatchingDocumentQuery(t, e.path) : e.isCollectionGroupQuery() ? this.getDocumentsMatchingCollectionGroupQuery(t, e) : this.getDocumentsMatchingCollectionQuery(t, e);\n        }, t.prototype.getDocumentsMatchingDocumentQuery = function (t, e) {\n          return this.getDocument(t, new mr(e)).next(function (t) {\n            var e = Pi();\n            return t instanceof gr && (e = e.insert(t.key, t)), e;\n          });\n        }, t.prototype.getDocumentsMatchingCollectionGroupQuery = function (n, r) {\n          var i = this;\n          vn(r.path.isEmpty(), \"Currently we only support collection group queries at the root.\");\n          var o = r.collectionGroup,\n              s = Pi();\n          return this.indexManager.getCollectionParents(n, o).next(function (t) {\n            return qo.forEach(t, function (t) {\n              var e = r.asCollectionQueryAtPath(t.child(o));\n              return i.getDocumentsMatchingCollectionQuery(n, e).next(function (t) {\n                t.forEach(function (t, e) {\n                  s = s.insert(t, e);\n                });\n              });\n            }).next(function () {\n              return s;\n            });\n          });\n        }, t.prototype.getDocumentsMatchingCollectionQuery = function (e, h) {\n          var l,\n              n = this;\n          return this.remoteDocumentCache.getDocumentsMatchingQuery(e, h).next(function (t) {\n            return l = t, n.mutationQueue.getAllMutationBatchesAffectingQuery(e, h);\n          }).next(function (t) {\n            for (var e = 0, n = t; e < n.length; e++) {\n              for (var r = n[e], i = 0, o = r.mutations; i < o.length; i++) {\n                var s = o[i],\n                    a = s.key;\n\n                if (h.path.isImmediateParentOf(a.path)) {\n                  var u = l.get(a),\n                      c = s.applyToLocalView(u, u, r.localWriteTime);\n                  l = c instanceof gr ? l.insert(a, c) : l.remove(a);\n                }\n              }\n            }\n          }).next(function () {\n            return l.forEach(function (t, e) {\n              h.matches(e) || (l = l.remove(t));\n            }), l;\n          });\n        }, t;\n      }(),\n          na = function () {\n        function t() {\n          this.refsByKey = new ci(ra.compareByKey), this.refsByTarget = new ci(ra.compareByTargetId);\n        }\n\n        return t.prototype.isEmpty = function () {\n          return this.refsByKey.isEmpty();\n        }, t.prototype.addReference = function (t, e) {\n          var n = new ra(t, e);\n          this.refsByKey = this.refsByKey.add(n), this.refsByTarget = this.refsByTarget.add(n);\n        }, t.prototype.addReferences = function (t, e) {\n          var n = this;\n          t.forEach(function (t) {\n            return n.addReference(t, e);\n          });\n        }, t.prototype.removeReference = function (t, e) {\n          this.removeRef(new ra(t, e));\n        }, t.prototype.removeReferences = function (t, e) {\n          var n = this;\n          t.forEach(function (t) {\n            return n.removeReference(t, e);\n          });\n        }, t.prototype.removeReferencesForId = function (t) {\n          var e = this,\n              n = mr.EMPTY,\n              r = new ra(n, t),\n              i = new ra(n, t + 1),\n              o = [];\n          return this.refsByTarget.forEachInRange([r, i], function (t) {\n            e.removeRef(t), o.push(t.key);\n          }), o;\n        }, t.prototype.removeAllReferences = function () {\n          var e = this;\n          this.refsByKey.forEach(function (t) {\n            return e.removeRef(t);\n          });\n        }, t.prototype.removeRef = function (t) {\n          this.refsByKey = this.refsByKey.delete(t), this.refsByTarget = this.refsByTarget.delete(t);\n        }, t.prototype.referencesForId = function (t) {\n          var e = mr.EMPTY,\n              n = new ra(e, t),\n              r = new ra(e, t + 1),\n              i = Fi();\n          return this.refsByTarget.forEachInRange([n, r], function (t) {\n            i = i.add(t.key);\n          }), i;\n        }, t.prototype.containsKey = function (t) {\n          var e = new ra(t, 0),\n              n = this.refsByKey.firstAfterOrEqual(e);\n          return null !== n && t.isEqual(n.key);\n        }, t;\n      }(),\n          ra = function () {\n        function t(t, e) {\n          this.key = t, this.targetOrBatchId = e;\n        }\n\n        return t.compareByKey = function (t, e) {\n          return mr.comparator(t.key, e.key) || Hn(t.targetOrBatchId, e.targetOrBatchId);\n        }, t.compareByTargetId = function (t, e) {\n          return Hn(t.targetOrBatchId, e.targetOrBatchId) || mr.comparator(t.key, e.key);\n        }, t;\n      }(),\n          ia = function () {\n        function l(t, e) {\n          this.persistence = t, this.localViewReferences = new na(), this.queryDataByTarget = {}, vn(t.started, \"LocalStore was passed an unstarted persistence implementation\"), this.persistence.referenceDelegate.setInMemoryPins(this.localViewReferences), this.mutationQueue = t.getMutationQueue(e), this.remoteDocuments = t.getRemoteDocumentCache(), this.queryCache = t.getQueryCache(), this.localDocuments = new ea(this.remoteDocuments, this.mutationQueue, this.persistence.getIndexManager());\n        }\n\n        return l.prototype.handleUserChange = function (e) {\n          var y = this;\n          return this.persistence.runTransaction(\"Handle user change\", \"readonly\", function (d) {\n            var m;\n            return y.mutationQueue.getAllMutationBatches(d).next(function (t) {\n              return m = t, y.mutationQueue = y.persistence.getMutationQueue(e), y.localDocuments = new ea(y.remoteDocuments, y.mutationQueue, y.persistence.getIndexManager()), y.mutationQueue.getAllMutationBatches(d);\n            }).next(function (t) {\n              for (var e = [], n = [], r = Fi(), i = 0, o = m; i < o.length; i++) {\n                var s = o[i];\n                e.push(s.batchId);\n\n                for (var a = 0, u = s.mutations; a < u.length; a++) {\n                  var c = u[a];\n                  r = r.add(c.key);\n                }\n              }\n\n              for (var h = 0, l = t; h < l.length; h++) {\n                s = l[h];\n                n.push(s.batchId);\n\n                for (var f = 0, p = s.mutations; f < p.length; f++) {\n                  c = p[f];\n                  r = r.add(c.key);\n                }\n              }\n\n              return y.localDocuments.getDocuments(d, r).next(function (t) {\n                return {\n                  affectedDocuments: t,\n                  removedBatchIds: e,\n                  addedBatchIds: n\n                };\n              });\n            });\n          });\n        }, l.prototype.localWrite = function (c) {\n          var h = this,\n              l = sr.now(),\n              t = c.reduce(function (t, e) {\n            return t.add(e.key);\n          }, Fi());\n          return this.persistence.runTransaction(\"Locally write mutations\", \"readwrite\", function (u) {\n            return h.localDocuments.getDocuments(u, t).next(function (n) {\n              for (var t = [], e = 0, r = c; e < r.length; e++) {\n                var i = r[e],\n                    o = n.get(i.key);\n\n                if (!i.isIdempotent) {\n                  var s = i.fieldMask;\n\n                  if (s) {\n                    var a = o instanceof gr ? s.applyTo(o.data) : Fr.EMPTY;\n                    t.push(new gi(i.key, a, s, di.exists(!0)));\n                  }\n                }\n              }\n\n              return h.mutationQueue.addMutationBatch(u, l, t, c).next(function (t) {\n                var e = t.applyToLocalDocumentSet(n);\n                return {\n                  batchId: t.batchId,\n                  changes: e\n                };\n              });\n            });\n          });\n        }, l.prototype.lookupMutationDocuments = function (t) {\n          var n = this;\n          return this.persistence.runTransaction(\"Lookup mutation documents\", \"readonly\", function (e) {\n            return n.mutationQueue.lookupMutationKeys(e, t).next(function (t) {\n              return t ? n.localDocuments.getDocuments(e, t) : qo.resolve(null);\n            });\n          });\n        }, l.prototype.acknowledgeBatch = function (r) {\n          var i = this;\n          return this.persistence.runTransaction(\"Acknowledge batch\", \"readwrite-primary\", function (t) {\n            var e = r.batch.keys(),\n                n = i.remoteDocuments.newChangeBuffer();\n            return i.mutationQueue.acknowledgeBatch(t, r.batch, r.streamToken).next(function () {\n              return i.applyWriteToRemoteDocuments(t, r, n);\n            }).next(function () {\n              return n.apply(t);\n            }).next(function () {\n              return i.mutationQueue.performConsistencyCheck(t);\n            }).next(function () {\n              return i.localDocuments.getDocuments(t, e);\n            });\n          });\n        }, l.prototype.rejectBatch = function (t) {\n          var r = this;\n          return this.persistence.runTransaction(\"Reject batch\", \"readwrite-primary\", function (e) {\n            var n;\n            return r.mutationQueue.lookupMutationBatch(e, t).next(function (t) {\n              return vn(null !== t, \"Attempt to reject nonexistent batch!\"), n = t.keys(), r.mutationQueue.removeMutationBatch(e, t);\n            }).next(function () {\n              return r.mutationQueue.performConsistencyCheck(e);\n            }).next(function () {\n              return r.localDocuments.getDocuments(e, n);\n            });\n          });\n        }, l.prototype.getLastStreamToken = function () {\n          var e = this;\n          return this.persistence.runTransaction(\"Get last stream token\", \"readonly\", function (t) {\n            return e.mutationQueue.getLastStreamToken(t);\n          });\n        }, l.prototype.setLastStreamToken = function (e) {\n          var n = this;\n          return this.persistence.runTransaction(\"Set last stream token\", \"readwrite-primary\", function (t) {\n            return n.mutationQueue.setLastStreamToken(t, e);\n          });\n        }, l.prototype.getLastRemoteSnapshotVersion = function () {\n          var e = this;\n          return this.persistence.runTransaction(\"Get last remote snapshot version\", \"readonly\", function (t) {\n            return e.queryCache.getLastRemoteSnapshotVersion(t);\n          });\n        }, l.prototype.applyRemoteEvent = function (u) {\n          var c = this,\n              h = this.remoteDocuments.newChangeBuffer();\n          return this.persistence.runTransaction(\"Apply remote event\", \"readwrite-primary\", function (o) {\n            var s = [],\n                a = Fi();\n            Dn(u.targetChanges, function (t, e) {\n              var n = c.queryDataByTarget[t];\n\n              if (n) {\n                e.addedDocuments.forEach(function (t) {\n                  a = a.add(t);\n                }), e.modifiedDocuments.forEach(function (t) {\n                  a = a.add(t);\n                }), s.push(c.queryCache.removeMatchingKeys(o, e.removedDocuments, t).next(function () {\n                  return c.queryCache.addMatchingKeys(o, e.addedDocuments, t);\n                }));\n                var r = e.resumeToken;\n\n                if (0 < r.length) {\n                  var i = n;\n                  n = n.copy({\n                    resumeToken: r,\n                    snapshotVersion: u.snapshotVersion\n                  }), c.queryDataByTarget[t] = n, l.shouldPersistQueryData(i, n, e) && s.push(c.queryCache.updateQueryData(o, n));\n                }\n              }\n            });\n            var i = Mi(),\n                n = Fi();\n            u.documentUpdates.forEach(function (t, e) {\n              n = n.add(t);\n            }), s.push(h.getEntries(o, n).next(function (r) {\n              u.documentUpdates.forEach(function (t, e) {\n                var n = r.get(t);\n                null == n || e.version.isEqual(oi.MIN) || a.has(e.key) && !n.hasPendingWrites || 0 <= e.version.compareTo(n.version) ? (h.addEntry(e), i = i.insert(t, e)) : dn(\"LocalStore\", \"Ignoring outdated watch update for \", t, \". Current version:\", n.version, \" Watch version:\", e.version), u.resolvedLimboDocuments.has(t) && s.push(c.persistence.referenceDelegate.updateLimboDocument(o, t));\n              });\n            }));\n            var e = u.snapshotVersion;\n\n            if (!e.isEqual(oi.MIN)) {\n              var t = c.queryCache.getLastRemoteSnapshotVersion(o).next(function (t) {\n                return vn(0 <= e.compareTo(t), \"Watch stream reverted to previous snapshot?? \" + e + \" < \" + t), c.queryCache.setTargetsMetadata(o, o.currentSequenceNumber, e);\n              });\n              s.push(t);\n            }\n\n            return qo.waitFor(s).next(function () {\n              return h.apply(o);\n            }).next(function () {\n              return c.localDocuments.getLocalViewOfDocuments(o, i);\n            });\n          });\n        }, l.shouldPersistQueryData = function (t, e, n) {\n          return 0 !== e.resumeToken.length && (0 === t.resumeToken.length || e.snapshotVersion.toMicroseconds() - t.snapshotVersion.toMicroseconds() >= this.RESUME_TOKEN_MAX_AGE_MICROS || 0 < n.addedDocuments.size + n.modifiedDocuments.size + n.removedDocuments.size);\n        }, l.prototype.notifyLocalViewChanges = function (t) {\n          var n = this;\n          return this.persistence.runTransaction(\"notifyLocalViewChanges\", \"readwrite\", function (e) {\n            return qo.forEach(t, function (t) {\n              return n.localViewReferences.addReferences(t.addedKeys, t.targetId), n.localViewReferences.removeReferences(t.removedKeys, t.targetId), qo.forEach(t.removedKeys, function (t) {\n                return n.persistence.referenceDelegate.removeReference(e, t);\n              });\n            });\n          });\n        }, l.prototype.nextMutationBatch = function (e) {\n          var n = this;\n          return this.persistence.runTransaction(\"Get next mutation batch\", \"readonly\", function (t) {\n            return void 0 === e && (e = -1), n.mutationQueue.getNextMutationBatchAfterBatchId(t, e);\n          });\n        }, l.prototype.readDocument = function (e) {\n          var n = this;\n          return this.persistence.runTransaction(\"read document\", \"readonly\", function (t) {\n            return n.localDocuments.getDocument(t, e);\n          });\n        }, l.prototype.allocateQuery = function (r) {\n          var i = this;\n          return this.persistence.runTransaction(\"Allocate query\", \"readwrite\", function (e) {\n            var n;\n            return i.queryCache.getQueryData(e, r).next(function (t) {\n              return t ? (n = t, qo.resolve()) : i.queryCache.allocateTargetId(e).next(function (t) {\n                return n = new ui(r, t, Gr.Listen, e.currentSequenceNumber), i.queryCache.addQueryData(e, n);\n              });\n            }).next(function () {\n              return vn(!i.queryDataByTarget[n.targetId], \"Tried to allocate an already allocated query: \" + r), i.queryDataByTarget[n.targetId] = n;\n            });\n          });\n        }, l.prototype.releaseQuery = function (o, s) {\n          var a = this,\n              t = s ? \"readwrite\" : \"readwrite-primary\";\n          return this.persistence.runTransaction(\"Release query\", t, function (i) {\n            return a.queryCache.getQueryData(i, o).next(function (t) {\n              vn(null != t, \"Tried to release nonexistent query: \" + o);\n              var e = t.targetId,\n                  n = a.queryDataByTarget[e],\n                  r = a.localViewReferences.removeReferencesForId(e);\n              return delete a.queryDataByTarget[e], s ? qo.resolve() : qo.forEach(r, function (t) {\n                return a.persistence.referenceDelegate.removeReference(i, t);\n              }).next(function () {\n                return a.persistence.referenceDelegate.removeTarget(i, n);\n              });\n            });\n          });\n        }, l.prototype.executeQuery = function (e) {\n          var n = this;\n          return this.persistence.runTransaction(\"Execute query\", \"readonly\", function (t) {\n            return n.localDocuments.getDocumentsMatchingQuery(t, e);\n          });\n        }, l.prototype.remoteDocumentKeys = function (e) {\n          var n = this;\n          return this.persistence.runTransaction(\"Remote document keys\", \"readonly\", function (t) {\n            return n.queryCache.getMatchingKeysForTargetId(t, e);\n          });\n        }, l.prototype.getActiveClients = function () {\n          return this.persistence.getActiveClients();\n        }, l.prototype.removeCachedMutationBatchMetadata = function (t) {\n          this.mutationQueue.removeCachedMutationKeys(t);\n        }, l.prototype.setNetworkEnabled = function (t) {\n          this.persistence.setNetworkEnabled(t);\n        }, l.prototype.applyWriteToRemoteDocuments = function (t, i, o) {\n          var e = this,\n              s = i.batch,\n              n = s.keys(),\n              a = qo.resolve();\n          return n.forEach(function (r) {\n            a = a.next(function () {\n              return o.getEntry(t, r);\n            }).next(function (t) {\n              var e = t,\n                  n = i.docVersions.get(r);\n              vn(null !== n, \"ackVersions should contain every doc in the write.\"), (!e || e.version.compareTo(n) < 0) && ((e = s.applyToRemoteDocument(r, e, i)) ? o.addEntry(e) : vn(!t, \"Mutation batch \" + s + \" applied to document \" + t + \" resulted in null\"));\n            });\n          }), a.next(function () {\n            return e.mutationQueue.removeMutationBatch(t, s);\n          });\n        }, l.prototype.collectGarbage = function (e) {\n          var n = this;\n          return this.persistence.runTransaction(\"Collect garbage\", \"readwrite-primary\", function (t) {\n            return e.collect(t, n.queryDataByTarget);\n          });\n        }, l.prototype.getQueryForTarget = function (e) {\n          var n = this;\n          return this.queryDataByTarget[e] ? Promise.resolve(this.queryDataByTarget[e].query) : this.persistence.runTransaction(\"Get query data\", \"readonly\", function (t) {\n            return n.queryCache.getQueryDataForTarget(t, e).next(function (t) {\n              return t ? t.query : null;\n            });\n          });\n        }, l.prototype.getNewDocumentChanges = function () {\n          var e = this;\n          return this.persistence.runTransaction(\"Get new document changes\", \"readonly\", function (t) {\n            return e.remoteDocuments.getNewDocumentChanges(t);\n          });\n        }, l.RESUME_TOKEN_MAX_AGE_MICROS = 3e8, l;\n      }(),\n          oa = function () {\n        function t(t, e) {\n          this.indexManager = t, this.referenceDelegate = e, this.mutationQueue = [], this.nextBatchId = 1, this.lastStreamToken = wn(), this.batchesByDocumentKey = new ci(ra.compareByKey);\n        }\n\n        return t.prototype.checkEmpty = function (t) {\n          return qo.resolve(0 === this.mutationQueue.length);\n        }, t.prototype.acknowledgeBatch = function (t, e, n) {\n          var r = e.batchId,\n              i = this.indexOfExistingBatchId(r, \"acknowledged\");\n          vn(0 === i, \"Can only acknowledge the first batch in the mutation queue\");\n          var o = this.mutationQueue[i];\n          return vn(r === o.batchId, \"Queue ordering failure: expected batch \" + r + \", got batch \" + o.batchId), this.lastStreamToken = n, qo.resolve();\n        }, t.prototype.getLastStreamToken = function (t) {\n          return qo.resolve(this.lastStreamToken);\n        }, t.prototype.setLastStreamToken = function (t, e) {\n          return this.lastStreamToken = e, qo.resolve();\n        }, t.prototype.addMutationBatch = function (t, e, n, r) {\n          vn(0 !== r.length, \"Mutation batches should not be empty\");\n          var i = this.nextBatchId;\n          (this.nextBatchId++, 0 < this.mutationQueue.length) && vn(this.mutationQueue[this.mutationQueue.length - 1].batchId < i, \"Mutation batchIDs must be monotonically increasing order\");\n          var o = new Lo(i, e, n, r);\n          this.mutationQueue.push(o);\n\n          for (var s = 0, a = r; s < a.length; s++) {\n            var u = a[s];\n            this.batchesByDocumentKey = this.batchesByDocumentKey.add(new ra(u.key, i)), this.indexManager.addToCollectionParentIndex(t, u.key.path.popLast());\n          }\n\n          return qo.resolve(o);\n        }, t.prototype.lookupMutationBatch = function (t, e) {\n          return qo.resolve(this.findMutationBatch(e));\n        }, t.prototype.lookupMutationKeys = function (t, e) {\n          var n = this.findMutationBatch(e);\n          return vn(null != n, \"Failed to find local mutation batch.\"), qo.resolve(n.keys());\n        }, t.prototype.getNextMutationBatchAfterBatchId = function (t, e) {\n          var n = e + 1,\n              r = this.indexOfBatchId(n),\n              i = r < 0 ? 0 : r;\n          return qo.resolve(this.mutationQueue.length > i ? this.mutationQueue[i] : null);\n        }, t.prototype.getAllMutationBatches = function (t) {\n          return qo.resolve(this.mutationQueue.slice());\n        }, t.prototype.getAllMutationBatchesAffectingDocumentKey = function (t, n) {\n          var r = this,\n              e = new ra(n, 0),\n              i = new ra(n, Number.POSITIVE_INFINITY),\n              o = [];\n          return this.batchesByDocumentKey.forEachInRange([e, i], function (t) {\n            vn(n.isEqual(t.key), \"Should only iterate over a single key's batches\");\n            var e = r.findMutationBatch(t.targetOrBatchId);\n            vn(null !== e, \"Batches in the index must exist in the main table\"), o.push(e);\n          }), qo.resolve(o);\n        }, t.prototype.getAllMutationBatchesAffectingDocumentKeys = function (t, e) {\n          var r = this,\n              i = new ci(Hn);\n          return e.forEach(function (e) {\n            var t = new ra(e, 0),\n                n = new ra(e, Number.POSITIVE_INFINITY);\n            r.batchesByDocumentKey.forEachInRange([t, n], function (t) {\n              vn(e.isEqual(t.key), \"For each key, should only iterate over a single key's batches\"), i = i.add(t.targetOrBatchId);\n            });\n          }), qo.resolve(this.findMutationBatches(i));\n        }, t.prototype.getAllMutationBatchesAffectingQuery = function (t, e) {\n          vn(!e.isCollectionGroupQuery(), \"CollectionGroup queries should be handled in LocalDocumentsView\");\n          var n = e.path,\n              r = n.length + 1,\n              i = n;\n          mr.isDocumentKey(i) || (i = i.child(\"\"));\n          var o = new ra(new mr(i), 0),\n              s = new ci(Hn);\n          return this.batchesByDocumentKey.forEachWhile(function (t) {\n            var e = t.key.path;\n            return !!n.isPrefixOf(e) && (e.length === r && (s = s.add(t.targetOrBatchId)), !0);\n          }, o), qo.resolve(this.findMutationBatches(s));\n        }, t.prototype.findMutationBatches = function (t) {\n          var n = this,\n              r = [];\n          return t.forEach(function (t) {\n            var e = n.findMutationBatch(t);\n            null !== e && r.push(e);\n          }), r;\n        }, t.prototype.removeMutationBatch = function (n, r) {\n          var i = this;\n          vn(0 === this.indexOfExistingBatchId(r.batchId, \"removed\"), \"Can only remove the first entry of the mutation queue\"), this.mutationQueue.shift();\n          var o = this.batchesByDocumentKey;\n          return qo.forEach(r.mutations, function (t) {\n            var e = new ra(t.key, r.batchId);\n            return o = o.delete(e), i.referenceDelegate.removeMutationReference(n, t.key);\n          }).next(function () {\n            i.batchesByDocumentKey = o;\n          });\n        }, t.prototype.removeCachedMutationKeys = function (t) {}, t.prototype.containsKey = function (t, e) {\n          var n = new ra(e, 0),\n              r = this.batchesByDocumentKey.firstAfterOrEqual(n);\n          return qo.resolve(e.isEqual(r && r.key));\n        }, t.prototype.performConsistencyCheck = function (t) {\n          return 0 === this.mutationQueue.length && vn(this.batchesByDocumentKey.isEmpty(), \"Document leak -- detected dangling mutation references when queue is empty.\"), qo.resolve();\n        }, t.prototype.indexOfExistingBatchId = function (t, e) {\n          var n = this.indexOfBatchId(t);\n          return vn(0 <= n && n < this.mutationQueue.length, \"Batches must exist to be \" + e), n;\n        }, t.prototype.indexOfBatchId = function (t) {\n          return 0 === this.mutationQueue.length ? 0 : t - this.mutationQueue[0].batchId;\n        }, t.prototype.findMutationBatch = function (t) {\n          var e = this.indexOfBatchId(t);\n          if (e < 0 || e >= this.mutationQueue.length) return null;\n          var n = this.mutationQueue[e];\n          return vn(n.batchId === t, \"If found batch must match\"), n;\n        }, t;\n      }(),\n          sa = function () {\n        function t(t) {\n          this.persistence = t, this.queries = new os(function (t) {\n            return t.canonicalId();\n          }), this.lastRemoteSnapshotVersion = oi.MIN, this.highestTargetId = 0, this.highestSequenceNumber = 0, this.references = new na(), this.targetCount = 0, this.targetIdGenerator = zo.forQueryCache();\n        }\n\n        return t.prototype.getTargetCount = function (t) {\n          return qo.resolve(this.targetCount);\n        }, t.prototype.forEachTarget = function (t, n) {\n          return this.queries.forEach(function (t, e) {\n            return n(e);\n          }), qo.resolve();\n        }, t.prototype.getLastRemoteSnapshotVersion = function (t) {\n          return qo.resolve(this.lastRemoteSnapshotVersion);\n        }, t.prototype.getHighestSequenceNumber = function (t) {\n          return qo.resolve(this.highestSequenceNumber);\n        }, t.prototype.allocateTargetId = function (t) {\n          var e = this.targetIdGenerator.after(this.highestTargetId);\n          return this.highestTargetId = e, qo.resolve(e);\n        }, t.prototype.setTargetsMetadata = function (t, e, n) {\n          return n && (this.lastRemoteSnapshotVersion = n), e > this.highestSequenceNumber && (this.highestSequenceNumber = e), qo.resolve();\n        }, t.prototype.saveQueryData = function (t) {\n          this.queries.set(t.query, t);\n          var e = t.targetId;\n          e > this.highestTargetId && (this.highestTargetId = e), t.sequenceNumber > this.highestSequenceNumber && (this.highestSequenceNumber = t.sequenceNumber);\n        }, t.prototype.addQueryData = function (t, e) {\n          return vn(!this.queries.has(e.query), \"Adding a query that already exists\"), this.saveQueryData(e), this.targetCount += 1, qo.resolve();\n        }, t.prototype.updateQueryData = function (t, e) {\n          return vn(this.queries.has(e.query), \"Updating a non-existent query\"), this.saveQueryData(e), qo.resolve();\n        }, t.prototype.removeQueryData = function (t, e) {\n          return vn(0 < this.targetCount, \"Removing a target from an empty cache\"), vn(this.queries.has(e.query), \"Removing a non-existent target from the cache\"), this.queries.delete(e.query), this.references.removeReferencesForId(e.targetId), this.targetCount -= 1, qo.resolve();\n        }, t.prototype.removeTargets = function (n, r, i) {\n          var o = this,\n              s = 0,\n              a = [];\n          return this.queries.forEach(function (t, e) {\n            e.sequenceNumber <= r && !i[e.targetId] && (o.queries.delete(t), a.push(o.removeMatchingKeysForTargetId(n, e.targetId)), s++);\n          }), qo.waitFor(a).next(function () {\n            return s;\n          });\n        }, t.prototype.getQueryCount = function (t) {\n          return qo.resolve(this.targetCount);\n        }, t.prototype.getQueryData = function (t, e) {\n          var n = this.queries.get(e) || null;\n          return qo.resolve(n);\n        }, t.prototype.getQueryDataForTarget = function (t, e) {\n          return gn(\"Not yet implemented.\");\n        }, t.prototype.addMatchingKeys = function (e, t, n) {\n          this.references.addReferences(t, n);\n          var r = this.persistence.referenceDelegate,\n              i = [];\n          return r && t.forEach(function (t) {\n            i.push(r.addReference(e, t));\n          }), qo.waitFor(i);\n        }, t.prototype.removeMatchingKeys = function (e, t, n) {\n          this.references.removeReferences(t, n);\n          var r = this.persistence.referenceDelegate,\n              i = [];\n          return r && t.forEach(function (t) {\n            i.push(r.removeReference(e, t));\n          }), qo.waitFor(i);\n        }, t.prototype.removeMatchingKeysForTargetId = function (t, e) {\n          return this.references.removeReferencesForId(e), qo.resolve();\n        }, t.prototype.getMatchingKeysForTargetId = function (t, e) {\n          var n = this.references.referencesForId(e);\n          return qo.resolve(n);\n        }, t.prototype.containsKey = function (t, e) {\n          return qo.resolve(this.references.containsKey(e));\n        }, t;\n      }();\n\n      var aa,\n          ua,\n          ca = function () {\n        function t(t, e) {\n          this.indexManager = t, this.sizer = e, this.docs = new wr(mr.comparator), this.newDocumentChanges = Fi(), this.size = 0;\n        }\n\n        return t.prototype.addEntries = function (t, e, n) {\n          for (var r = [], i = 0, o = e; i < o.length; i++) {\n            var s = o[i],\n                a = s.maybeDocument.key;\n            this.docs = this.docs.insert(a, s), this.newDocumentChanges = this.newDocumentChanges.add(a), r.push(this.indexManager.addToCollectionParentIndex(t, a.path.popLast()));\n          }\n\n          return this.size += n, qo.waitFor(r);\n        }, t.prototype.removeEntry = function (t, e) {\n          var n = this.docs.get(e);\n          return n ? (this.docs = this.docs.remove(e), this.size -= n.size, qo.resolve(n.size)) : qo.resolve(0);\n        }, t.prototype.getEntry = function (t, e) {\n          var n = this.docs.get(e);\n          return qo.resolve(n ? n.maybeDocument : null);\n        }, t.prototype.getSizedEntry = function (t, e) {\n          return qo.resolve(this.docs.get(e));\n        }, t.prototype.getEntries = function (t, e) {\n          var n = this,\n              r = _i();\n\n          return e.forEach(function (t) {\n            var e = n.docs.get(t);\n            r = r.insert(t, e ? e.maybeDocument : null);\n          }), qo.resolve(r);\n        }, t.prototype.getSizedEntries = function (t, e) {\n          var n = this,\n              r = _i(),\n              i = new wr(mr.comparator);\n\n          return e.forEach(function (t) {\n            var e = n.docs.get(t);\n            r = r.insert(t, e ? e.maybeDocument : null), i = i.insert(t, e ? e.size : 0);\n          }), qo.resolve({\n            maybeDocuments: r,\n            sizeMap: i\n          });\n        }, t.prototype.getDocumentsMatchingQuery = function (t, e) {\n          vn(!e.isCollectionGroupQuery(), \"CollectionGroup queries should be handled in LocalDocumentsView\");\n\n          for (var n = Pi(), r = new mr(e.path.child(\"\")), i = this.docs.getIteratorFrom(r); i.hasNext();) {\n            var o = i.getNext(),\n                s = o.key,\n                a = o.value.maybeDocument;\n            if (!e.path.isPrefixOf(s.path)) break;\n            a instanceof gr && e.matches(a) && (n = n.insert(a.key, a));\n          }\n\n          return qo.resolve(n);\n        }, t.prototype.forEachDocumentKey = function (t, e) {\n          return qo.forEach(this.docs, function (t) {\n            return e(t);\n          });\n        }, t.prototype.getNewDocumentChanges = function (t) {\n          var r = this,\n              i = Mi();\n          return this.newDocumentChanges.forEach(function (t) {\n            var e = r.docs.get(t),\n                n = e ? e.maybeDocument : new vr(t, oi.forDeletedDoc());\n            i = i.insert(t, n);\n          }), this.newDocumentChanges = Fi(), qo.resolve(i);\n        }, t.prototype.newChangeBuffer = function () {\n          return new ha(this.sizer, this);\n        }, t.prototype.getSize = function (t) {\n          return qo.resolve(this.size);\n        }, t;\n      }(),\n          ha = function (r) {\n        function t(t, e) {\n          var n = r.call(this) || this;\n          return n.sizer = t, n.documentCache = e, n;\n        }\n\n        return a(t, r), t.prototype.applyChanges = function (t) {\n          var i = this,\n              e = this.assertChanges(),\n              o = 0,\n              s = [];\n          return e.forEach(function (t, e) {\n            var n = i.documentSizes.get(t);\n            vn(void 0 !== n, \"Attempting to change document \" + t.toString() + \" without having read it first\");\n            var r = i.sizer(e);\n            o += r - n, s.push({\n              maybeDocument: e,\n              size: r\n            });\n          }), this.documentCache.addEntries(t, s, o);\n        }, t.prototype.getFromCache = function (t, e) {\n          return this.documentCache.getSizedEntry(t, e);\n        }, t.prototype.getAllFromCache = function (t, e) {\n          return this.documentCache.getSizedEntries(t, e);\n        }, t;\n      }(ss),\n          la = function () {\n        function r(t, e) {\n          var n = this;\n          this.clientId = t, this.mutationQueues = {}, this.listenSequence = new To(0), this._started = !1, this._started = !0, this.referenceDelegate = e(this), this.queryCache = new sa(this);\n          this.indexManager = new ms(), this.remoteDocumentCache = new ca(this.indexManager, function (t) {\n            return n.referenceDelegate.documentSize(t);\n          });\n        }\n\n        return r.createLruPersistence = function (t, e, n) {\n          return new r(t, function (t) {\n            return new da(t, new Fs(e), n);\n          });\n        }, r.createEagerPersistence = function (t) {\n          return new r(t, function (t) {\n            return new pa(t);\n          });\n        }, r.prototype.shutdown = function (t) {\n          return this._started = !1, Promise.resolve();\n        }, Object.defineProperty(r.prototype, \"started\", {\n          get: function get() {\n            return this._started;\n          },\n          enumerable: !0,\n          configurable: !0\n        }), r.prototype.getActiveClients = function () {\n          return h(this, void 0, void 0, function () {\n            return p(this, function (t) {\n              return [2, [this.clientId]];\n            });\n          });\n        }, r.prototype.setPrimaryStateListener = function (t) {\n          return t(!0);\n        }, r.prototype.setNetworkEnabled = function (t) {}, r.prototype.getIndexManager = function () {\n          return this.indexManager;\n        }, r.prototype.getMutationQueue = function (t) {\n          var e = this.mutationQueues[t.toKey()];\n          return e || (e = new oa(this.indexManager, this.referenceDelegate), this.mutationQueues[t.toKey()] = e), e;\n        }, r.prototype.getQueryCache = function () {\n          return this.queryCache;\n        }, r.prototype.getRemoteDocumentCache = function () {\n          return this.remoteDocumentCache;\n        }, r.prototype.runTransaction = function (t, e, n) {\n          var r = this;\n          dn(\"MemoryPersistence\", \"Starting transaction:\", t);\n          var i = new fa(this.listenSequence.next());\n          return this.referenceDelegate.onTransactionStarted(), n(i).next(function (t) {\n            return r.referenceDelegate.onTransactionCommitted(i).next(function () {\n              return t;\n            });\n          }).toPromise();\n        }, r.prototype.mutationQueuesContainKey = function (e, n) {\n          return qo.or((t = this.mutationQueues, r = [], Nn(t, function (t, e) {\n            return r.push(e);\n          }), r).map(function (t) {\n            return function () {\n              return t.containsKey(e, n);\n            };\n          }));\n          var t, r;\n        }, r;\n      }(),\n          fa = function fa(t) {\n        this.currentSequenceNumber = t;\n      },\n          pa = function () {\n        function t(t) {\n          this.persistence = t;\n        }\n\n        return t.prototype.setInMemoryPins = function (t) {\n          this.inMemoryPins = t;\n        }, t.prototype.addReference = function (t, e) {\n          return this.orphanedDocuments.delete(e), qo.resolve();\n        }, t.prototype.removeReference = function (t, e) {\n          return this.orphanedDocuments.add(e), qo.resolve();\n        }, t.prototype.removeMutationReference = function (t, e) {\n          return this.orphanedDocuments.add(e), qo.resolve();\n        }, t.prototype.removeTarget = function (t, e) {\n          var n = this,\n              r = this.persistence.getQueryCache();\n          return r.getMatchingKeysForTargetId(t, e.targetId).next(function (t) {\n            t.forEach(function (t) {\n              return n.orphanedDocuments.add(t);\n            });\n          }).next(function () {\n            return r.removeQueryData(t, e);\n          });\n        }, t.prototype.onTransactionStarted = function () {\n          this.orphanedDocuments = new Set();\n        }, t.prototype.onTransactionCommitted = function (n) {\n          var t = this,\n              r = this.persistence.getRemoteDocumentCache();\n          return qo.forEach(this.orphanedDocuments, function (e) {\n            return t.isReferenced(n, e).next(function (t) {\n              return t ? qo.resolve() : r.removeEntry(n, e).next(function () {});\n            });\n          });\n        }, t.prototype.updateLimboDocument = function (t, e) {\n          var n = this;\n          return this.isReferenced(t, e).next(function (t) {\n            t ? n.orphanedDocuments.delete(e) : n.orphanedDocuments.add(e);\n          });\n        }, t.prototype.documentSize = function (t) {\n          return 0;\n        }, t.prototype.isReferenced = function (t, e) {\n          var n = this;\n          return qo.or([function () {\n            return n.persistence.getQueryCache().containsKey(t, e);\n          }, function () {\n            return n.persistence.mutationQueuesContainKey(t, e);\n          }, function () {\n            return qo.resolve(n.inMemoryPins.containsKey(e));\n          }]);\n        }, t;\n      }(),\n          da = function () {\n        function t(t, e, n) {\n          this.persistence = t, this.serializer = e, this.orphanedSequenceNumbers = new os(function (t) {\n            return Mo(t.path);\n          }), this.garbageCollector = new js(this, n);\n        }\n\n        return t.prototype.onTransactionStarted = function () {}, t.prototype.onTransactionCommitted = function (t) {\n          return qo.resolve();\n        }, t.prototype.forEachTarget = function (t, e) {\n          return this.persistence.getQueryCache().forEachTarget(t, e);\n        }, t.prototype.getSequenceNumberCount = function (t) {\n          var n = this.orphanedDocumentCount(t);\n          return this.persistence.getQueryCache().getTargetCount(t).next(function (e) {\n            return n.next(function (t) {\n              return e + t;\n            });\n          });\n        }, t.prototype.orphanedDocumentCount = function (t) {\n          var e = 0;\n          return this.forEachOrphanedDocumentSequenceNumber(t, function (t) {\n            e++;\n          }).next(function () {\n            return e;\n          });\n        }, t.prototype.forEachOrphanedDocumentSequenceNumber = function (n, r) {\n          var i = this;\n          return qo.forEach(this.orphanedSequenceNumbers, function (t, e) {\n            return i.isPinned(n, t, e).next(function (t) {\n              return t ? qo.resolve() : r(e);\n            });\n          });\n        }, t.prototype.setInMemoryPins = function (t) {\n          this.inMemoryPins = t;\n        }, t.prototype.removeTargets = function (t, e, n) {\n          return this.persistence.getQueryCache().removeTargets(t, e, n);\n        }, t.prototype.removeOrphanedDocuments = function (n, t) {\n          var r = this,\n              i = 0,\n              o = this.persistence.getRemoteDocumentCache();\n          return o.forEachDocumentKey(n, function (e) {\n            return r.isPinned(n, e, t).next(function (t) {\n              return t ? qo.resolve() : (i++, o.removeEntry(n, e).next());\n            });\n          }).next(function () {\n            return i;\n          });\n        }, t.prototype.removeMutationReference = function (t, e) {\n          return this.orphanedSequenceNumbers.set(e, t.currentSequenceNumber), qo.resolve();\n        }, t.prototype.removeTarget = function (t, e) {\n          var n = e.copy({\n            sequenceNumber: t.currentSequenceNumber\n          });\n          return this.persistence.getQueryCache().updateQueryData(t, n);\n        }, t.prototype.addReference = function (t, e) {\n          return this.orphanedSequenceNumbers.set(e, t.currentSequenceNumber), qo.resolve();\n        }, t.prototype.removeReference = function (t, e) {\n          return this.orphanedSequenceNumbers.set(e, t.currentSequenceNumber), qo.resolve();\n        }, t.prototype.updateLimboDocument = function (t, e) {\n          return this.orphanedSequenceNumbers.set(e, t.currentSequenceNumber), qo.resolve();\n        }, t.prototype.documentSize = function (t) {\n          var e,\n              n = this.serializer.toDbRemoteDocument(t);\n          if (n.document) e = n.document;else if (n.unknownDocument) e = n.unknownDocument;else {\n            if (!n.noDocument) throw gn(\"Unknown remote document type\");\n            e = n.noDocument;\n          }\n          return JSON.stringify(e).length;\n        }, t.prototype.isPinned = function (t, e, n) {\n          var r = this;\n          return qo.or([function () {\n            return r.persistence.mutationQueuesContainKey(t, e);\n          }, function () {\n            return qo.resolve(r.inMemoryPins.containsKey(e));\n          }, function () {\n            return r.persistence.getQueryCache().containsKey(t, e);\n          }, function () {\n            var t = r.orphanedSequenceNumbers.get(e);\n            return qo.resolve(void 0 !== t && n < t);\n          }]);\n        }, t.prototype.getCacheSize = function (t) {\n          return this.persistence.getRemoteDocumentCache().getSize(t);\n        }, t;\n      }(),\n          ma = function () {\n        function t(t, e, n, r, i) {\n          this.queue = t, this.timerId = e, this.initialDelayMs = n, this.backoffFactor = r, this.maxDelayMs = i, this.timerPromise = null, this.lastAttemptTime = Date.now(), this.reset();\n        }\n\n        return t.prototype.reset = function () {\n          this.currentBaseMs = 0;\n        }, t.prototype.resetToMax = function () {\n          this.currentBaseMs = this.maxDelayMs;\n        }, t.prototype.backoffAndRun = function (t) {\n          var e = this;\n          this.cancel();\n          var n = Math.floor(this.currentBaseMs + this.jitterDelayMs()),\n              r = Math.max(0, Date.now() - this.lastAttemptTime),\n              i = Math.max(0, n - r);\n          0 < this.currentBaseMs && dn(\"ExponentialBackoff\", \"Backing off for \" + i + \" ms (base delay: \" + this.currentBaseMs + \" ms, delay with jitter: \" + n + \" ms, last attempt: \" + r + \" ms ago)\"), this.timerPromise = this.queue.enqueueAfterDelay(this.timerId, i, function () {\n            return e.lastAttemptTime = Date.now(), t();\n          }), this.currentBaseMs *= this.backoffFactor, this.currentBaseMs < this.initialDelayMs && (this.currentBaseMs = this.initialDelayMs), this.currentBaseMs > this.maxDelayMs && (this.currentBaseMs = this.maxDelayMs);\n        }, t.prototype.cancel = function () {\n          null !== this.timerPromise && (this.timerPromise.cancel(), this.timerPromise = null);\n        }, t.prototype.jitterDelayMs = function () {\n          return (Math.random() - .5) * this.currentBaseMs;\n        }, t;\n      }(),\n          ya = \"PersistentStream\";\n\n      (ua = aa || (aa = {}))[ua.Initial = 0] = \"Initial\", ua[ua.Starting = 1] = \"Starting\", ua[ua.Open = 2] = \"Open\", ua[ua.Error = 3] = \"Error\", ua[ua.Backoff = 4] = \"Backoff\";\n\n      var ga,\n          va,\n          ba,\n          wa,\n          Ea = function () {\n        function t(t, e, n, r, i, o) {\n          this.queue = t, this.idleTimerId = n, this.connection = r, this.credentialsProvider = i, this.listener = o, this.state = aa.Initial, this.closeCount = 0, this.idleTimer = null, this.stream = null, this.backoff = new ma(t, e, 1e3, 1.5, 6e4);\n        }\n\n        return t.prototype.isStarted = function () {\n          return this.state === aa.Starting || this.state === aa.Open || this.state === aa.Backoff;\n        }, t.prototype.isOpen = function () {\n          return this.state === aa.Open;\n        }, t.prototype.start = function () {\n          this.state !== aa.Error ? (vn(this.state === aa.Initial, \"Already started\"), this.auth()) : this.performBackoff();\n        }, t.prototype.stop = function () {\n          return h(this, void 0, void 0, function () {\n            return p(this, function (t) {\n              switch (t.label) {\n                case 0:\n                  return this.isStarted() ? [4, this.close(aa.Initial)] : [3, 2];\n\n                case 1:\n                  t.sent(), t.label = 2;\n\n                case 2:\n                  return [2];\n              }\n            });\n          });\n        }, t.prototype.inhibitBackoff = function () {\n          vn(!this.isStarted(), \"Can only inhibit backoff in a stopped state\"), this.state = aa.Initial, this.backoff.reset();\n        }, t.prototype.markIdle = function () {\n          var t = this;\n          this.isOpen() && null === this.idleTimer && (this.idleTimer = this.queue.enqueueAfterDelay(this.idleTimerId, 6e4, function () {\n            return t.handleIdleCloseTimer();\n          }));\n        }, t.prototype.sendRequest = function (t) {\n          this.cancelIdleCheck(), this.stream.send(t);\n        }, t.prototype.handleIdleCloseTimer = function () {\n          return h(this, void 0, void 0, function () {\n            return p(this, function (t) {\n              return this.isOpen() ? [2, this.close(aa.Initial)] : [2];\n            });\n          });\n        }, t.prototype.cancelIdleCheck = function () {\n          this.idleTimer && (this.idleTimer.cancel(), this.idleTimer = null);\n        }, t.prototype.close = function (e, n) {\n          return h(this, void 0, void 0, function () {\n            return p(this, function (t) {\n              switch (t.label) {\n                case 0:\n                  return vn(this.isStarted(), \"Only started streams should be closed.\"), vn(e === aa.Error || jr(n), \"Can't provide an error when not in an error state.\"), this.cancelIdleCheck(), this.backoff.cancel(), this.closeCount++, e !== aa.Error ? this.backoff.reset() : n && n.code === En.RESOURCE_EXHAUSTED ? (mn(n.toString()), mn(\"Using maximum backoff delay to prevent overloading the backend.\"), this.backoff.resetToMax()) : n && n.code === En.UNAUTHENTICATED && this.credentialsProvider.invalidateToken(), null !== this.stream && (this.tearDown(), this.stream.close(), this.stream = null), this.state = e, [4, this.listener.onClose(n)];\n\n                case 1:\n                  return t.sent(), [2];\n              }\n            });\n          });\n        }, t.prototype.tearDown = function () {}, t.prototype.auth = function () {\n          var n = this;\n          vn(this.state === aa.Initial, \"Must be in initial state to auth\"), this.state = aa.Starting;\n          var t = this.getCloseGuardedDispatcher(this.closeCount),\n              e = this.closeCount;\n          this.credentialsProvider.getToken().then(function (t) {\n            n.closeCount === e && n.startStream(t);\n          }, function (e) {\n            t(function () {\n              var t = new Sn(En.UNKNOWN, \"Fetching auth token failed: \" + e.message);\n              return n.handleStreamClose(t);\n            });\n          });\n        }, t.prototype.startStream = function (t) {\n          var e = this;\n          vn(this.state === aa.Starting, \"Trying to start stream in a non-starting state\");\n          var n = this.getCloseGuardedDispatcher(this.closeCount);\n          this.stream = this.startRpc(t), this.stream.onOpen(function () {\n            n(function () {\n              return vn(e.state === aa.Starting, \"Expected stream to be in state Starting, but was \" + e.state), e.state = aa.Open, e.listener.onOpen();\n            });\n          }), this.stream.onClose(function (t) {\n            n(function () {\n              return e.handleStreamClose(t);\n            });\n          }), this.stream.onMessage(function (t) {\n            n(function () {\n              return e.onMessage(t);\n            });\n          });\n        }, t.prototype.performBackoff = function () {\n          var t = this;\n          vn(this.state === aa.Error, \"Should only perform backoff when in Error state\"), this.state = aa.Backoff, this.backoff.backoffAndRun(function () {\n            return h(t, void 0, void 0, function () {\n              return p(this, function (t) {\n                return vn(this.state === aa.Backoff, \"Backoff elapsed but state is now: \" + this.state), this.state = aa.Initial, this.start(), vn(this.isStarted(), \"PersistentStream should have started\"), [2];\n              });\n            });\n          });\n        }, t.prototype.handleStreamClose = function (t) {\n          return vn(this.isStarted(), \"Can't handle server close on non-started stream\"), dn(ya, \"close with error: \" + t), this.stream = null, this.close(aa.Error, t);\n        }, t.prototype.getCloseGuardedDispatcher = function (e) {\n          var n = this;\n          return function (t) {\n            n.queue.enqueueAndForget(function () {\n              return n.closeCount === e ? t() : (dn(ya, \"stream callback skipped by getCloseGuardedDispatcher.\"), Promise.resolve());\n            });\n          };\n        }, t;\n      }(),\n          Sa = function (s) {\n        function t(t, e, n, r, i) {\n          var o = s.call(this, t, Eo.ListenStreamConnectionBackoff, Eo.ListenStreamIdle, e, n, i) || this;\n          return o.serializer = r, o;\n        }\n\n        return a(t, s), t.prototype.startRpc = function (t) {\n          return this.connection.openStream(\"Listen\", t);\n        }, t.prototype.onMessage = function (t) {\n          this.backoff.reset();\n          var e = this.serializer.fromWatchChange(t),\n              n = this.serializer.versionFromListenResponse(t);\n          return this.listener.onWatchChange(e, n);\n        }, t.prototype.watch = function (t) {\n          var e = {};\n          e.database = this.serializer.encodedDatabaseId, e.addTarget = this.serializer.toTarget(t);\n          var n = this.serializer.toListenRequestLabels(t);\n          n && (e.labels = n), this.sendRequest(e);\n        }, t.prototype.unwatch = function (t) {\n          var e = {};\n          e.database = this.serializer.encodedDatabaseId, e.removeTarget = t, this.sendRequest(e);\n        }, t;\n      }(Ea),\n          Ta = function (s) {\n        function t(t, e, n, r, i) {\n          var o = s.call(this, t, Eo.WriteStreamConnectionBackoff, Eo.WriteStreamIdle, e, n, i) || this;\n          return o.serializer = r, o.handshakeComplete_ = !1, o;\n        }\n\n        return a(t, s), Object.defineProperty(t.prototype, \"handshakeComplete\", {\n          get: function get() {\n            return this.handshakeComplete_;\n          },\n          enumerable: !0,\n          configurable: !0\n        }), t.prototype.start = function () {\n          this.handshakeComplete_ = !1, s.prototype.start.call(this);\n        }, t.prototype.tearDown = function () {\n          this.handshakeComplete_ && this.writeMutations([]);\n        }, t.prototype.startRpc = function (t) {\n          return this.connection.openStream(\"Write\", t);\n        }, t.prototype.onMessage = function (t) {\n          if (vn(!!t.streamToken, \"Got a write response without a stream token\"), this.lastStreamToken = t.streamToken, this.handshakeComplete_) {\n            this.backoff.reset();\n            var e = this.serializer.fromWriteResults(t.writeResults, t.commitTime),\n                n = this.serializer.fromVersion(t.commitTime);\n            return this.listener.onMutationResult(n, e);\n          }\n\n          return vn(!t.writeResults || 0 === t.writeResults.length, \"Got mutation results for handshake\"), this.handshakeComplete_ = !0, this.listener.onHandshakeComplete();\n        }, t.prototype.writeHandshake = function () {\n          vn(this.isOpen(), \"Writing handshake requires an opened stream\"), vn(!this.handshakeComplete_, \"Handshake already completed\");\n          var t = {};\n          t.database = this.serializer.encodedDatabaseId, this.sendRequest(t);\n        }, t.prototype.writeMutations = function (t) {\n          var e = this;\n          vn(this.isOpen(), \"Writing mutations requires an opened stream\"), vn(this.handshakeComplete_, \"Handshake must be complete before writing mutations\"), vn(0 < this.lastStreamToken.length, \"Trying to write mutation without a token\");\n          var n = {\n            streamToken: this.lastStreamToken,\n            writes: t.map(function (t) {\n              return e.serializer.toMutation(t);\n            })\n          };\n          this.sendRequest(n);\n        }, t;\n      }(Ea),\n          Ia = function () {\n        function t(t, e, n, r) {\n          this.queue = t, this.connection = e, this.credentials = n, this.serializer = r;\n        }\n\n        return t.prototype.newPersistentWriteStream = function (t) {\n          return new Ta(this.queue, this.connection, this.credentials, this.serializer, t);\n        }, t.prototype.newPersistentWatchStream = function (t) {\n          return new Sa(this.queue, this.connection, this.credentials, this.serializer, t);\n        }, t.prototype.commit = function (t) {\n          var e = this,\n              n = {\n            database: this.serializer.encodedDatabaseId,\n            writes: t.map(function (t) {\n              return e.serializer.toMutation(t);\n            })\n          };\n          return this.invokeRPC(\"Commit\", n).then(function (t) {\n            return e.serializer.fromWriteResults(t.writeResults, t.commitTime);\n          });\n        }, t.prototype.lookup = function (e) {\n          var i = this,\n              t = {\n            database: this.serializer.encodedDatabaseId,\n            documents: e.map(function (t) {\n              return i.serializer.toName(t);\n            })\n          };\n          return this.invokeStreamingRPC(\"BatchGetDocuments\", t).then(function (t) {\n            var n = Mi();\n            t.forEach(function (t) {\n              var e = i.serializer.fromMaybeDocument(t);\n              n = n.insert(e.key, e);\n            });\n            var r = [];\n            return e.forEach(function (t) {\n              var e = n.get(t);\n              vn(!!e, \"Missing entity in write response for \" + t), r.push(e);\n            }), r;\n          });\n        }, t.prototype.invokeRPC = function (e, n) {\n          var r = this;\n          return this.credentials.getToken().then(function (t) {\n            return r.connection.invokeRPC(e, n, t);\n          }).catch(function (t) {\n            throw t.code === En.UNAUTHENTICATED && r.credentials.invalidateToken(), t;\n          });\n        }, t.prototype.invokeStreamingRPC = function (e, n) {\n          var r = this;\n          return this.credentials.getToken().then(function (t) {\n            return r.connection.invokeStreamingRPC(e, n, t);\n          }).catch(function (t) {\n            throw t.code === En.UNAUTHENTICATED && r.credentials.invalidateToken(), t;\n          });\n        }, t;\n      }(),\n          Ca = function () {\n        function t(t) {\n          this.datastore = t, this.readVersions = xi(), this.mutations = [], this.committed = !1;\n        }\n\n        return t.prototype.recordVersion = function (t) {\n          var e;\n          if (t instanceof gr) e = t.version;else {\n            if (!(t instanceof vr)) throw gn(\"Document in a transaction was a \" + t.constructor.name);\n            e = oi.forDeletedDoc();\n          }\n          var n = this.readVersions.get(t.key);\n\n          if (null !== n) {\n            if (!e.isEqual(n)) throw new Sn(En.ABORTED, \"Document version changed between two reads.\");\n          } else this.readVersions = this.readVersions.insert(t.key, e);\n        }, t.prototype.lookup = function (t) {\n          var e = this;\n          return this.committed ? Promise.reject(\"Transaction has already completed.\") : 0 < this.mutations.length ? Promise.reject(\"Transactions lookups are invalid after writes.\") : this.datastore.lookup(t).then(function (t) {\n            return t.forEach(function (t) {\n              t instanceof vr || t instanceof gr ? e.recordVersion(t) : gn(\"Document in a transaction was a \" + t.constructor.name);\n            }), t;\n          });\n        }, t.prototype.write = function (t) {\n          if (this.committed) throw new Sn(En.FAILED_PRECONDITION, \"Transaction has already completed.\");\n          this.mutations = this.mutations.concat(t);\n        }, t.prototype.precondition = function (t) {\n          var e = this.readVersions.get(t);\n          return e ? di.updateTime(e) : di.NONE;\n        }, t.prototype.preconditionForUpdate = function (t) {\n          var e = this.readVersions.get(t);\n          if (e && e.isEqual(oi.forDeletedDoc())) throw new Sn(En.FAILED_PRECONDITION, \"Can't update a document that doesn't exist.\");\n          return e ? di.updateTime(e) : di.exists(!0);\n        }, t.prototype.set = function (t, e) {\n          this.write(e.toMutations(t, this.precondition(t)));\n        }, t.prototype.update = function (t, e) {\n          this.write(e.toMutations(t, this.preconditionForUpdate(t)));\n        }, t.prototype.delete = function (t) {\n          this.write([new bi(t, this.precondition(t))]), this.readVersions = this.readVersions.insert(t, oi.forDeletedDoc());\n        }, t.prototype.commit = function () {\n          var t = this,\n              e = this.readVersions;\n          return this.mutations.forEach(function (t) {\n            e = e.remove(t.key);\n          }), e.isEmpty() ? this.datastore.commit(this.mutations).then(function () {\n            t.committed = !0;\n          }) : Promise.reject(Error(\"Every document read in a transaction must also be written.\"));\n        }, t;\n      }();\n\n      (va = ga || (ga = {}))[va.Unknown = 0] = \"Unknown\", va[va.Online = 1] = \"Online\", va[va.Offline = 2] = \"Offline\", (wa = ba || (ba = {}))[wa.RemoteStore = 0] = \"RemoteStore\", wa[wa.SharedClientState = 1] = \"SharedClientState\";\n\n      var Da = function () {\n        function t(t, e) {\n          this.asyncQueue = t, this.onlineStateHandler = e, this.state = ga.Unknown, this.watchStreamFailures = 0, this.onlineStateTimer = null, this.shouldWarnClientIsOffline = !0;\n        }\n\n        return t.prototype.handleWatchStreamStart = function () {\n          var t = this;\n          0 === this.watchStreamFailures && (this.setAndBroadcast(ga.Unknown), vn(null === this.onlineStateTimer, \"onlineStateTimer shouldn't be started yet\"), this.onlineStateTimer = this.asyncQueue.enqueueAfterDelay(Eo.OnlineStateTimeout, 1e4, function () {\n            return t.onlineStateTimer = null, vn(t.state === ga.Unknown, \"Timer should be canceled if we transitioned to a different state.\"), t.logClientOfflineWarningIfNecessary(\"Backend didn't respond within 10 seconds.\"), t.setAndBroadcast(ga.Offline), Promise.resolve();\n          }));\n        }, t.prototype.handleWatchStreamFailure = function (t) {\n          this.state === ga.Online ? (this.setAndBroadcast(ga.Unknown), vn(0 === this.watchStreamFailures, \"watchStreamFailures must be 0\"), vn(null === this.onlineStateTimer, \"onlineStateTimer must be null\")) : (this.watchStreamFailures++, 1 <= this.watchStreamFailures && (this.clearOnlineStateTimer(), this.logClientOfflineWarningIfNecessary(\"Connection failed 1 times. Most recent error: \" + t.toString()), this.setAndBroadcast(ga.Offline)));\n        }, t.prototype.set = function (t) {\n          this.clearOnlineStateTimer(), this.watchStreamFailures = 0, t === ga.Online && (this.shouldWarnClientIsOffline = !1), this.setAndBroadcast(t);\n        }, t.prototype.setAndBroadcast = function (t) {\n          t !== this.state && (this.state = t, this.onlineStateHandler(t));\n        }, t.prototype.logClientOfflineWarningIfNecessary = function (t) {\n          var e = \"Could not reach Cloud Firestore backend. \" + t + \"\\nThis typically indicates that your device does not have a healthy Internet connection at the moment. The client will operate in offline mode until it is able to successfully connect to the backend.\";\n          this.shouldWarnClientIsOffline ? (mn(e), this.shouldWarnClientIsOffline = !1) : dn(\"OnlineStateTracker\", e);\n        }, t.prototype.clearOnlineStateTimer = function () {\n          null !== this.onlineStateTimer && (this.onlineStateTimer.cancel(), this.onlineStateTimer = null);\n        }, t;\n      }(),\n          Na = \"RemoteStore\",\n          Aa = function () {\n        function t(t, e, n, r) {\n          this.localStore = t, this.datastore = e, this.writePipeline = [], this.listenTargets = {}, this.watchChangeAggregator = null, this.networkEnabled = !1, this.isPrimary = !1, this.onlineStateTracker = new Da(n, r), this.watchStream = this.datastore.newPersistentWatchStream({\n            onOpen: this.onWatchStreamOpen.bind(this),\n            onClose: this.onWatchStreamClose.bind(this),\n            onWatchChange: this.onWatchStreamChange.bind(this)\n          }), this.writeStream = this.datastore.newPersistentWriteStream({\n            onOpen: this.onWriteStreamOpen.bind(this),\n            onClose: this.onWriteStreamClose.bind(this),\n            onHandshakeComplete: this.onWriteHandshakeComplete.bind(this),\n            onMutationResult: this.onMutationResult.bind(this)\n          });\n        }\n\n        return t.prototype.start = function () {\n          return this.enableNetwork();\n        }, t.prototype.enableNetwork = function () {\n          return h(this, void 0, void 0, function () {\n            var e;\n            return p(this, function (t) {\n              switch (t.label) {\n                case 0:\n                  return this.networkEnabled = !0, this.canUseNetwork() ? (e = this.writeStream, [4, this.localStore.getLastStreamToken()]) : [3, 3];\n\n                case 1:\n                  return e.lastStreamToken = t.sent(), this.shouldStartWatchStream() ? this.startWatchStream() : this.onlineStateTracker.set(ga.Unknown), [4, this.fillWritePipeline()];\n\n                case 2:\n                  t.sent(), t.label = 3;\n\n                case 3:\n                  return [2];\n              }\n            });\n          });\n        }, t.prototype.disableNetwork = function () {\n          return h(this, void 0, void 0, function () {\n            return p(this, function (t) {\n              switch (t.label) {\n                case 0:\n                  return this.networkEnabled = !1, [4, this.disableNetworkInternal()];\n\n                case 1:\n                  return t.sent(), this.onlineStateTracker.set(ga.Offline), [2];\n              }\n            });\n          });\n        }, t.prototype.disableNetworkInternal = function () {\n          return h(this, void 0, void 0, function () {\n            return p(this, function (t) {\n              switch (t.label) {\n                case 0:\n                  return [4, this.writeStream.stop()];\n\n                case 1:\n                  return t.sent(), [4, this.watchStream.stop()];\n\n                case 2:\n                  return t.sent(), 0 < this.writePipeline.length && (dn(Na, \"Stopping write stream with \" + this.writePipeline.length + \" pending writes\"), this.writePipeline = []), this.cleanUpWatchStreamState(), [2];\n              }\n            });\n          });\n        }, t.prototype.shutdown = function () {\n          return h(this, void 0, void 0, function () {\n            return p(this, function (t) {\n              switch (t.label) {\n                case 0:\n                  return dn(Na, \"RemoteStore shutting down.\"), this.networkEnabled = !1, [4, this.disableNetworkInternal()];\n\n                case 1:\n                  return t.sent(), this.onlineStateTracker.set(ga.Unknown), [2];\n              }\n            });\n          });\n        }, t.prototype.listen = function (t) {\n          vn(!In(this.listenTargets, t.targetId), \"listen called with duplicate targetId!\"), this.listenTargets[t.targetId] = t, this.shouldStartWatchStream() ? this.startWatchStream() : this.watchStream.isOpen() && this.sendWatchRequest(t);\n        }, t.prototype.unlisten = function (t) {\n          vn(In(this.listenTargets, t), \"unlisten called without assigned target ID!\"), delete this.listenTargets[t], this.watchStream.isOpen() && this.sendUnwatchRequest(t), An(this.listenTargets) && (this.watchStream.isOpen() ? this.watchStream.markIdle() : this.canUseNetwork() && this.onlineStateTracker.set(ga.Unknown));\n        }, t.prototype.getQueryDataForTarget = function (t) {\n          return this.listenTargets[t] || null;\n        }, t.prototype.getRemoteKeysForTarget = function (t) {\n          return this.syncEngine.getRemoteKeysForTarget(t);\n        }, t.prototype.sendWatchRequest = function (t) {\n          this.watchChangeAggregator.recordPendingTargetRequest(t.targetId), this.watchStream.watch(t);\n        }, t.prototype.sendUnwatchRequest = function (t) {\n          this.watchChangeAggregator.recordPendingTargetRequest(t), this.watchStream.unwatch(t);\n        }, t.prototype.startWatchStream = function () {\n          vn(this.shouldStartWatchStream(), \"startWatchStream() called when shouldStartWatchStream() is false.\"), this.watchChangeAggregator = new no(this), this.watchStream.start(), this.onlineStateTracker.handleWatchStreamStart();\n        }, t.prototype.shouldStartWatchStream = function () {\n          return this.canUseNetwork() && !this.watchStream.isStarted() && !An(this.listenTargets);\n        }, t.prototype.canUseNetwork = function () {\n          return this.isPrimary && this.networkEnabled;\n        }, t.prototype.cleanUpWatchStreamState = function () {\n          this.watchChangeAggregator = null;\n        }, t.prototype.onWatchStreamOpen = function () {\n          return h(this, void 0, void 0, function () {\n            var n = this;\n            return p(this, function (t) {\n              return Dn(this.listenTargets, function (t, e) {\n                n.sendWatchRequest(e);\n              }), [2];\n            });\n          });\n        }, t.prototype.onWatchStreamClose = function (e) {\n          return h(this, void 0, void 0, function () {\n            return p(this, function (t) {\n              return void 0 === e && vn(!this.shouldStartWatchStream(), \"Watch stream was stopped gracefully while still needed.\"), this.cleanUpWatchStreamState(), this.shouldStartWatchStream() ? (this.onlineStateTracker.handleWatchStreamFailure(e), this.startWatchStream()) : this.onlineStateTracker.set(ga.Unknown), [2];\n            });\n          });\n        }, t.prototype.onWatchStreamChange = function (n, r) {\n          return h(this, void 0, void 0, function () {\n            var e;\n            return p(this, function (t) {\n              switch (t.label) {\n                case 0:\n                  return this.onlineStateTracker.set(ga.Online), n instanceof to && n.state === Gi.Removed && n.cause ? [2, this.handleTargetError(n)] : (n instanceof $i ? this.watchChangeAggregator.handleDocumentChange(n) : n instanceof Zi ? this.watchChangeAggregator.handleExistenceFilter(n) : (vn(n instanceof to, \"Expected watchChange to be an instance of WatchTargetChange\"), this.watchChangeAggregator.handleTargetChange(n)), r.isEqual(oi.MIN) ? [3, 3] : [4, this.localStore.getLastRemoteSnapshotVersion()]);\n\n                case 1:\n                  return e = t.sent(), 0 <= r.compareTo(e) ? [4, this.raiseWatchSnapshot(r)] : [3, 3];\n\n                case 2:\n                  t.sent(), t.label = 3;\n\n                case 3:\n                  return [2];\n              }\n            });\n          });\n        }, t.prototype.raiseWatchSnapshot = function (r) {\n          var i = this;\n          vn(!r.isEqual(oi.MIN), \"Can't raise event for unknown SnapshotVersion\");\n          var t = this.watchChangeAggregator.createRemoteEvent(r);\n          return Dn(t.targetChanges, function (t, e) {\n            if (0 < e.resumeToken.length) {\n              var n = i.listenTargets[t];\n              n && (i.listenTargets[t] = n.copy({\n                resumeToken: e.resumeToken,\n                snapshotVersion: r\n              }));\n            }\n          }), t.targetMismatches.forEach(function (t) {\n            var e = i.listenTargets[t];\n\n            if (e) {\n              i.listenTargets[t] = e.copy({\n                resumeToken: wn()\n              }), i.sendUnwatchRequest(t);\n              var n = new ui(e.query, t, Gr.ExistenceFilterMismatch, e.sequenceNumber);\n              i.sendWatchRequest(n);\n            }\n          }), this.syncEngine.applyRemoteEvent(t);\n        }, t.prototype.handleTargetError = function (t) {\n          var n = this;\n          vn(!!t.cause, \"Handling target error without a cause\");\n          var r = t.cause,\n              i = Promise.resolve();\n          return t.targetIds.forEach(function (e) {\n            i = i.then(function () {\n              return h(n, void 0, void 0, function () {\n                return p(this, function (t) {\n                  return In(this.listenTargets, e) ? (delete this.listenTargets[e], this.watchChangeAggregator.removeTarget(e), [2, this.syncEngine.rejectListen(e, r)]) : [2];\n                });\n              });\n            });\n          }), i;\n        }, t.prototype.fillWritePipeline = function () {\n          return h(this, void 0, void 0, function () {\n            var e, n;\n            return p(this, function (t) {\n              switch (t.label) {\n                case 0:\n                  return this.canAddToWritePipeline() ? (e = 0 < this.writePipeline.length ? this.writePipeline[this.writePipeline.length - 1].batchId : -1, [4, this.localStore.nextMutationBatch(e)]) : [3, 4];\n\n                case 1:\n                  return null !== (n = t.sent()) ? [3, 2] : (0 === this.writePipeline.length && this.writeStream.markIdle(), [3, 4]);\n\n                case 2:\n                  return this.addToWritePipeline(n), [4, this.fillWritePipeline()];\n\n                case 3:\n                  t.sent(), t.label = 4;\n\n                case 4:\n                  return this.shouldStartWriteStream() && this.startWriteStream(), [2];\n              }\n            });\n          });\n        }, t.prototype.canAddToWritePipeline = function () {\n          return this.canUseNetwork() && this.writePipeline.length < 10;\n        }, t.prototype.outstandingWrites = function () {\n          return this.writePipeline.length;\n        }, t.prototype.addToWritePipeline = function (t) {\n          vn(this.canAddToWritePipeline(), \"addToWritePipeline called when pipeline is full\"), this.writePipeline.push(t), this.writeStream.isOpen() && this.writeStream.handshakeComplete && this.writeStream.writeMutations(t.mutations);\n        }, t.prototype.shouldStartWriteStream = function () {\n          return this.canUseNetwork() && !this.writeStream.isStarted() && 0 < this.writePipeline.length;\n        }, t.prototype.startWriteStream = function () {\n          vn(this.shouldStartWriteStream(), \"startWriteStream() called when shouldStartWriteStream() is false.\"), this.writeStream.start();\n        }, t.prototype.onWriteStreamOpen = function () {\n          return h(this, void 0, void 0, function () {\n            return p(this, function (t) {\n              return this.writeStream.writeHandshake(), [2];\n            });\n          });\n        }, t.prototype.onWriteHandshakeComplete = function () {\n          var r = this;\n          return this.localStore.setLastStreamToken(this.writeStream.lastStreamToken).then(function () {\n            for (var t = 0, e = r.writePipeline; t < e.length; t++) {\n              var n = e[t];\n              r.writeStream.writeMutations(n.mutations);\n            }\n          }).catch(Xs);\n        }, t.prototype.onMutationResult = function (t, e) {\n          var n = this;\n          vn(0 < this.writePipeline.length, \"Got result for empty write pipeline\");\n          var r = this.writePipeline.shift(),\n              i = xo.from(r, t, e, this.writeStream.lastStreamToken);\n          return this.syncEngine.applySuccessfulWrite(i).then(function () {\n            return n.fillWritePipeline();\n          });\n        }, t.prototype.onWriteStreamClose = function (n) {\n          return h(this, void 0, void 0, function () {\n            var e = this;\n            return p(this, function (t) {\n              return void 0 === n && vn(!this.shouldStartWriteStream(), \"Write stream was stopped gracefully while still needed.\"), n && 0 < this.writePipeline.length ? (void 0, [2, (this.writeStream.handshakeComplete ? this.handleWriteError(n) : this.handleHandshakeError(n)).then(function () {\n                e.shouldStartWriteStream() && e.startWriteStream();\n              })]) : [2];\n            });\n          });\n        }, t.prototype.handleHandshakeError = function (e) {\n          return h(this, void 0, void 0, function () {\n            return p(this, function (t) {\n              return Ai(e.code) ? (dn(Na, \"RemoteStore error before completed handshake; resetting stream token: \", this.writeStream.lastStreamToken), this.writeStream.lastStreamToken = wn(), [2, this.localStore.setLastStreamToken(wn()).catch(Xs)]) : [2];\n            });\n          });\n        }, t.prototype.handleWriteError = function (i) {\n          return h(this, void 0, void 0, function () {\n            var n,\n                r = this;\n            return p(this, function (t) {\n              return Ai(e = i.code) && e !== En.ABORTED ? (n = this.writePipeline.shift(), this.writeStream.inhibitBackoff(), [2, this.syncEngine.rejectFailedWrite(n.batchId, i).then(function () {\n                return r.fillWritePipeline();\n              })]) : [2];\n              var e;\n            });\n          });\n        }, t.prototype.createTransaction = function () {\n          return new Ca(this.datastore);\n        }, t.prototype.handleCredentialChange = function () {\n          return h(this, void 0, void 0, function () {\n            return p(this, function (t) {\n              switch (t.label) {\n                case 0:\n                  return this.canUseNetwork() ? (dn(Na, \"RemoteStore restarting streams for new credential\"), this.networkEnabled = !1, [4, this.disableNetworkInternal()]) : [3, 3];\n\n                case 1:\n                  return t.sent(), this.onlineStateTracker.set(ga.Unknown), [4, this.enableNetwork()];\n\n                case 2:\n                  t.sent(), t.label = 3;\n\n                case 3:\n                  return [2];\n              }\n            });\n          });\n        }, t.prototype.applyPrimaryState = function (e) {\n          return h(this, void 0, void 0, function () {\n            return p(this, function (t) {\n              switch (t.label) {\n                case 0:\n                  return (this.isPrimary = e) && this.networkEnabled ? [4, this.enableNetwork()] : [3, 2];\n\n                case 1:\n                  return t.sent(), [3, 4];\n\n                case 2:\n                  return e ? [3, 4] : [4, this.disableNetworkInternal()];\n\n                case 3:\n                  t.sent(), this.onlineStateTracker.set(ga.Unknown), t.label = 4;\n\n                case 4:\n                  return [2];\n              }\n            });\n          });\n        }, t;\n      }(),\n          ka = function ka() {\n        this.listeners = [];\n      },\n          Ra = function () {\n        function t(t) {\n          this.syncEngine = t, this.queries = new os(function (t) {\n            return t.canonicalId();\n          }), this.onlineState = ga.Unknown, this.syncEngine.subscribe(this);\n        }\n\n        return t.prototype.listen = function (t) {\n          var e = t.query,\n              n = !1,\n              r = this.queries.get(e);\n          return r || (n = !0, r = new ka(), this.queries.set(e, r)), r.listeners.push(t), t.applyOnlineStateChange(this.onlineState), r.viewSnap && t.onViewSnapshot(r.viewSnap), n ? this.syncEngine.listen(e).then(function (t) {\n            return r.targetId = t;\n          }) : Promise.resolve(r.targetId);\n        }, t.prototype.unlisten = function (o) {\n          return h(this, void 0, void 0, function () {\n            var e, n, r, i;\n            return p(this, function (t) {\n              return e = o.query, n = !1, (r = this.queries.get(e)) && 0 <= (i = r.listeners.indexOf(o)) && (r.listeners.splice(i, 1), n = 0 === r.listeners.length), n ? (this.queries.delete(e), [2, this.syncEngine.unlisten(e)]) : [2];\n            });\n          });\n        }, t.prototype.onWatchChange = function (t) {\n          for (var e = 0, n = t; e < n.length; e++) {\n            var r = n[e],\n                i = r.query,\n                o = this.queries.get(i);\n\n            if (o) {\n              for (var s = 0, a = o.listeners; s < a.length; s++) {\n                a[s].onViewSnapshot(r);\n              }\n\n              o.viewSnap = r;\n            }\n          }\n        }, t.prototype.onWatchError = function (t, e) {\n          var n = this.queries.get(t);\n          if (n) for (var r = 0, i = n.listeners; r < i.length; r++) {\n            i[r].onError(e);\n          }\n          this.queries.delete(t);\n        }, t.prototype.onOnlineStateChange = function (i) {\n          this.onlineState = i, this.queries.forEach(function (t, e) {\n            for (var n = 0, r = e.listeners; n < r.length; n++) {\n              r[n].applyOnlineStateChange(i);\n            }\n          });\n        }, t;\n      }(),\n          Ma = function () {\n        function t(t, e, n) {\n          this.query = t, this.queryObserver = e, this.raisedInitialEvent = !1, this.onlineState = ga.Unknown, this.options = n || {};\n        }\n\n        return t.prototype.onViewSnapshot = function (t) {\n          if (vn(0 < t.docChanges.length || t.syncStateChanged, \"We got a new snapshot with no changes?\"), !this.options.includeMetadataChanges) {\n            for (var e = [], n = 0, r = t.docChanges; n < r.length; n++) {\n              var i = r[n];\n              i.type !== Ui.Metadata && e.push(i);\n            }\n\n            t = new Yi(t.query, t.docs, t.oldDocs, e, t.mutatedKeys, t.fromCache, t.syncStateChanged, !0);\n          }\n\n          this.raisedInitialEvent ? this.shouldRaiseEvent(t) && this.queryObserver.next(t) : this.shouldRaiseInitialEvent(t, this.onlineState) && this.raiseInitialEvent(t), this.snap = t;\n        }, t.prototype.onError = function (t) {\n          this.queryObserver.error(t);\n        }, t.prototype.applyOnlineStateChange = function (t) {\n          this.onlineState = t, this.snap && !this.raisedInitialEvent && this.shouldRaiseInitialEvent(this.snap, t) && this.raiseInitialEvent(this.snap);\n        }, t.prototype.shouldRaiseInitialEvent = function (t, e) {\n          if (vn(!this.raisedInitialEvent, \"Determining whether to raise first event but already had first event\"), !t.fromCache) return !0;\n          var n = e !== ga.Offline;\n          return this.options.waitForSyncWhenOnline && n ? (vn(t.fromCache, \"Waiting for sync, but snapshot is not from cache\"), !1) : !t.docs.isEmpty() || e === ga.Offline;\n        }, t.prototype.shouldRaiseEvent = function (t) {\n          if (0 < t.docChanges.length) return !0;\n          var e = this.snap && this.snap.hasPendingWrites !== t.hasPendingWrites;\n          return !(!t.syncStateChanged && !e) && !0 === this.options.includeMetadataChanges;\n        }, t.prototype.raiseInitialEvent = function (t) {\n          vn(!this.raisedInitialEvent, \"Trying to raise initial events for second time\"), t = Yi.fromInitialDocuments(t.query, t.docs, t.mutatedKeys, t.fromCache), this.raisedInitialEvent = !0, this.queryObserver.next(t);\n        }, t;\n      }(),\n          _a = function () {\n        function a(t, e, n) {\n          this.targetId = t, this.addedKeys = e, this.removedKeys = n;\n        }\n\n        return a.fromSnapshot = function (t, e) {\n          for (var n = Fi(), r = Fi(), i = 0, o = e.docChanges; i < o.length; i++) {\n            var s = o[i];\n\n            switch (s.type) {\n              case Ui.Added:\n                n = n.add(s.doc.key);\n                break;\n\n              case Ui.Removed:\n                r = r.add(s.doc.key);\n            }\n          }\n\n          return new a(t, n, r);\n        }, a;\n      }(),\n          Oa = function Oa(t) {\n        this.key = t;\n      },\n          Pa = function Pa(t) {\n        this.key = t;\n      },\n          La = function () {\n        function t(t, e) {\n          this.query = t, this._syncedDocuments = e, this.syncState = null, this.current = !1, this.limboDocuments = Fi(), this.mutatedKeys = Fi(), this.documentSet = new Wi(t.docComparator.bind(t));\n        }\n\n        return Object.defineProperty(t.prototype, \"syncedDocuments\", {\n          get: function get() {\n            return this._syncedDocuments;\n          },\n          enumerable: !0,\n          configurable: !0\n        }), t.prototype.computeDocChanges = function (t, e) {\n          var a = this,\n              u = e ? e.changeSet : new Hi(),\n              c = e ? e.documentSet : this.documentSet,\n              h = e ? e.mutatedKeys : this.mutatedKeys,\n              l = c,\n              f = !1,\n              p = this.query.hasLimit() && c.size === this.query.limit ? c.last() : null;\n          if (t.inorderTraversal(function (t, e) {\n            var n = c.get(t),\n                r = e instanceof gr ? e : null;\n            r && (vn(t.isEqual(r.key), \"Mismatching keys found in document changes: \" + t + \" != \" + r.key), r = a.query.matches(r) ? r : null);\n            var i = !!n && a.mutatedKeys.has(n.key),\n                o = !!r && (r.hasLocalMutations || a.mutatedKeys.has(r.key) && r.hasCommittedMutations),\n                s = !1;\n            n && r ? n.data.isEqual(r.data) ? i !== o && (u.track({\n              type: Ui.Metadata,\n              doc: r\n            }), s = !0) : a.shouldWaitForSyncedDocument(n, r) || (u.track({\n              type: Ui.Modified,\n              doc: r\n            }), s = !0, p && 0 < a.query.docComparator(r, p) && (f = !0)) : !n && r ? (u.track({\n              type: Ui.Added,\n              doc: r\n            }), s = !0) : n && !r && (u.track({\n              type: Ui.Removed,\n              doc: n\n            }), s = !0, p && (f = !0));\n            s && (h = r ? (l = l.add(r), o ? h.add(t) : h.delete(t)) : (l = l.delete(t), h.delete(t)));\n          }), this.query.hasLimit()) for (; l.size > this.query.limit;) {\n            var n = l.last();\n            l = l.delete(n.key), h = h.delete(n.key), u.track({\n              type: Ui.Removed,\n              doc: n\n            });\n          }\n          return vn(!f || !e, \"View was refilled using docs that themselves needed refilling.\"), {\n            documentSet: l,\n            changeSet: u,\n            needsRefill: f,\n            mutatedKeys: h\n          };\n        }, t.prototype.shouldWaitForSyncedDocument = function (t, e) {\n          return t.hasLocalMutations && e.hasCommittedMutations && !e.hasLocalMutations;\n        }, t.prototype.applyChanges = function (t, e, n) {\n          var o = this;\n          vn(!t.needsRefill, \"Cannot apply changes that need a refill\");\n          var r = this.documentSet;\n          this.documentSet = t.documentSet, this.mutatedKeys = t.mutatedKeys;\n          var i = t.changeSet.getChanges();\n          i.sort(function (t, e) {\n            return n = t.type, r = e.type, (i = function i(t) {\n              switch (t) {\n                case Ui.Added:\n                  return 1;\n\n                case Ui.Modified:\n                case Ui.Metadata:\n                  return 2;\n\n                case Ui.Removed:\n                  return 0;\n\n                default:\n                  return gn(\"Unknown ChangeType: \" + t);\n              }\n            })(n) - i(r) || o.query.docComparator(t.doc, e.doc);\n            var n, r, i;\n          }), this.applyTargetChange(n);\n          var s = e ? this.updateLimboDocuments() : [],\n              a = 0 === this.limboDocuments.size && this.current ? Ki.Synced : Ki.Local,\n              u = a !== this.syncState;\n          return this.syncState = a, 0 !== i.length || u ? {\n            snapshot: new Yi(this.query, t.documentSet, r, i, t.mutatedKeys, a === Ki.Local, u, !1),\n            limboChanges: s\n          } : {\n            limboChanges: s\n          };\n        }, t.prototype.applyOnlineStateChange = function (t) {\n          return this.current && t === ga.Offline ? (this.current = !1, this.applyChanges({\n            documentSet: this.documentSet,\n            changeSet: new Hi(),\n            mutatedKeys: this.mutatedKeys,\n            needsRefill: !1\n          }, !1)) : {\n            limboChanges: []\n          };\n        }, t.prototype.shouldBeInLimbo = function (t) {\n          return !this._syncedDocuments.has(t) && !!this.documentSet.has(t) && !this.documentSet.get(t).hasLocalMutations;\n        }, t.prototype.applyTargetChange = function (t) {\n          var e = this;\n          t && (t.addedDocuments.forEach(function (t) {\n            return e._syncedDocuments = e._syncedDocuments.add(t);\n          }), t.modifiedDocuments.forEach(function (t) {\n            return vn(e._syncedDocuments.has(t), \"Modified document \" + t + \" not found in view.\");\n          }), t.removedDocuments.forEach(function (t) {\n            return e._syncedDocuments = e._syncedDocuments.delete(t);\n          }), this.current = t.current);\n        }, t.prototype.updateLimboDocuments = function () {\n          var e = this;\n          if (!this.current) return [];\n          var n = this.limboDocuments;\n          this.limboDocuments = Fi(), this.documentSet.forEach(function (t) {\n            e.shouldBeInLimbo(t.key) && (e.limboDocuments = e.limboDocuments.add(t.key));\n          });\n          var r = [];\n          return n.forEach(function (t) {\n            e.limboDocuments.has(t) || r.push(new Pa(t));\n          }), this.limboDocuments.forEach(function (t) {\n            n.has(t) || r.push(new Oa(t));\n          }), r;\n        }, t.prototype.synchronizeWithPersistedState = function (t, e) {\n          this._syncedDocuments = e, this.limboDocuments = Fi();\n          var n = this.computeDocChanges(t);\n          return this.applyChanges(n, !0);\n        }, t.prototype.computeInitialSnapshot = function () {\n          return Yi.fromInitialDocuments(this.query, this.documentSet, this.mutatedKeys, this.syncState === Ki.Local);\n        }, t;\n      }();\n\n      var xa = \"SyncEngine\",\n          qa = function qa(t, e, n) {\n        this.query = t, this.targetId = e, this.view = n;\n      },\n          Fa = function Fa(t) {\n        this.key = t;\n      },\n          Va = function () {\n        function t(t, e, n, r) {\n          this.localStore = t, this.remoteStore = e, this.sharedClientState = n, this.currentUser = r, this.syncEngineListener = null, this.queryViewsByQuery = new os(function (t) {\n            return t.canonicalId();\n          }), this.queryViewsByTarget = {}, this.limboTargetsByKey = new wr(mr.comparator), this.limboResolutionsByTarget = {}, this.limboDocumentRefs = new na(), this.mutationUserCallbacks = {}, this.limboTargetIdGenerator = zo.forSyncEngine(), this.isPrimary = void 0, this.onlineState = ga.Unknown;\n        }\n\n        return Object.defineProperty(t.prototype, \"isPrimaryClient\", {\n          get: function get() {\n            return !0 === this.isPrimary;\n          },\n          enumerable: !0,\n          configurable: !0\n        }), t.prototype.subscribe = function (t) {\n          vn(null !== t, \"SyncEngine listener cannot be null\"), vn(null === this.syncEngineListener, \"SyncEngine already has a subscriber.\"), this.syncEngineListener = t;\n        }, t.prototype.listen = function (s) {\n          return h(this, void 0, void 0, function () {\n            var e, n, r, i, o;\n            return p(this, function (t) {\n              switch (t.label) {\n                case 0:\n                  return this.assertSubscribed(\"listen()\"), (r = this.queryViewsByQuery.get(s)) ? (e = r.targetId, this.sharedClientState.addLocalQueryTarget(e), n = r.view.computeInitialSnapshot(), [3, 4]) : [3, 1];\n\n                case 1:\n                  return [4, this.localStore.allocateQuery(s)];\n\n                case 2:\n                  return i = t.sent(), o = this.sharedClientState.addLocalQueryTarget(i.targetId), e = i.targetId, [4, this.initializeViewAndComputeSnapshot(i, \"current\" === o)];\n\n                case 3:\n                  n = t.sent(), this.isPrimary && this.remoteStore.listen(i), t.label = 4;\n\n                case 4:\n                  return this.syncEngineListener.onWatchChange([n]), [2, e];\n              }\n            });\n          });\n        }, t.prototype.initializeViewAndComputeSnapshot = function (a, u) {\n          var c = this,\n              h = a.query;\n          return this.localStore.executeQuery(h).then(function (s) {\n            return c.localStore.remoteDocumentKeys(a.targetId).then(function (t) {\n              var e = new La(h, t),\n                  n = e.computeDocChanges(s),\n                  r = Ji.createSynthesizedTargetChangeForCurrentChange(a.targetId, u && c.onlineState !== ga.Offline),\n                  i = e.applyChanges(n, !0 === c.isPrimary, r);\n              vn(0 === i.limboChanges.length, \"View returned limbo docs before target ack from the server.\"), vn(!!i.snapshot, \"applyChanges for new view should always return a snapshot\");\n              var o = new qa(h, a.targetId, e);\n              return c.queryViewsByQuery.set(h, o), c.queryViewsByTarget[a.targetId] = o, i.snapshot;\n            });\n          });\n        }, t.prototype.synchronizeViewAndComputeSnapshot = function (i) {\n          var t = this;\n          return this.localStore.executeQuery(i.query).then(function (r) {\n            return t.localStore.remoteDocumentKeys(i.targetId).then(function (n) {\n              return h(t, void 0, void 0, function () {\n                var e;\n                return p(this, function (t) {\n                  return e = i.view.synchronizeWithPersistedState(r, n), this.isPrimary && this.updateTrackedLimbos(i.targetId, e.limboChanges), [2, e];\n                });\n              });\n            });\n          });\n        }, t.prototype.unlisten = function (r) {\n          return h(this, void 0, void 0, function () {\n            var e,\n                n = this;\n            return p(this, function (t) {\n              switch (t.label) {\n                case 0:\n                  return this.assertSubscribed(\"unlisten()\"), vn(!!(e = this.queryViewsByQuery.get(r)), \"Trying to unlisten on query not found:\" + r), this.isPrimary ? (this.sharedClientState.removeLocalQueryTarget(e.targetId), this.sharedClientState.isActiveQueryTarget(e.targetId) ? [3, 2] : [4, this.localStore.releaseQuery(r, !1).then(function () {\n                    n.sharedClientState.clearQueryState(e.targetId), n.remoteStore.unlisten(e.targetId), n.removeAndCleanupQuery(e);\n                  }).catch(Xs)]) : [3, 3];\n\n                case 1:\n                  t.sent(), t.label = 2;\n\n                case 2:\n                  return [3, 5];\n\n                case 3:\n                  return this.removeAndCleanupQuery(e), [4, this.localStore.releaseQuery(r, !0)];\n\n                case 4:\n                  t.sent(), t.label = 5;\n\n                case 5:\n                  return [2];\n              }\n            });\n          });\n        }, t.prototype.write = function (t, e) {\n          var n = this;\n          return this.assertSubscribed(\"write()\"), this.localStore.localWrite(t).then(function (t) {\n            return n.sharedClientState.addPendingMutation(t.batchId), n.addMutationCallback(t.batchId, e), n.emitNewSnapsAndNotifyLocalStore(t.changes);\n          }).then(function () {\n            return n.remoteStore.fillWritePipeline();\n          });\n        }, t.prototype.wrapUpdateFunctionError = function (t) {\n          return t;\n        }, t.prototype.runTransaction = function (e, n) {\n          var r = this;\n          void 0 === n && (n = 5), vn(0 <= n, \"Got negative number of retries for transaction.\");\n          var i = this.remoteStore.createTransaction();\n          return function () {\n            try {\n              var t = e(i);\n              return !jr(t) && t.catch && t.then ? t.catch(function (t) {\n                return Promise.reject(r.wrapUpdateFunctionError(t));\n              }) : Promise.reject(Error(\"Transaction callback must return a Promise\"));\n            } catch (t) {\n              return Promise.reject(r.wrapUpdateFunctionError(t));\n            }\n          }().then(function (t) {\n            return i.commit().then(function () {\n              return t;\n            }).catch(function (t) {\n              return 0 === n ? Promise.reject(t) : r.runTransaction(e, n - 1);\n            });\n          });\n        }, t.prototype.applyRemoteEvent = function (e) {\n          var r = this;\n          return this.assertSubscribed(\"applyRemoteEvent()\"), this.localStore.applyRemoteEvent(e).then(function (t) {\n            return Nn(e.targetChanges, function (t, e) {\n              var n = r.limboResolutionsByTarget[t];\n              n && (vn(e.addedDocuments.size + e.modifiedDocuments.size + e.removedDocuments.size <= 1, \"Limbo resolution for single document contains multiple changes.\"), 0 < e.addedDocuments.size ? n.receivedDocument = !0 : 0 < e.modifiedDocuments.size ? vn(n.receivedDocument, \"Received change for limbo target document without add.\") : 0 < e.removedDocuments.size && (vn(n.receivedDocument, \"Received remove for limbo target document without add.\"), n.receivedDocument = !1));\n            }), r.emitNewSnapsAndNotifyLocalStore(t, e);\n          }).catch(Xs);\n        }, t.prototype.applyOnlineStateChange = function (r, t) {\n          if (this.isPrimary && t === ba.RemoteStore || !this.isPrimary && t === ba.SharedClientState) {\n            var i = [];\n            this.queryViewsByQuery.forEach(function (t, e) {\n              var n = e.view.applyOnlineStateChange(r);\n              vn(0 === n.limboChanges.length, \"OnlineState should not affect limbo documents.\"), n.snapshot && i.push(n.snapshot);\n            }), this.syncEngineListener.onOnlineStateChange(r), this.syncEngineListener.onWatchChange(i), this.onlineState = r, this.isPrimary && this.sharedClientState.setOnlineState(r);\n          }\n        }, t.prototype.rejectListen = function (u, c) {\n          return h(this, void 0, void 0, function () {\n            var e,\n                n,\n                r,\n                i,\n                o,\n                s,\n                a = this;\n            return p(this, function (t) {\n              switch (t.label) {\n                case 0:\n                  return this.assertSubscribed(\"rejectListens()\"), this.sharedClientState.updateQueryState(u, \"rejected\", c), e = this.limboResolutionsByTarget[u], (n = e && e.key) ? (this.limboTargetsByKey = this.limboTargetsByKey.remove(n), delete this.limboResolutionsByTarget[u], r = (r = new wr(mr.comparator)).insert(n, new vr(n, oi.forDeletedDoc())), i = Fi().add(n), o = new Xi(oi.MIN, {}, new ci(Hn), r, i), [2, this.applyRemoteEvent(o)]) : [3, 1];\n\n                case 1:\n                  return vn(!!(s = this.queryViewsByTarget[u]), \"Unknown targetId: \" + u), [4, this.localStore.releaseQuery(s.query, !1).then(function () {\n                    return a.removeAndCleanupQuery(s);\n                  }).catch(Xs)];\n\n                case 2:\n                  t.sent(), this.syncEngineListener.onWatchError(s.query, c), t.label = 3;\n\n                case 3:\n                  return [2];\n              }\n            });\n          });\n        }, t.prototype.applyBatchState = function (n, r, i) {\n          return h(this, void 0, void 0, function () {\n            var e;\n            return p(this, function (t) {\n              switch (t.label) {\n                case 0:\n                  return this.assertSubscribed(\"applyBatchState()\"), [4, this.localStore.lookupMutationDocuments(n)];\n\n                case 1:\n                  return null === (e = t.sent()) ? (dn(xa, \"Cannot apply mutation batch with id: \" + n), [2]) : \"pending\" !== r ? [3, 3] : [4, this.remoteStore.fillWritePipeline()];\n\n                case 2:\n                  return t.sent(), [3, 4];\n\n                case 3:\n                  \"acknowledged\" === r || \"rejected\" === r ? (this.processUserCallback(n, i || null), this.localStore.removeCachedMutationBatchMetadata(n)) : gn(\"Unknown batchState: \" + r), t.label = 4;\n\n                case 4:\n                  return [4, this.emitNewSnapsAndNotifyLocalStore(e)];\n\n                case 5:\n                  return t.sent(), [2];\n              }\n            });\n          });\n        }, t.prototype.applySuccessfulWrite = function (t) {\n          var e = this;\n          this.assertSubscribed(\"applySuccessfulWrite()\");\n          var n = t.batch.batchId;\n          return this.processUserCallback(n, null), this.localStore.acknowledgeBatch(t).then(function (t) {\n            return e.sharedClientState.updateMutationState(n, \"acknowledged\"), e.emitNewSnapsAndNotifyLocalStore(t);\n          }).catch(Xs);\n        }, t.prototype.rejectFailedWrite = function (e, n) {\n          var r = this;\n          return this.assertSubscribed(\"rejectFailedWrite()\"), this.processUserCallback(e, n), this.localStore.rejectBatch(e).then(function (t) {\n            return r.sharedClientState.updateMutationState(e, \"rejected\", n), r.emitNewSnapsAndNotifyLocalStore(t);\n          }).catch(Xs);\n        }, t.prototype.addMutationCallback = function (t, e) {\n          var n = this.mutationUserCallbacks[this.currentUser.toKey()];\n          n || (n = new wr(Hn)), n = n.insert(t, e), this.mutationUserCallbacks[this.currentUser.toKey()] = n;\n        }, t.prototype.processUserCallback = function (t, e) {\n          var n = this.mutationUserCallbacks[this.currentUser.toKey()];\n\n          if (n) {\n            var r = n.get(t);\n            r && (vn(t === n.minKey(), \"Mutation callbacks processed out-of-order?\"), e ? r.reject(e) : r.resolve(), n = n.remove(t)), this.mutationUserCallbacks[this.currentUser.toKey()] = n;\n          }\n        }, t.prototype.removeAndCleanupQuery = function (t) {\n          var e = this;\n\n          if (this.sharedClientState.removeLocalQueryTarget(t.targetId), this.queryViewsByQuery.delete(t.query), delete this.queryViewsByTarget[t.targetId], this.isPrimary) {\n            var n = this.limboDocumentRefs.referencesForId(t.targetId);\n            this.limboDocumentRefs.removeReferencesForId(t.targetId), n.forEach(function (t) {\n              e.limboDocumentRefs.containsKey(t) || e.removeLimboTarget(t);\n            });\n          }\n        }, t.prototype.removeLimboTarget = function (t) {\n          var e = this.limboTargetsByKey.get(t);\n          null !== e && (this.remoteStore.unlisten(e), this.limboTargetsByKey = this.limboTargetsByKey.remove(t), delete this.limboResolutionsByTarget[e]);\n        }, t.prototype.updateTrackedLimbos = function (t, e) {\n          for (var n = 0, r = e; n < r.length; n++) {\n            var i = r[n];\n            if (i instanceof Oa) this.limboDocumentRefs.addReference(i.key, t), this.trackLimboChange(i);else if (i instanceof Pa) {\n              dn(xa, \"Document no longer in limbo: \" + i.key), this.limboDocumentRefs.removeReference(i.key, t), this.limboDocumentRefs.containsKey(i.key) || this.removeLimboTarget(i.key);\n            } else gn(\"Unknown limbo change: \" + JSON.stringify(i));\n          }\n        }, t.prototype.trackLimboChange = function (t) {\n          var e = t.key;\n\n          if (!this.limboTargetsByKey.get(e)) {\n            dn(xa, \"New document in limbo: \" + e);\n            var n = this.limboTargetIdGenerator.next(),\n                r = Hr.atPath(e.path);\n            this.limboResolutionsByTarget[n] = new Fa(e), this.remoteStore.listen(new ui(r, n, Gr.LimboResolution, To.INVALID)), this.limboTargetsByKey = this.limboTargetsByKey.insert(e, n);\n          }\n        }, t.prototype.currentLimboDocs = function () {\n          return this.limboTargetsByKey;\n        }, t.prototype.emitNewSnapsAndNotifyLocalStore = function (n, u) {\n          return h(this, void 0, void 0, function () {\n            var o,\n                s,\n                e,\n                a = this;\n            return p(this, function (t) {\n              switch (t.label) {\n                case 0:\n                  return o = [], s = [], e = [], this.queryViewsByQuery.forEach(function (t, i) {\n                    e.push(Promise.resolve().then(function () {\n                      var e = i.view.computeDocChanges(n);\n                      return e.needsRefill ? a.localStore.executeQuery(i.query).then(function (t) {\n                        return i.view.computeDocChanges(t, e);\n                      }) : e;\n                    }).then(function (t) {\n                      var e = u && u.targetChanges[i.targetId],\n                          n = i.view.applyChanges(t, !0 === a.isPrimary, e);\n\n                      if (a.updateTrackedLimbos(i.targetId, n.limboChanges), n.snapshot) {\n                        a.isPrimary && a.sharedClientState.updateQueryState(i.targetId, n.snapshot.fromCache ? \"not-current\" : \"current\"), o.push(n.snapshot);\n\n                        var r = _a.fromSnapshot(i.targetId, n.snapshot);\n\n                        s.push(r);\n                      }\n                    }));\n                  }), [4, Promise.all(e)];\n\n                case 1:\n                  return t.sent(), this.syncEngineListener.onWatchChange(o), [4, this.localStore.notifyLocalViewChanges(s)];\n\n                case 2:\n                  return t.sent(), [2];\n              }\n            });\n          });\n        }, t.prototype.assertSubscribed = function (t) {\n          vn(null !== this.syncEngineListener, \"Trying to call \" + t + \" before calling subscribe().\");\n        }, t.prototype.handleCredentialChange = function (r) {\n          return h(this, void 0, void 0, function () {\n            var e, n;\n            return p(this, function (t) {\n              switch (t.label) {\n                case 0:\n                  return e = !this.currentUser.isEqual(r), this.currentUser = r, e ? [4, this.localStore.handleUserChange(r)] : [3, 3];\n\n                case 1:\n                  return n = t.sent(), this.sharedClientState.handleUserChange(r, n.removedBatchIds, n.addedBatchIds), [4, this.emitNewSnapsAndNotifyLocalStore(n.affectedDocuments)];\n\n                case 2:\n                  t.sent(), t.label = 3;\n\n                case 3:\n                  return [4, this.remoteStore.handleCredentialChange()];\n\n                case 4:\n                  return t.sent(), [2];\n              }\n            });\n          });\n        }, t.prototype.applyPrimaryState = function (c) {\n          return h(this, void 0, void 0, function () {\n            var e,\n                n,\n                r,\n                i,\n                o,\n                s,\n                a,\n                u = this;\n            return p(this, function (t) {\n              switch (t.label) {\n                case 0:\n                  return !0 !== c || !0 === this.isPrimary ? [3, 3] : (this.isPrimary = !0, [4, this.remoteStore.applyPrimaryState(!0)]);\n\n                case 1:\n                  return t.sent(), e = this.sharedClientState.getAllActiveQueryTargets(), [4, this.synchronizeQueryViewsAndRaiseSnapshots(e.toArray())];\n\n                case 2:\n                  for (n = t.sent(), r = 0, i = n; r < i.length; r++) {\n                    o = i[r], this.remoteStore.listen(o);\n                  }\n\n                  return [3, 7];\n\n                case 3:\n                  return !1 !== c || !1 === this.isPrimary ? [3, 7] : (this.isPrimary = !1, s = [], a = Promise.resolve(), Dn(this.queryViewsByTarget, function (t, e) {\n                    u.sharedClientState.isLocalQueryTarget(t) ? s.push(t) : a = a.then(function () {\n                      return u.unlisten(e.query);\n                    }), u.remoteStore.unlisten(e.targetId);\n                  }), [4, a]);\n\n                case 4:\n                  return t.sent(), [4, this.synchronizeQueryViewsAndRaiseSnapshots(s)];\n\n                case 5:\n                  return t.sent(), this.resetLimboDocuments(), [4, this.remoteStore.applyPrimaryState(!1)];\n\n                case 6:\n                  t.sent(), t.label = 7;\n\n                case 7:\n                  return [2];\n              }\n            });\n          });\n        }, t.prototype.resetLimboDocuments = function () {\n          var e = this;\n          Dn(this.limboResolutionsByTarget, function (t) {\n            e.remoteStore.unlisten(t);\n          }), this.limboDocumentRefs.removeAllReferences(), this.limboResolutionsByTarget = [], this.limboTargetsByKey = new wr(mr.comparator);\n        }, t.prototype.synchronizeQueryViewsAndRaiseSnapshots = function (t) {\n          for (var e = this, n = Promise.resolve(), s = [], a = [], r = function r(o) {\n            n = n.then(function () {\n              return h(e, void 0, void 0, function () {\n                var e, n, r, i;\n                return p(this, function (t) {\n                  switch (t.label) {\n                    case 0:\n                      return (n = this.queryViewsByTarget[o]) ? [4, this.localStore.releaseQuery(n.query, !0)] : [3, 4];\n\n                    case 1:\n                      return t.sent(), [4, this.localStore.allocateQuery(n.query)];\n\n                    case 2:\n                      return e = t.sent(), [4, this.synchronizeViewAndComputeSnapshot(n)];\n\n                    case 3:\n                      return (r = t.sent()).snapshot && a.push(r.snapshot), [3, 8];\n\n                    case 4:\n                      return vn(!0 === this.isPrimary, \"A secondary tab should never have an active query without an active view.\"), [4, this.localStore.getQueryForTarget(o)];\n\n                    case 5:\n                      return vn(!!(i = t.sent()), \"Query data for target \" + o + \" not found\"), [4, this.localStore.allocateQuery(i)];\n\n                    case 6:\n                      return e = t.sent(), [4, this.initializeViewAndComputeSnapshot(e, !1)];\n\n                    case 7:\n                      t.sent(), t.label = 8;\n\n                    case 8:\n                      return s.push(e), [2];\n                  }\n                });\n              });\n            });\n          }, i = 0, o = t; i < o.length; i++) {\n            r(o[i]);\n          }\n\n          return n.then(function () {\n            return e.syncEngineListener.onWatchChange(a), s;\n          });\n        }, t.prototype.getActiveClients = function () {\n          return this.localStore.getActiveClients();\n        }, t.prototype.applyTargetState = function (r, o, n) {\n          return h(this, void 0, void 0, function () {\n            var e,\n                i = this;\n            return p(this, function (t) {\n              switch (t.label) {\n                case 0:\n                  if (this.isPrimary) return dn(xa, \"Ignoring unexpected query state notification.\"), [2];\n                  if (!this.queryViewsByTarget[r]) return [3, 5];\n\n                  switch (o) {\n                    case \"current\":\n                    case \"not-current\":\n                      return [3, 1];\n\n                    case \"rejected\":\n                      return [3, 2];\n                  }\n\n                  return [3, 4];\n\n                case 1:\n                  return [2, this.localStore.getNewDocumentChanges().then(function (n) {\n                    return h(i, void 0, void 0, function () {\n                      var e;\n                      return p(this, function (t) {\n                        switch (t.label) {\n                          case 0:\n                            return e = Xi.createSynthesizedRemoteEventForCurrentChange(r, \"current\" === o), [4, this.emitNewSnapsAndNotifyLocalStore(n, e)];\n\n                          case 1:\n                            return t.sent(), [2];\n                        }\n                      });\n                    });\n                  }, function (r) {\n                    return h(i, void 0, void 0, function () {\n                      var n;\n                      return p(this, function (t) {\n                        switch (t.label) {\n                          case 0:\n                            return (e = r).code !== En.DATA_LOSS || e.message !== as ? [3, 2] : (n = [], Dn(this.queryViewsByTarget, function (t) {\n                              return n.push(t);\n                            }), [4, this.synchronizeQueryViewsAndRaiseSnapshots(n)]);\n\n                          case 1:\n                            return t.sent(), [3, 3];\n\n                          case 2:\n                            throw r;\n\n                          case 3:\n                            return [2];\n                        }\n\n                        var e;\n                      });\n                    });\n                  })];\n\n                case 2:\n                  return e = this.queryViewsByTarget[r], this.removeAndCleanupQuery(e), [4, this.localStore.releaseQuery(e.query, !0)];\n\n                case 3:\n                  return t.sent(), this.syncEngineListener.onWatchError(e.query, n), [3, 5];\n\n                case 4:\n                  gn(\"Unexpected target state: \" + o), t.label = 5;\n\n                case 5:\n                  return [2];\n              }\n            });\n          });\n        }, t.prototype.applyActiveTargetsChange = function (l, f) {\n          return h(this, void 0, void 0, function () {\n            var e,\n                n,\n                r,\n                i,\n                o,\n                s,\n                a,\n                u,\n                c,\n                h = this;\n            return p(this, function (t) {\n              switch (t.label) {\n                case 0:\n                  if (!this.isPrimary) return [2];\n                  e = 0, n = l, t.label = 1;\n\n                case 1:\n                  return e < n.length ? (c = n[e], vn(!this.queryViewsByTarget[c], \"Trying to add an already active target\"), [4, this.localStore.getQueryForTarget(c)]) : [3, 6];\n\n                case 2:\n                  return vn(!!(r = t.sent()), \"Query data for active target \" + c + \" not found\"), [4, this.localStore.allocateQuery(r)];\n\n                case 3:\n                  return i = t.sent(), [4, this.initializeViewAndComputeSnapshot(i, !1)];\n\n                case 4:\n                  t.sent(), this.remoteStore.listen(i), t.label = 5;\n\n                case 5:\n                  return e++, [3, 1];\n\n                case 6:\n                  o = function o(e) {\n                    var n;\n                    return p(this, function (t) {\n                      switch (t.label) {\n                        case 0:\n                          return (n = s.queryViewsByTarget[e]) ? [4, s.localStore.releaseQuery(n.query, !1).then(function () {\n                            h.remoteStore.unlisten(e), h.removeAndCleanupQuery(n);\n                          }).catch(Xs)] : [3, 2];\n\n                        case 1:\n                          t.sent(), t.label = 2;\n\n                        case 2:\n                          return [2];\n                      }\n                    });\n                  }, s = this, a = 0, u = f, t.label = 7;\n\n                case 7:\n                  return a < u.length ? (c = u[a], [5, o(c)]) : [3, 10];\n\n                case 8:\n                  t.sent(), t.label = 9;\n\n                case 9:\n                  return a++, [3, 7];\n\n                case 10:\n                  return [2];\n              }\n            });\n          });\n        }, t.prototype.enableNetwork = function () {\n          return this.localStore.setNetworkEnabled(!0), this.remoteStore.enableNetwork();\n        }, t.prototype.disableNetwork = function () {\n          return this.localStore.setNetworkEnabled(!1), this.remoteStore.disableNetwork();\n        }, t.prototype.getRemoteKeysForTarget = function (t) {\n          var e = this.limboResolutionsByTarget[t];\n          return e && e.receivedDocument ? Fi().add(e.key) : this.queryViewsByTarget[t] ? this.queryViewsByTarget[t].view.syncedDocuments : Fi();\n        }, t;\n      }(),\n          Ba = function () {\n        function t(t) {\n          this.uid = t;\n        }\n\n        return t.prototype.isAuthenticated = function () {\n          return null != this.uid;\n        }, t.prototype.toKey = function () {\n          return this.isAuthenticated() ? \"uid:\" + this.uid : \"anonymous-user\";\n        }, t.prototype.isEqual = function (t) {\n          return t.uid === this.uid;\n        }, t.UNAUTHENTICATED = new t(null), t.GOOGLE_CREDENTIALS = new t(\"google-credentials-uid\"), t.FIRST_PARTY = new t(\"first-party-uid\"), t;\n      }(),\n          Ua = \"SharedClientState\",\n          Qa = \"firestore_clients\",\n          Ka = \"firestore_mutations\",\n          ja = \"firestore_targets\",\n          Wa = function () {\n        function s(t, e, n, r) {\n          this.user = t, this.batchId = e, this.state = n, vn(void 0 !== (this.error = r) == (\"rejected\" === n), \"MutationMetadata must contain an error iff state is 'rejected'\");\n        }\n\n        return s.fromWebStorageEntry = function (t, e, n) {\n          var r = JSON.parse(n),\n              i = \"object\" == typeof r && -1 !== [\"pending\", \"acknowledged\", \"rejected\"].indexOf(r.state) && (void 0 === r.error || \"object\" == typeof r.error),\n              o = void 0;\n          return i && r.error && (i = \"string\" == typeof r.error.message && \"string\" == typeof r.error.code) && (o = new Sn(r.error.code, r.error.message)), i ? new s(t, e, r.state, o) : (mn(Ua, \"Failed to parse mutation state for ID '\" + e + \"': \" + n), null);\n        }, s.prototype.toWebStorageJSON = function () {\n          var t = {\n            state: this.state,\n            updateTimeMs: Date.now()\n          };\n          return this.error && (t.error = {\n            code: this.error.code,\n            message: this.error.message\n          }), JSON.stringify(t);\n        }, s;\n      }(),\n          Ga = function () {\n        function o(t, e, n) {\n          this.targetId = t, this.state = e, vn(void 0 !== (this.error = n) == (\"rejected\" === e), \"QueryTargetMetadata must contain an error iff state is 'rejected'\");\n        }\n\n        return o.fromWebStorageEntry = function (t, e) {\n          var n = JSON.parse(e),\n              r = \"object\" == typeof n && -1 !== [\"not-current\", \"current\", \"rejected\"].indexOf(n.state) && (void 0 === n.error || \"object\" == typeof n.error),\n              i = void 0;\n          return r && n.error && (r = \"string\" == typeof n.error.message && \"string\" == typeof n.error.code) && (i = new Sn(n.error.code, n.error.message)), r ? new o(t, n.state, i) : (mn(Ua, \"Failed to parse target state for ID '\" + t + \"': \" + e), null);\n        }, o.prototype.toWebStorageJSON = function () {\n          var t = {\n            state: this.state,\n            updateTimeMs: Date.now()\n          };\n          return this.error && (t.error = {\n            code: this.error.code,\n            message: this.error.message\n          }), JSON.stringify(t);\n        }, o;\n      }(),\n          za = function () {\n        function s(t, e) {\n          this.clientId = t, this.activeTargetIds = e;\n        }\n\n        return s.fromWebStorageEntry = function (t, e) {\n          for (var n = JSON.parse(e), r = \"object\" == typeof n && n.activeTargetIds instanceof Array, i = Bi(), o = 0; r && o < n.activeTargetIds.length; ++o) {\n            r = Wr(n.activeTargetIds[o]), i = i.add(n.activeTargetIds[o]);\n          }\n\n          return r ? new s(t, i) : (mn(Ua, \"Failed to parse client data for instance '\" + t + \"': \" + e), null);\n        }, s;\n      }(),\n          Ha = function () {\n        function n(t, e) {\n          this.clientId = t, this.onlineState = e;\n        }\n\n        return n.fromWebStorageEntry = function (t) {\n          var e = JSON.parse(t);\n          return \"object\" == typeof e && void 0 !== ga[e.onlineState] && \"string\" == typeof e.clientId ? new n(e.clientId, ga[e.onlineState]) : (mn(Ua, \"Failed to parse online state: \" + t), null);\n        }, n;\n      }(),\n          Ya = function () {\n        function t() {\n          this.activeTargetIds = Bi();\n        }\n\n        return t.prototype.addQueryTarget = function (t) {\n          vn(!this.activeTargetIds.has(t), \"Target with ID '\" + t + \"' already active.\"), this.activeTargetIds = this.activeTargetIds.add(t);\n        }, t.prototype.removeQueryTarget = function (t) {\n          this.activeTargetIds = this.activeTargetIds.delete(t);\n        }, t.prototype.toWebStorageJSON = function () {\n          var t = {\n            activeTargetIds: this.activeTargetIds.toArray(),\n            updateTimeMs: Date.now()\n          };\n          return JSON.stringify(t);\n        }, t;\n      }(),\n          Xa = function () {\n        function s(t, e, n, r, i) {\n          if (this.queue = t, this.platform = e, this.persistenceKey = n, this.localClientId = r, this.syncEngine = null, this.onlineStateHandler = null, this.sequenceNumberHandler = null, this.activeClients = {}, this.storageListener = this.handleWebStorageEvent.bind(this), this.started = !1, this.earlyEvents = [], !s.isAvailable(this.platform)) throw new Sn(En.UNIMPLEMENTED, \"LocalStorage is not available on this platform.\");\n          var o = n.replace(/[.*+?^${}()|[\\]\\\\]/g, \"\\\\$&\");\n          this.storage = this.platform.window.localStorage, this.currentUser = i, this.localClientStorageKey = this.toWebStorageClientStateKey(this.localClientId), this.sequenceNumberKey = \"firestore_sequence_number_\" + n, this.activeClients[this.localClientId] = new Ya(), this.clientStateKeyRe = new RegExp(\"^\" + Qa + \"_\" + o + \"_([^_]*)$\"), this.mutationBatchKeyRe = new RegExp(\"^\" + Ka + \"_\" + o + \"_(\\\\d+)(?:_(.*))?$\"), this.queryTargetKeyRe = new RegExp(\"^\" + ja + \"_\" + o + \"_(\\\\d+)$\"), this.onlineStateKey = \"firestore_online_state_\" + n, this.platform.window.addEventListener(\"storage\", this.storageListener);\n        }\n\n        return s.isAvailable = function (t) {\n          return !(!t.window || null == t.window.localStorage);\n        }, s.prototype.start = function () {\n          return h(this, void 0, void 0, function () {\n            var e,\n                n,\n                r,\n                i,\n                o,\n                s,\n                a,\n                u,\n                c,\n                h,\n                l,\n                f = this;\n            return p(this, function (t) {\n              switch (t.label) {\n                case 0:\n                  return vn(!this.started, \"WebStorageSharedClientState already started\"), vn(null !== this.syncEngine, \"syncEngine property must be set before calling start()\"), vn(null !== this.onlineStateHandler, \"onlineStateHandler property must be set before calling start()\"), [4, this.syncEngine.getActiveClients()];\n\n                case 1:\n                  for (e = t.sent(), n = 0, r = e; n < r.length; n++) {\n                    (i = r[n]) !== this.localClientId && (o = this.getItem(this.toWebStorageClientStateKey(i))) && (s = za.fromWebStorageEntry(i, o)) && (this.activeClients[s.clientId] = s);\n                  }\n\n                  for (this.persistClientState(), (a = this.storage.getItem(this.onlineStateKey)) && (u = this.fromWebStorageOnlineState(a)) && this.handleOnlineStateEvent(u), c = 0, h = this.earlyEvents; c < h.length; c++) {\n                    l = h[c], this.handleWebStorageEvent(l);\n                  }\n\n                  return this.earlyEvents = [], this.platform.window.addEventListener(\"unload\", function () {\n                    return f.shutdown();\n                  }), this.started = !0, [2];\n              }\n            });\n          });\n        }, s.prototype.writeSequenceNumber = function (t) {\n          this.setItem(this.sequenceNumberKey, JSON.stringify(t));\n        }, s.prototype.getAllActiveQueryTargets = function () {\n          var n = Bi();\n          return Nn(this.activeClients, function (t, e) {\n            n = n.unionWith(e.activeTargetIds);\n          }), n;\n        }, s.prototype.isActiveQueryTarget = function (t) {\n          for (var e in this.activeClients) {\n            if (this.activeClients.hasOwnProperty(e) && this.activeClients[e].activeTargetIds.has(t)) return !0;\n          }\n\n          return !1;\n        }, s.prototype.addPendingMutation = function (t) {\n          this.persistMutationState(t, \"pending\");\n        }, s.prototype.updateMutationState = function (t, e, n) {\n          this.persistMutationState(t, e, n), this.removeMutationState(t);\n        }, s.prototype.addLocalQueryTarget = function (t) {\n          var e = \"not-current\";\n\n          if (this.isActiveQueryTarget(t)) {\n            var n = this.storage.getItem(this.toWebStorageQueryTargetMetadataKey(t));\n\n            if (n) {\n              var r = Ga.fromWebStorageEntry(t, n);\n              r && (e = r.state);\n            }\n          }\n\n          return this.localClientState.addQueryTarget(t), this.persistClientState(), e;\n        }, s.prototype.removeLocalQueryTarget = function (t) {\n          this.localClientState.removeQueryTarget(t), this.persistClientState();\n        }, s.prototype.isLocalQueryTarget = function (t) {\n          return this.localClientState.activeTargetIds.has(t);\n        }, s.prototype.clearQueryState = function (t) {\n          this.removeItem(this.toWebStorageQueryTargetMetadataKey(t));\n        }, s.prototype.updateQueryState = function (t, e, n) {\n          this.persistQueryTargetState(t, e, n);\n        }, s.prototype.handleUserChange = function (t, e, n) {\n          var r = this;\n          e.forEach(function (t) {\n            r.removeMutationState(t);\n          }), this.currentUser = t, n.forEach(function (t) {\n            r.addPendingMutation(t);\n          });\n        }, s.prototype.setOnlineState = function (t) {\n          this.persistOnlineState(t);\n        }, s.prototype.shutdown = function () {\n          this.started && (this.platform.window.removeEventListener(\"storage\", this.storageListener), this.removeItem(this.localClientStorageKey), this.started = !1);\n        }, s.prototype.getItem = function (t) {\n          var e = this.storage.getItem(t);\n          return dn(Ua, \"READ\", t, e), e;\n        }, s.prototype.setItem = function (t, e) {\n          dn(Ua, \"SET\", t, e), this.storage.setItem(t, e);\n        }, s.prototype.removeItem = function (t) {\n          dn(Ua, \"REMOVE\", t), this.storage.removeItem(t);\n        }, s.prototype.handleWebStorageEvent = function (a) {\n          var t = this;\n\n          if (a.storageArea === this.storage) {\n            if (dn(Ua, \"EVENT\", a.key, a.newValue), a.key === this.localClientStorageKey) return void mn(\"Received WebStorage notification for local change. Another client might have garbage-collected our state\");\n            this.queue.enqueueAndForget(function () {\n              return h(t, void 0, void 0, function () {\n                var e, n, r, i, o, s;\n                return p(this, function (t) {\n                  if (!this.started) return this.earlyEvents.push(a), [2];\n                  if (null === a.key) return [2];\n\n                  if (this.clientStateKeyRe.test(a.key)) {\n                    if (null == a.newValue) return n = this.fromWebStorageClientStateKey(a.key), [2, this.handleClientStateEvent(n, null)];\n                    if (e = this.fromWebStorageClientState(a.key, a.newValue)) return [2, this.handleClientStateEvent(e.clientId, e)];\n                  } else if (this.mutationBatchKeyRe.test(a.key)) {\n                    if (null !== a.newValue && (r = this.fromWebStorageMutationMetadata(a.key, a.newValue))) return [2, this.handleMutationBatchEvent(r)];\n                  } else if (this.queryTargetKeyRe.test(a.key)) {\n                    if (null !== a.newValue && (i = this.fromWebStorageQueryTargetMetadata(a.key, a.newValue))) return [2, this.handleQueryTargetEvent(i)];\n                  } else if (a.key === this.onlineStateKey) {\n                    if (null !== a.newValue && (o = this.fromWebStorageOnlineState(a.newValue))) return [2, this.handleOnlineStateEvent(o)];\n                  } else a.key === this.sequenceNumberKey && (vn(!!this.sequenceNumberHandler, \"Missing sequenceNumberHandler\"), (s = function (t) {\n                    var e = To.INVALID;\n                    if (null != t) try {\n                      var n = JSON.parse(t);\n                      vn(\"number\" == typeof n, \"Found non-numeric sequence number\"), e = n;\n                    } catch (t) {\n                      mn(Ua, \"Failed to read sequence number from WebStorage\", t);\n                    }\n                    return e;\n                  }(a.newValue)) !== To.INVALID && this.sequenceNumberHandler(s));\n\n                  return [2];\n                });\n              });\n            });\n          }\n        }, Object.defineProperty(s.prototype, \"localClientState\", {\n          get: function get() {\n            return this.activeClients[this.localClientId];\n          },\n          enumerable: !0,\n          configurable: !0\n        }), s.prototype.persistClientState = function () {\n          this.setItem(this.localClientStorageKey, this.localClientState.toWebStorageJSON());\n        }, s.prototype.persistMutationState = function (t, e, n) {\n          var r = new Wa(this.currentUser, t, e, n),\n              i = this.toWebStorageMutationBatchKey(t);\n          this.setItem(i, r.toWebStorageJSON());\n        }, s.prototype.removeMutationState = function (t) {\n          var e = this.toWebStorageMutationBatchKey(t);\n          this.removeItem(e);\n        }, s.prototype.persistOnlineState = function (t) {\n          var e = {\n            clientId: this.localClientId,\n            onlineState: ga[t]\n          };\n          this.storage.setItem(this.onlineStateKey, JSON.stringify(e));\n        }, s.prototype.persistQueryTargetState = function (t, e, n) {\n          var r = this.toWebStorageQueryTargetMetadataKey(t),\n              i = new Ga(t, e, n);\n          this.setItem(r, i.toWebStorageJSON());\n        }, s.prototype.toWebStorageClientStateKey = function (t) {\n          return vn(-1 === t.indexOf(\"_\"), \"Client key cannot contain '_', but was '\" + t + \"'\"), Qa + \"_\" + this.persistenceKey + \"_\" + t;\n        }, s.prototype.toWebStorageQueryTargetMetadataKey = function (t) {\n          return ja + \"_\" + this.persistenceKey + \"_\" + t;\n        }, s.prototype.toWebStorageMutationBatchKey = function (t) {\n          var e = Ka + \"_\" + this.persistenceKey + \"_\" + t;\n          return this.currentUser.isAuthenticated() && (e += \"_\" + this.currentUser.uid), e;\n        }, s.prototype.fromWebStorageClientStateKey = function (t) {\n          var e = this.clientStateKeyRe.exec(t);\n          return e ? e[1] : null;\n        }, s.prototype.fromWebStorageClientState = function (t, e) {\n          var n = this.fromWebStorageClientStateKey(t);\n          return vn(null !== n, \"Cannot parse client state key '\" + t + \"'\"), za.fromWebStorageEntry(n, e);\n        }, s.prototype.fromWebStorageMutationMetadata = function (t, e) {\n          var n = this.mutationBatchKeyRe.exec(t);\n          vn(null !== n, \"Cannot parse mutation batch key '\" + t + \"'\");\n          var r = Number(n[1]),\n              i = void 0 !== n[2] ? n[2] : null;\n          return Wa.fromWebStorageEntry(new Ba(i), r, e);\n        }, s.prototype.fromWebStorageQueryTargetMetadata = function (t, e) {\n          var n = this.queryTargetKeyRe.exec(t);\n          vn(null !== n, \"Cannot parse query target key '\" + t + \"'\");\n          var r = Number(n[1]);\n          return Ga.fromWebStorageEntry(r, e);\n        }, s.prototype.fromWebStorageOnlineState = function (t) {\n          return Ha.fromWebStorageEntry(t);\n        }, s.prototype.handleMutationBatchEvent = function (e) {\n          return h(this, void 0, void 0, function () {\n            return p(this, function (t) {\n              return e.user.uid !== this.currentUser.uid ? (dn(Ua, \"Ignoring mutation for non-active user \" + e.user.uid), [2]) : [2, this.syncEngine.applyBatchState(e.batchId, e.state, e.error)];\n            });\n          });\n        }, s.prototype.handleQueryTargetEvent = function (t) {\n          return this.syncEngine.applyTargetState(t.targetId, t.state, t.error);\n        }, s.prototype.handleClientStateEvent = function (t, e) {\n          var n = this,\n              r = this.getAllActiveQueryTargets();\n          e ? this.activeClients[t] = e : delete this.activeClients[t];\n          var i = this.getAllActiveQueryTargets(),\n              o = [],\n              s = [];\n          return i.forEach(function (e) {\n            return h(n, void 0, void 0, function () {\n              return p(this, function (t) {\n                return r.has(e) || o.push(e), [2];\n              });\n            });\n          }), r.forEach(function (e) {\n            return h(n, void 0, void 0, function () {\n              return p(this, function (t) {\n                return i.has(e) || s.push(e), [2];\n              });\n            });\n          }), this.syncEngine.applyActiveTargetsChange(o, s);\n        }, s.prototype.handleOnlineStateEvent = function (t) {\n          this.activeClients[t.clientId] && this.onlineStateHandler(t.onlineState);\n        }, s;\n      }();\n\n      var Ja = function () {\n        function t() {\n          this.localState = new Ya(), this.queryState = {}, this.syncEngine = null, this.onlineStateHandler = null, this.sequenceNumberHandler = null;\n        }\n\n        return t.prototype.addPendingMutation = function (t) {}, t.prototype.updateMutationState = function (t, e, n) {}, t.prototype.addLocalQueryTarget = function (t) {\n          return this.localState.addQueryTarget(t), this.queryState[t] || \"not-current\";\n        }, t.prototype.updateQueryState = function (t, e, n) {\n          this.queryState[t] = e;\n        }, t.prototype.removeLocalQueryTarget = function (t) {\n          this.localState.removeQueryTarget(t);\n        }, t.prototype.isLocalQueryTarget = function (t) {\n          return this.localState.activeTargetIds.has(t);\n        }, t.prototype.clearQueryState = function (t) {\n          delete this.queryState[t];\n        }, t.prototype.getAllActiveQueryTargets = function () {\n          return this.localState.activeTargetIds;\n        }, t.prototype.isActiveQueryTarget = function (t) {\n          return this.localState.activeTargetIds.has(t);\n        }, t.prototype.start = function () {\n          return this.localState = new Ya(), Promise.resolve();\n        }, t.prototype.handleUserChange = function (t, e, n) {}, t.prototype.setOnlineState = function (t) {}, t.prototype.shutdown = function () {}, t.prototype.writeSequenceNumber = function (t) {}, t;\n      }(),\n          $a = \"FirestoreClient\",\n          Za = function () {\n        function t(t, e) {\n          this.cacheSizeBytes = t, this.experimentalTabSynchronization = e;\n        }\n\n        return t.prototype.lruParams = function () {\n          return Qs.withCacheSize(this.cacheSizeBytes);\n        }, t;\n      }(),\n          tu = function tu() {},\n          eu = function () {\n        function t(t, e, n, r) {\n          this.platform = t, this.databaseInfo = e, this.credentials = n, this.asyncQueue = r, this.clientId = zn.newId();\n        }\n\n        return t.prototype.start = function (t) {\n          var n = this,\n              r = new Io(),\n              i = new Io(),\n              o = !1;\n          return this.credentials.setChangeListener(function (e) {\n            o ? n.asyncQueue.enqueueAndForget(function () {\n              return n.handleCredentialChange(e);\n            }) : (o = !0, n.initializePersistence(t, i, e).then(function (t) {\n              return n.initializeRest(e, t);\n            }).then(r.resolve, r.reject));\n          }), this.asyncQueue.enqueueAndForget(function () {\n            return r.promise;\n          }), i.promise;\n        }, t.prototype.enableNetwork = function () {\n          var t = this;\n          return this.asyncQueue.enqueue(function () {\n            return t.syncEngine.enableNetwork();\n          });\n        }, t.prototype.initializePersistence = function (t, e, n) {\n          var r = this;\n          return t instanceof Za ? this.startIndexedDbPersistence(n, t).then(function (t) {\n            return e.resolve(), t;\n          }).catch(function (t) {\n            if (e.reject(t), !r.canFallback(t)) throw t;\n            return console.warn(\"Error enabling offline storage. Falling back to storage disabled: \" + t), r.startMemoryPersistence();\n          }) : (e.resolve(), this.startMemoryPersistence());\n        }, t.prototype.canFallback = function (t) {\n          return t instanceof Sn ? t.code === En.FAILED_PRECONDITION || t.code === En.UNIMPLEMENTED : !(\"undefined\" != typeof DOMException && t instanceof DOMException) || 22 === t.code || 20 === t.code;\n        }, t.prototype.startIndexedDbPersistence = function (r, i) {\n          var t = this,\n              o = Ys.buildStoragePrefix(this.databaseInfo),\n              s = new fo(this.databaseInfo.databaseId, {\n            useProto3Json: !0\n          });\n          return Promise.resolve().then(function () {\n            return h(t, void 0, void 0, function () {\n              var e, n;\n              return p(this, function (t) {\n                switch (t.label) {\n                  case 0:\n                    if (i.experimentalTabSynchronization && !Xa.isAvailable(this.platform)) throw new Sn(En.UNIMPLEMENTED, \"IndexedDB persistence is only available on platforms that support LocalStorage.\");\n                    return n = i.lruParams(), i.experimentalTabSynchronization ? (this.sharedClientState = new Xa(this.asyncQueue, this.platform, o, this.clientId, r), [4, Ys.createMultiClientIndexedDbPersistence(o, this.clientId, this.platform, this.asyncQueue, s, n, {\n                      sequenceNumberSyncer: this.sharedClientState\n                    })]) : [3, 2];\n\n                  case 1:\n                    return e = t.sent(), [3, 4];\n\n                  case 2:\n                    return this.sharedClientState = new Ja(), [4, Ys.createIndexedDbPersistence(o, this.clientId, this.platform, this.asyncQueue, s, n)];\n\n                  case 3:\n                    e = t.sent(), t.label = 4;\n\n                  case 4:\n                    return [2, (this.persistence = e).referenceDelegate.garbageCollector];\n                }\n              });\n            });\n          });\n        }, t.prototype.startMemoryPersistence = function () {\n          return this.persistence = la.createEagerPersistence(this.clientId), this.sharedClientState = new Ja(), Promise.resolve(null);\n        }, t.prototype.initializeRest = function (a, u) {\n          var t = this;\n          return dn($a, \"Initializing. user=\", a.uid), this.platform.loadConnection(this.databaseInfo).then(function (s) {\n            return h(t, void 0, void 0, function () {\n              var e,\n                  n,\n                  r,\n                  i,\n                  o = this;\n              return p(this, function (t) {\n                switch (t.label) {\n                  case 0:\n                    return this.localStore = new ia(this.persistence, a), u && (this.lruScheduler = new Ks(u, this.asyncQueue, this.localStore)), e = this.platform.newSerializer(this.databaseInfo.databaseId), n = new Ia(this.asyncQueue, s, this.credentials, e), r = function r(t) {\n                      return o.syncEngine.applyOnlineStateChange(t, ba.RemoteStore);\n                    }, i = function i(t) {\n                      return o.syncEngine.applyOnlineStateChange(t, ba.SharedClientState);\n                    }, this.remoteStore = new Aa(this.localStore, n, this.asyncQueue, r), this.syncEngine = new Va(this.localStore, this.remoteStore, this.sharedClientState, a), this.sharedClientState.onlineStateHandler = i, this.remoteStore.syncEngine = this.syncEngine, this.sharedClientState.syncEngine = this.syncEngine, this.eventMgr = new Ra(this.syncEngine), [4, this.sharedClientState.start()];\n\n                  case 1:\n                    return t.sent(), [4, this.remoteStore.start()];\n\n                  case 2:\n                    return t.sent(), [4, this.persistence.setPrimaryStateListener(function (e) {\n                      return h(o, void 0, void 0, function () {\n                        return p(this, function (t) {\n                          switch (t.label) {\n                            case 0:\n                              return [4, this.syncEngine.applyPrimaryState(e)];\n\n                            case 1:\n                              return t.sent(), this.lruScheduler && (e && !this.lruScheduler.started ? this.lruScheduler.start() : e || this.lruScheduler.stop()), [2];\n                          }\n                        });\n                      });\n                    })];\n\n                  case 3:\n                    return t.sent(), [2];\n                }\n              });\n            });\n          });\n        }, t.prototype.handleCredentialChange = function (t) {\n          return this.asyncQueue.verifyOperationInProgress(), dn($a, \"Credential Changed. Current user: \" + t.uid), this.syncEngine.handleCredentialChange(t);\n        }, t.prototype.disableNetwork = function () {\n          var t = this;\n          return this.asyncQueue.enqueue(function () {\n            return t.syncEngine.disableNetwork();\n          });\n        }, t.prototype.shutdown = function (e) {\n          var t = this;\n          return this.asyncQueue.enqueue(function () {\n            return h(t, void 0, void 0, function () {\n              return p(this, function (t) {\n                switch (t.label) {\n                  case 0:\n                    return this.lruScheduler && this.lruScheduler.stop(), [4, this.remoteStore.shutdown()];\n\n                  case 1:\n                    return t.sent(), [4, this.sharedClientState.shutdown()];\n\n                  case 2:\n                    return t.sent(), [4, this.persistence.shutdown(e && e.purgePersistenceWithDataLoss)];\n\n                  case 3:\n                    return t.sent(), this.credentials.removeChangeListener(), [2];\n                }\n              });\n            });\n          });\n        }, t.prototype.listen = function (t, e, n) {\n          var r = this,\n              i = new Ma(t, e, n);\n          return this.asyncQueue.enqueueAndForget(function () {\n            return r.eventMgr.listen(i);\n          }), i;\n        }, t.prototype.unlisten = function (t) {\n          var e = this;\n          this.asyncQueue.enqueueAndForget(function () {\n            return e.eventMgr.unlisten(t);\n          });\n        }, t.prototype.getDocumentFromLocalCache = function (t) {\n          var e = this;\n          return this.asyncQueue.enqueue(function () {\n            return e.localStore.readDocument(t);\n          }).then(function (t) {\n            if (t instanceof gr) return t;\n            if (t instanceof vr) return null;\n            throw new Sn(En.UNAVAILABLE, \"Failed to get document from cache. (However, this document may exist on the server. Run again without setting 'source' in the GetOptions to attempt to retrieve the document from the server.)\");\n          });\n        }, t.prototype.getDocumentsFromLocalCache = function (i) {\n          var t = this;\n          return this.asyncQueue.enqueue(function () {\n            return t.localStore.executeQuery(i);\n          }).then(function (t) {\n            var e = Fi(),\n                n = new La(i, e),\n                r = n.computeDocChanges(t);\n            return n.applyChanges(r, !1).snapshot;\n          });\n        }, t.prototype.write = function (t) {\n          var e = this,\n              n = new Io();\n          return this.asyncQueue.enqueueAndForget(function () {\n            return e.syncEngine.write(t, n);\n          }), n.promise;\n        }, t.prototype.databaseId = function () {\n          return this.databaseInfo.databaseId;\n        }, t.prototype.transaction = function (t) {\n          var e = this;\n          return this.asyncQueue.enqueue(function () {\n            return h(e, void 0, void 0, function () {\n              return p(this, function (t) {\n                return [2];\n              });\n            });\n          }).then(function () {\n            return e.syncEngine.runTransaction(t);\n          });\n        }, t;\n      }(),\n          nu = function () {\n        function t(t) {\n          this.observer = t, this.muted = !1;\n        }\n\n        return t.prototype.next = function (t) {\n          this.scheduleEvent(this.observer.next, t);\n        }, t.prototype.error = function (t) {\n          this.scheduleEvent(this.observer.error, t);\n        }, t.prototype.mute = function () {\n          this.muted = !0;\n        }, t.prototype.scheduleEvent = function (t, e) {\n          var n = this;\n          this.muted || setTimeout(function () {\n            n.muted || t(e);\n          }, 0);\n        }, t;\n      }(),\n          ru = function () {\n        function e() {\n          for (var t = [], e = 0; e < arguments.length; e++) {\n            t[e] = arguments[e];\n          }\n\n          !function (t, e, n, r) {\n            if (!(e instanceof Array) || e.length < r) throw new Sn(En.INVALID_ARGUMENT, \"Function \" + t + \"() requires its \" + n + \" argument to be an array with at least \" + Gn(r, \"element\") + \".\");\n          }(\"FieldPath\", t, \"fieldNames\", 1);\n\n          for (var n = 0; n < t.length; ++n) {\n            if (On(\"FieldPath\", \"string\", n, t[n]), 0 === t[n].length) throw new Sn(En.INVALID_ARGUMENT, \"Invalid field name at argument $(i + 1). Field names must not be empty.\");\n          }\n\n          this._internalPath = new dr(t);\n        }\n\n        return e.documentId = function () {\n          return e._DOCUMENT_ID;\n        }, e.prototype.isEqual = function (t) {\n          if (!(t instanceof e)) throw jn(\"isEqual\", \"FieldPath\", 1, t);\n          return this._internalPath.isEqual(t._internalPath);\n        }, e._DOCUMENT_ID = new e(dr.keyField().canonicalString()), e;\n      }(),\n          iu = new RegExp(\"[~\\\\*/\\\\[\\\\]]\");\n\n      var ou = function ou(t, e) {\n        this.user = e, this.type = \"OAuth\", this.authHeaders = {\n          Authorization: \"Bearer \" + t\n        };\n      },\n          su = function () {\n        function t() {\n          this.changeListener = null;\n        }\n\n        return t.prototype.getToken = function () {\n          return Promise.resolve(null);\n        }, t.prototype.invalidateToken = function () {}, t.prototype.setChangeListener = function (t) {\n          vn(!this.changeListener, \"Can only call setChangeListener() once.\"), (this.changeListener = t)(Ba.UNAUTHENTICATED);\n        }, t.prototype.removeChangeListener = function () {\n          vn(null !== this.changeListener, \"removeChangeListener() when no listener registered\"), this.changeListener = null;\n        }, t;\n      }(),\n          au = function () {\n        function t(t) {\n          var e = this;\n          this.app = t, this.tokenListener = null, this.tokenCounter = 0, this.changeListener = null, this.forceRefresh = !1, this.tokenListener = function () {\n            e.tokenCounter++, e.currentUser = e.getUser(), e.changeListener && e.changeListener(e.currentUser);\n          }, this.tokenCounter = 0, this.app.INTERNAL.addAuthTokenListener(this.tokenListener);\n        }\n\n        return t.prototype.getToken = function () {\n          var e = this;\n          vn(null != this.tokenListener, \"getToken cannot be called after listener removed.\");\n          var n = this.tokenCounter,\n              t = this.forceRefresh;\n          return this.forceRefresh = !1, this.app.INTERNAL.getToken(t).then(function (t) {\n            if (e.tokenCounter !== n) throw new Sn(En.ABORTED, \"getToken aborted due to token change.\");\n            return t ? (vn(\"string\" == typeof t.accessToken, \"Invalid tokenData returned from getToken():\" + t), new ou(t.accessToken, e.currentUser)) : null;\n          });\n        }, t.prototype.invalidateToken = function () {\n          this.forceRefresh = !0;\n        }, t.prototype.setChangeListener = function (t) {\n          vn(!this.changeListener, \"Can only call setChangeListener() once.\"), this.changeListener = t, this.currentUser && t(this.currentUser);\n        }, t.prototype.removeChangeListener = function () {\n          vn(null != this.tokenListener, \"removeChangeListener() called twice\"), vn(null !== this.changeListener, \"removeChangeListener() called when no listener registered\"), this.app.INTERNAL.removeAuthTokenListener(this.tokenListener), this.tokenListener = null, this.changeListener = null;\n        }, t.prototype.getUser = function () {\n          var t = this.app.INTERNAL.getUid();\n          return vn(null === t || \"string\" == typeof t, \"Received invalid UID: \" + t), new Ba(t);\n        }, t;\n      }(),\n          uu = function () {\n        function t(t, e) {\n          this.gapi = t, this.sessionIndex = e, this.type = \"FirstParty\", this.user = Ba.FIRST_PARTY;\n        }\n\n        return Object.defineProperty(t.prototype, \"authHeaders\", {\n          get: function get() {\n            var t = {\n              \"X-Goog-AuthUser\": this.sessionIndex\n            },\n                e = this.gapi.auth.getAuthHeaderValueForFirstParty([]);\n            return e && (t.Authorization = e), t;\n          },\n          enumerable: !0,\n          configurable: !0\n        }), t;\n      }(),\n          cu = function () {\n        function t(t, e) {\n          this.gapi = t, this.sessionIndex = e;\n        }\n\n        return t.prototype.getToken = function () {\n          return Promise.resolve(new uu(this.gapi, this.sessionIndex));\n        }, t.prototype.setChangeListener = function (t) {\n          t(Ba.FIRST_PARTY);\n        }, t.prototype.removeChangeListener = function () {}, t.prototype.invalidateToken = function () {}, t;\n      }();\n\n      function hu(t) {\n        return function (t, e) {\n          if (\"object\" != typeof t || null === t) return !1;\n\n          for (var n = t, r = 0, i = e; r < i.length; r++) {\n            var o = i[r];\n            if (o in n && \"function\" == typeof n[o]) return !0;\n          }\n\n          return !1;\n        }(t, [\"next\", \"error\", \"complete\"]);\n      }\n\n      var lu,\n          fu,\n          pu = function () {\n        function t(t) {\n          this._methodName = t;\n        }\n\n        return t.delete = function () {\n          return kn(\"FieldValue.delete\", arguments), du.instance;\n        }, t.serverTimestamp = function () {\n          return kn(\"FieldValue.serverTimestamp\", arguments), mu.instance;\n        }, t.arrayUnion = function () {\n          for (var t = [], e = 0; e < arguments.length; e++) {\n            t[e] = arguments[e];\n          }\n\n          return Mn(\"FieldValue.arrayUnion\", arguments, 1), new yu(t);\n        }, t.arrayRemove = function () {\n          for (var t = [], e = 0; e < arguments.length; e++) {\n            t[e] = arguments[e];\n          }\n\n          return Mn(\"FieldValue.arrayRemove\", arguments, 1), new gu(t);\n        }, t.increment = function (t) {\n          return On(\"FieldValue.increment\", \"number\", 1, t), Rn(\"FieldValue.increment\", arguments, 1), new vu(t);\n        }, t.prototype.isEqual = function (t) {\n          return this === t;\n        }, t;\n      }(),\n          du = function (t) {\n        function e() {\n          return t.call(this, \"FieldValue.delete\") || this;\n        }\n\n        return a(e, t), e.instance = new e(), e;\n      }(pu),\n          mu = function (t) {\n        function e() {\n          return t.call(this, \"FieldValue.serverTimestamp\") || this;\n        }\n\n        return a(e, t), e.instance = new e(), e;\n      }(pu),\n          yu = function (n) {\n        function t(t) {\n          var e = n.call(this, \"FieldValue.arrayUnion\") || this;\n          return e._elements = t, e;\n        }\n\n        return a(t, n), t;\n      }(pu),\n          gu = function (n) {\n        function t(t) {\n          var e = n.call(this, \"FieldValue.arrayRemove\") || this;\n          return e._elements = t, e;\n        }\n\n        return a(t, n), t;\n      }(pu),\n          vu = function (n) {\n        function t(t) {\n          var e = n.call(this, \"FieldValue.increment\") || this;\n          return e._operand = t, e;\n        }\n\n        return a(t, n), t;\n      }(pu),\n          bu = Tn(pu, \"Use FieldValue.<field>() instead.\"),\n          wu = /^__.*__$/,\n          Eu = function () {\n        function t(t, e, n) {\n          this.data = t, this.fieldMask = e, this.fieldTransforms = n;\n        }\n\n        return t.prototype.toMutations = function (t, e) {\n          var n = [];\n          return null !== this.fieldMask ? n.push(new gi(t, this.data, this.fieldMask, e)) : n.push(new yi(t, this.data, e)), 0 < this.fieldTransforms.length && n.push(new vi(t, this.fieldTransforms)), n;\n        }, t;\n      }(),\n          Su = function () {\n        function t(t, e, n) {\n          this.data = t, this.fieldMask = e, this.fieldTransforms = n;\n        }\n\n        return t.prototype.toMutations = function (t, e) {\n          var n = [new gi(t, this.data, this.fieldMask, e)];\n          return 0 < this.fieldTransforms.length && n.push(new vi(t, this.fieldTransforms)), n;\n        }, t;\n      }();\n\n      function Tu(t) {\n        switch (t) {\n          case lu.Set:\n          case lu.MergeSet:\n          case lu.Update:\n            return !0;\n\n          case lu.Argument:\n            return !1;\n\n          default:\n            throw gn(\"Unexpected case for UserDataSource: \" + t);\n        }\n      }\n\n      (fu = lu || (lu = {}))[fu.Set = 0] = \"Set\", fu[fu.Update = 1] = \"Update\", fu[fu.MergeSet = 2] = \"MergeSet\", fu[fu.Argument = 3] = \"Argument\";\n\n      var Iu = function () {\n        function r(t, e, n, r, i, o) {\n          this.dataSource = t, this.methodName = e, this.path = n, this.arrayElement = r, void 0 === i && this.validatePath(), this.arrayElement = void 0 !== r && r, this.fieldTransforms = i || [], this.fieldMask = o || [];\n        }\n\n        return r.prototype.childContextForField = function (t) {\n          var e = null == this.path ? null : this.path.child(t),\n              n = new r(this.dataSource, this.methodName, e, !1, this.fieldTransforms, this.fieldMask);\n          return n.validatePathSegment(t), n;\n        }, r.prototype.childContextForFieldPath = function (t) {\n          var e = null == this.path ? null : this.path.child(t),\n              n = new r(this.dataSource, this.methodName, e, !1, this.fieldTransforms, this.fieldMask);\n          return n.validatePath(), n;\n        }, r.prototype.childContextForArray = function (t) {\n          return new r(this.dataSource, this.methodName, null, !0, this.fieldTransforms, this.fieldMask);\n        }, r.prototype.createError = function (t) {\n          var e = null === this.path || this.path.isEmpty() ? \"\" : \" (found in field \" + this.path.toString() + \")\";\n          return new Sn(En.INVALID_ARGUMENT, \"Function \" + this.methodName + \"() called with invalid data. \" + t + e);\n        }, r.prototype.contains = function (e) {\n          return void 0 !== this.fieldMask.find(function (t) {\n            return e.isPrefixOf(t);\n          }) || void 0 !== this.fieldTransforms.find(function (t) {\n            return e.isPrefixOf(t.field);\n          });\n        }, r.prototype.validatePath = function () {\n          if (null !== this.path) for (var t = 0; t < this.path.length; t++) {\n            this.validatePathSegment(this.path.get(t));\n          }\n        }, r.prototype.validatePathSegment = function (t) {\n          if (Tu(this.dataSource) && wu.test(t)) throw this.createError(\"Document fields cannot begin and end with __\");\n        }, r;\n      }(),\n          Cu = function Cu(t, e) {\n        this.databaseId = t, this.key = e;\n      },\n          Du = function () {\n        function t(t) {\n          this.preConverter = t;\n        }\n\n        return t.prototype.parseSetData = function (t, e) {\n          var n = new Iu(lu.Set, t, dr.EMPTY_PATH);\n          Au(\"Data must be an object, but it was:\", n, e);\n          var r = this.parseData(e, n);\n          return new Eu(r, null, n.fieldTransforms);\n        }, t.prototype.parseMergeData = function (t, e, n) {\n          var r = new Iu(lu.MergeSet, t, dr.EMPTY_PATH);\n          Au(\"Data must be an object, but it was:\", r, e);\n          var i,\n              o,\n              s = this.parseData(e, r);\n\n          if (n) {\n            for (var a = new ci(dr.comparator), u = 0, c = n; u < c.length; u++) {\n              var h = c[u],\n                  l = void 0;\n              if (h instanceof ru) l = h._internalPath;else {\n                if (\"string\" != typeof h) throw gn(\"Expected stringOrFieldPath to be a string or a FieldPath\");\n                l = Ru(t, h);\n              }\n              if (!r.contains(l)) throw new Sn(En.INVALID_ARGUMENT, \"Field '\" + l + \"' is specified in your field mask but missing from your input data.\");\n              a = a.add(l);\n            }\n\n            i = li.fromSet(a), o = r.fieldTransforms.filter(function (t) {\n              return i.covers(t.field);\n            });\n          } else i = li.fromArray(r.fieldMask), o = r.fieldTransforms;\n\n          return new Eu(s, i, o);\n        }, t.prototype.parseUpdateData = function (o, t) {\n          var s = this,\n              a = new Iu(lu.Update, o, dr.EMPTY_PATH);\n          Au(\"Data must be an object, but it was:\", a, t);\n          var u = new ci(dr.comparator),\n              c = Fr.EMPTY;\n          Nn(t, function (t, e) {\n            var n = Ru(o, t),\n                r = a.childContextForFieldPath(n);\n            if ((e = s.runPreConverter(e, r)) instanceof du) u = u.add(n);else {\n              var i = s.parseData(e, r);\n              null != i && (u = u.add(n), c = c.set(n, i));\n            }\n          });\n          var e = li.fromSet(u);\n          return new Su(c, e, a.fieldTransforms);\n        }, t.prototype.parseUpdateVarargs = function (t, e, n, r) {\n          var i = new Iu(lu.Update, t, dr.EMPTY_PATH),\n              o = [ku(t, e)],\n              s = [n];\n          if (r.length % 2 != 0) throw new Sn(En.INVALID_ARGUMENT, \"Function \" + t + \"() needs to be called with an even number of arguments that alternate between field names and values.\");\n\n          for (var a = 0; a < r.length; a += 2) {\n            o.push(ku(t, r[a])), s.push(r[a + 1]);\n          }\n\n          var u = new ci(dr.comparator),\n              c = Fr.EMPTY;\n\n          for (a = 0; a < o.length; ++a) {\n            var h = o[a],\n                l = i.childContextForFieldPath(h),\n                f = this.runPreConverter(s[a], l);\n            if (f instanceof du) u = u.add(h);else {\n              var p = this.parseData(f, l);\n              null != p && (u = u.add(h), c = c.set(h, p));\n            }\n          }\n\n          var d = li.fromSet(u);\n          return new Su(c, d, i.fieldTransforms);\n        }, t.prototype.parseQueryValue = function (t, e) {\n          var n = new Iu(lu.Argument, t, dr.EMPTY_PATH),\n              r = this.parseData(e, n);\n          return vn(null != r, \"Parsed data should not be null.\"), vn(0 === n.fieldTransforms.length, \"Field transforms should have been disallowed.\"), r;\n        }, t.prototype.runPreConverter = function (t, e) {\n          try {\n            return this.preConverter(t);\n          } catch (t) {\n            var n = Mu(t);\n            throw e.createError(n);\n          }\n        }, t.prototype.parseData = function (t, e) {\n          if (Nu(t = this.runPreConverter(t, e))) return Au(\"Unsupported field value:\", e, t), this.parseObject(t, e);\n          if (t instanceof pu) return this.parseSentinelFieldValue(t, e), null;\n\n          if (e.path && e.fieldMask.push(e.path), t instanceof Array) {\n            if (e.arrayElement) throw e.createError(\"Nested arrays are not supported\");\n            return this.parseArray(t, e);\n          }\n\n          return this.parseScalarValue(t, e);\n        }, t.prototype.parseObject = function (t, r) {\n          var i = this,\n              o = new wr(Hn);\n          return An(t) ? r.path && 0 < r.path.length && r.fieldMask.push(r.path) : Nn(t, function (t, e) {\n            var n = i.parseData(e, r.childContextForField(t));\n            null != n && (o = o.insert(t, n));\n          }), new Fr(o);\n        }, t.prototype.parseArray = function (t, e) {\n          for (var n = [], r = 0, i = 0, o = t; i < o.length; i++) {\n            var s = o[i],\n                a = this.parseData(s, e.childContextForArray(r));\n            null == a && (a = Dr.INSTANCE), n.push(a), r++;\n          }\n\n          return new Vr(n);\n        }, t.prototype.parseSentinelFieldValue = function (t, e) {\n          if (!Tu(e.dataSource)) throw e.createError(t._methodName + \"() can only be used with update() and set()\");\n          if (null === e.path) throw e.createError(t._methodName + \"() is not currently supported inside arrays\");\n\n          if (t instanceof du) {\n            if (e.dataSource !== lu.MergeSet) throw e.dataSource === lu.Update ? (vn(0 < e.path.length, \"FieldValue.delete() at the top level should have already been handled.\"), e.createError(\"FieldValue.delete() can only appear at the top level of your update data\")) : e.createError(\"FieldValue.delete() cannot be used with set() unless you pass {merge:true}\");\n            e.fieldMask.push(e.path);\n          } else if (t instanceof mu) e.fieldTransforms.push(new fi(e.path, wi.instance));else if (t instanceof yu) {\n            var n = this.parseArrayTransformElements(t._methodName, t._elements),\n                r = new Ei(n);\n            e.fieldTransforms.push(new fi(e.path, r));\n          } else if (t instanceof gu) {\n            n = this.parseArrayTransformElements(t._methodName, t._elements);\n            var i = new Si(n);\n            e.fieldTransforms.push(new fi(e.path, i));\n          } else if (t instanceof vu) {\n            var o = this.parseQueryValue(\"FieldValue.increment\", t._operand),\n                s = new Ti(o);\n            e.fieldTransforms.push(new fi(e.path, s));\n          } else gn(\"Unknown FieldValue type: \" + t);\n        }, t.prototype.parseScalarValue = function (t, e) {\n          if (null === t) return Dr.INSTANCE;\n          if (\"number\" == typeof t) return Wr(t) ? new Rr(t) : new Mr(t);\n          if (\"boolean\" == typeof t) return Nr.of(t);\n          if (\"string\" == typeof t) return new _r(t);\n          if (t instanceof Date) return new Or(sr.fromDate(t));\n          if (t instanceof sr) return new Or(new sr(t.seconds, 1e3 * Math.floor(t.nanoseconds / 1e3)));\n          if (t instanceof or) return new qr(t);\n          if (t instanceof rr) return new Lr(t);\n          if (t instanceof Cu) return new xr(t.databaseId, t.key);\n          throw e.createError(\"Unsupported field value: \" + Un(t));\n        }, t.prototype.parseArrayTransformElements = function (r, t) {\n          var i = this;\n          return t.map(function (t, e) {\n            var n = new Iu(lu.Argument, r, dr.EMPTY_PATH);\n            return i.parseData(t, n.childContextForArray(e));\n          });\n        }, t;\n      }();\n\n      function Nu(t) {\n        return !(\"object\" != typeof t || null === t || t instanceof Array || t instanceof Date || t instanceof sr || t instanceof or || t instanceof rr || t instanceof Cu || t instanceof pu);\n      }\n\n      function Au(t, e, n) {\n        if (!Nu(n) || !Bn(n)) {\n          var r = Un(n);\n          throw \"an object\" === r ? e.createError(t + \" a custom object\") : e.createError(t + \" \" + r);\n        }\n      }\n\n      function ku(t, e) {\n        if (e instanceof ru) return e._internalPath;\n        if (\"string\" == typeof e) return Ru(t, e);\n        throw new Sn(En.INVALID_ARGUMENT, \"Function \" + t + \"() called with invalid data. Field path arguments must be of type string or FieldPath.\");\n      }\n\n      function Ru(e, t) {\n        try {\n          return function (e) {\n            if (0 <= e.search(iu)) throw new Sn(En.INVALID_ARGUMENT, \"Invalid field path (\" + e + \"). Paths must not contain '~', '*', '/', '[', or ']'\");\n\n            try {\n              return new (ru.bind.apply(ru, [void 0].concat(e.split(\".\"))))();\n            } catch (t) {\n              throw new Sn(En.INVALID_ARGUMENT, \"Invalid field path (\" + e + \"). Paths must not be empty, begin with '.', end with '.', or contain '..'\");\n            }\n          }(t)._internalPath;\n        } catch (t) {\n          var n = Mu(t);\n          throw new Sn(En.INVALID_ARGUMENT, \"Function \" + e + \"() called with invalid data. \" + n);\n        }\n      }\n\n      function Mu(t) {\n        return t instanceof Error ? t.message : t.toString();\n      }\n\n      var _u = Qs.COLLECTION_DISABLED,\n          Ou = function () {\n        function t(t) {\n          if (void 0 === t.host) {\n            if (void 0 !== t.ssl) throw new Sn(En.INVALID_ARGUMENT, \"Can't provide ssl option if host option is not set\");\n            this.host = \"firestore.googleapis.com\", this.ssl = !0;\n          } else Ln(\"settings\", \"non-empty string\", \"host\", t.host), this.host = t.host, xn(\"settings\", \"boolean\", \"ssl\", t.ssl), this.ssl = Cn(t.ssl, !0);\n\n          if (Kn(\"settings\", t, [\"host\", \"ssl\", \"credentials\", \"timestampsInSnapshots\", \"cacheSizeBytes\"]), xn(\"settings\", \"object\", \"credentials\", t.credentials), this.credentials = t.credentials, xn(\"settings\", \"boolean\", \"timestampsInSnapshots\", t.timestampsInSnapshots), !0 === t.timestampsInSnapshots ? mn(\"\\n  The timestampsInSnapshots setting now defaults to true and you no\\n  longer need to explicitly set it. In a future release, the setting\\n  will be removed entirely and so it is recommended that you remove it\\n  from your firestore.settings() call now.\") : !1 === t.timestampsInSnapshots && mn(\"\\n  The timestampsInSnapshots setting will soon be removed. YOU MUST UPDATE\\n  YOUR CODE.\\n\\n  To hide this warning, stop using the timestampsInSnapshots setting in your\\n  firestore.settings({ ... }) call.\\n\\n  Once you remove the setting, Timestamps stored in Cloud Firestore will be\\n  read back as Firebase Timestamp objects instead of as system Date objects.\\n  So you will also need to update code expecting a Date to instead expect a\\n  Timestamp. For example:\\n\\n  // Old:\\n  const date = snapshot.get('created_at');\\n  // New:\\n  const timestamp = snapshot.get('created_at'); const date =\\n  timestamp.toDate();\\n\\n  Please audit all existing usages of Date when you enable the new\\n  behavior.\"), this.timestampsInSnapshots = Cn(t.timestampsInSnapshots, !0), xn(\"settings\", \"number\", \"cacheSizeBytes\", t.cacheSizeBytes), void 0 === t.cacheSizeBytes) this.cacheSizeBytes = Qs.DEFAULT_CACHE_SIZE_BYTES;else {\n            if (t.cacheSizeBytes !== _u && t.cacheSizeBytes < Qs.MINIMUM_CACHE_SIZE_BYTES) throw new Sn(En.INVALID_ARGUMENT, \"cacheSizeBytes must be at least \" + Qs.MINIMUM_CACHE_SIZE_BYTES);\n            this.cacheSizeBytes = t.cacheSizeBytes;\n          }\n        }\n\n        return t.prototype.isEqual = function (t) {\n          return this.host === t.host && this.ssl === t.ssl && this.timestampsInSnapshots === t.timestampsInSnapshots && this.credentials === t.credentials && this.cacheSizeBytes === t.cacheSizeBytes;\n        }, t;\n      }(),\n          Pu = function Pu() {},\n          Lu = function () {\n        function o(t) {\n          var n = this;\n          this._queue = new Do(), this.INTERNAL = {\n            delete: function _delete(e) {\n              return h(n, void 0, void 0, function () {\n                return p(this, function (t) {\n                  return this._firestoreClient ? [2, this._firestoreClient.shutdown(e)] : [2];\n                });\n              });\n            }\n          };\n          var e = new Pu();\n\n          if (\"object\" == typeof t.options) {\n            var r = t;\n            e.firebaseApp = r, e.databaseId = o.databaseIdFromApp(r), e.persistenceKey = e.firebaseApp.name, e.credentials = new au(r);\n          } else {\n            var i = t;\n            if (!i.projectId) throw new Sn(En.INVALID_ARGUMENT, \"Must provide projectId\");\n            e.databaseId = new cr(i.projectId, i.database), e.persistenceKey = \"[DEFAULT]\", e.credentials = new su();\n          }\n\n          e.settings = new Ou({}), this._config = e, this._databaseId = e.databaseId;\n        }\n\n        return o.prototype.settings = function (t) {\n          if (Rn(\"Firestore.settings\", arguments, 1), On(\"Firestore.settings\", \"object\", 1, t), In(t, \"persistence\")) throw new Sn(En.INVALID_ARGUMENT, '\"persistence\" is now specified with a separate call to firestore.enablePersistence().');\n          var e = new Ou(t);\n          if (this._firestoreClient && !this._config.settings.isEqual(e)) throw new Sn(En.FAILED_PRECONDITION, \"Firestore has already been started and its settings can no longer be changed. You can only call settings() before calling any other methods on a Firestore object.\");\n          void 0 !== (this._config.settings = e).credentials && (this._config.credentials = function (t) {\n            if (!t) return new su();\n\n            switch (t.type) {\n              case \"gapi\":\n                var e = t.client;\n                return vn(!(\"object\" != typeof e || null === e || !e.auth || !e.auth.getAuthHeaderValueForFirstParty), \"unexpected gapi interface\"), new cu(e, t.sessionIndex || \"0\");\n\n              case \"provider\":\n                return t.client;\n\n              default:\n                throw new Sn(En.INVALID_ARGUMENT, \"makeCredentialsProvider failed due to invalid credential type\");\n            }\n          }(e.credentials));\n        }, o.prototype.enableNetwork = function () {\n          return this.ensureClientConfigured(), this._firestoreClient.enableNetwork();\n        }, o.prototype.disableNetwork = function () {\n          return this.ensureClientConfigured(), this._firestoreClient.disableNetwork();\n        }, o.prototype.enablePersistence = function (t) {\n          if (this._firestoreClient) throw new Sn(En.FAILED_PRECONDITION, \"Firestore has already been started and persistence can no longer be enabled. You can only call enablePersistence() before calling any other methods on a Firestore object.\");\n          return this.configureClient(new Za(this._config.settings.cacheSizeBytes, void 0 !== t && Cn(t.experimentalTabSynchronization, !1)));\n        }, o.prototype.ensureClientConfigured = function () {\n          return this._firestoreClient || this.configureClient(new tu()), this._firestoreClient;\n        }, o.prototype.configureClient = function (t) {\n          var r = this;\n          vn(!!this._config.settings.host, \"FirestoreSettings.host cannot be falsey\"), vn(!this._firestoreClient, \"configureClient() called multiple times\");\n          var e = new ar(this._config.databaseId, this._config.persistenceKey, this._config.settings.host, this._config.settings.ssl);\n          return this._dataConverter = new Du(function (t) {\n            if (t instanceof Fu) {\n              var e = r._config.databaseId,\n                  n = t.firestore._config.databaseId;\n              if (!n.isEqual(e)) throw new Sn(En.INVALID_ARGUMENT, \"Document reference is for database \" + n.projectId + \"/\" + n.database + \" but should be for database \" + e.projectId + \"/\" + e.database);\n              return new Cu(r._config.databaseId, t._key);\n            }\n\n            return t;\n          }), this._firestoreClient = new eu(bn.getPlatform(), e, this._config.credentials, this._queue), this._firestoreClient.start(t);\n        }, o.databaseIdFromApp = function (t) {\n          var e = t.options;\n          if (!In(e, \"projectId\")) throw new Sn(En.INVALID_ARGUMENT, '\"projectId\" not provided in firebase.initializeApp.');\n          var n = e.projectId;\n          if (!n || \"string\" != typeof n) throw new Sn(En.INVALID_ARGUMENT, \"projectId must be a string in FirebaseApp.options\");\n          return new cr(n);\n        }, Object.defineProperty(o.prototype, \"app\", {\n          get: function get() {\n            if (!this._config.firebaseApp) throw new Sn(En.FAILED_PRECONDITION, \"Firestore was not initialized using the Firebase SDK. 'app' is not available\");\n            return this._config.firebaseApp;\n          },\n          enumerable: !0,\n          configurable: !0\n        }), o.prototype.collection = function (t) {\n          return Rn(\"Firestore.collection\", arguments, 1), On(\"Firestore.collection\", \"non-empty string\", 1, t), this.ensureClientConfigured(), new ju(fr.fromString(t), this);\n        }, o.prototype.doc = function (t) {\n          return Rn(\"Firestore.doc\", arguments, 1), On(\"Firestore.doc\", \"non-empty string\", 1, t), this.ensureClientConfigured(), Fu.forPath(fr.fromString(t), this);\n        }, o.prototype._collectionGroup = function (t) {\n          if (Rn(\"Firestore.collectionGroup\", arguments, 1), On(\"Firestore.collectionGroup\", \"non-empty string\", 1, t), 0 <= t.indexOf(\"/\")) throw new Sn(En.INVALID_ARGUMENT, \"Invalid collection ID '\" + t + \"' passed to function Firestore.collectionGroup(). Collection IDs must not contain '/'.\");\n          return this.ensureClientConfigured(), new Qu(new Hr(fr.EMPTY_PATH, t), this);\n        }, o.prototype.runTransaction = function (e) {\n          var n = this;\n          return Rn(\"Firestore.runTransaction\", arguments, 1), On(\"Firestore.runTransaction\", \"function\", 1, e), this.ensureClientConfigured().transaction(function (t) {\n            return e(new xu(n, t));\n          });\n        }, o.prototype.batch = function () {\n          return this.ensureClientConfigured(), new qu(this);\n        }, Object.defineProperty(o, \"logLevel\", {\n          get: function get() {\n            switch (fn()) {\n              case an.DEBUG:\n                return \"debug\";\n\n              case an.ERROR:\n                return \"error\";\n\n              case an.SILENT:\n                return \"silent\";\n\n              default:\n                return gn(\"Unknown log level: \" + fn());\n            }\n          },\n          enumerable: !0,\n          configurable: !0\n        }), o.setLogLevel = function (t) {\n          switch (Rn(\"Firestore.setLogLevel\", arguments, 1), On(\"Firestore.setLogLevel\", \"non-empty string\", 1, t), t) {\n            case \"debug\":\n              pn(an.DEBUG);\n              break;\n\n            case \"error\":\n              pn(an.ERROR);\n              break;\n\n            case \"silent\":\n              pn(an.SILENT);\n              break;\n\n            default:\n              throw new Sn(En.INVALID_ARGUMENT, \"Invalid log level: \" + t);\n          }\n        }, o.prototype._areTimestampsInSnapshotsEnabled = function () {\n          return this._config.settings.timestampsInSnapshots;\n        }, o;\n      }(),\n          xu = function () {\n        function t(t, e) {\n          this._firestore = t, this._transaction = e;\n        }\n\n        return t.prototype.get = function (t) {\n          var n = this;\n          Rn(\"Transaction.get\", arguments, 1);\n          var r = Hu(\"Transaction.get\", t, this._firestore);\n          return this._transaction.lookup([r._key]).then(function (t) {\n            if (!t || 1 !== t.length) return gn(\"Mismatch in docs returned from document lookup.\");\n            var e = t[0];\n            if (e instanceof vr) return new Bu(n._firestore, r._key, null, !1, !1);\n            if (e instanceof gr) return new Bu(n._firestore, r._key, e, !1, !1);\n            throw gn(\"BatchGetDocumentsRequest returned unexpected document type: \" + e.constructor.name);\n          });\n        }, t.prototype.set = function (t, e, n) {\n          _n(\"Transaction.set\", arguments, 2, 3);\n\n          var r = Hu(\"Transaction.set\", t, this._firestore),\n              i = (n = Wu(\"Transaction.set\", n)).merge || n.mergeFields ? this._firestore._dataConverter.parseMergeData(\"Transaction.set\", e, n.mergeFields) : this._firestore._dataConverter.parseSetData(\"Transaction.set\", e);\n          return this._transaction.set(r._key, i), this;\n        }, t.prototype.update = function (t, e, n) {\n          for (var r, i, o = [], s = 3; s < arguments.length; s++) {\n            o[s - 3] = arguments[s];\n          }\n\n          return i = \"string\" == typeof e || e instanceof ru ? (Mn(\"Transaction.update\", arguments, 3), r = Hu(\"Transaction.update\", t, this._firestore), this._firestore._dataConverter.parseUpdateVarargs(\"Transaction.update\", e, n, o)) : (Rn(\"Transaction.update\", arguments, 2), r = Hu(\"Transaction.update\", t, this._firestore), this._firestore._dataConverter.parseUpdateData(\"Transaction.update\", e)), this._transaction.update(r._key, i), this;\n        }, t.prototype.delete = function (t) {\n          Rn(\"Transaction.delete\", arguments, 1);\n          var e = Hu(\"Transaction.delete\", t, this._firestore);\n          return this._transaction.delete(e._key), this;\n        }, t;\n      }(),\n          qu = function () {\n        function t(t) {\n          this._firestore = t, this._mutations = [], this._committed = !1;\n        }\n\n        return t.prototype.set = function (t, e, n) {\n          _n(\"WriteBatch.set\", arguments, 2, 3), this.verifyNotCommitted();\n          var r = Hu(\"WriteBatch.set\", t, this._firestore),\n              i = (n = Wu(\"WriteBatch.set\", n)).merge || n.mergeFields ? this._firestore._dataConverter.parseMergeData(\"WriteBatch.set\", e, n.mergeFields) : this._firestore._dataConverter.parseSetData(\"WriteBatch.set\", e);\n          return this._mutations = this._mutations.concat(i.toMutations(r._key, di.NONE)), this;\n        }, t.prototype.update = function (t, e, n) {\n          for (var r, i, o = [], s = 3; s < arguments.length; s++) {\n            o[s - 3] = arguments[s];\n          }\n\n          return this.verifyNotCommitted(), i = \"string\" == typeof e || e instanceof ru ? (Mn(\"WriteBatch.update\", arguments, 3), r = Hu(\"WriteBatch.update\", t, this._firestore), this._firestore._dataConverter.parseUpdateVarargs(\"WriteBatch.update\", e, n, o)) : (Rn(\"WriteBatch.update\", arguments, 2), r = Hu(\"WriteBatch.update\", t, this._firestore), this._firestore._dataConverter.parseUpdateData(\"WriteBatch.update\", e)), this._mutations = this._mutations.concat(i.toMutations(r._key, di.exists(!0))), this;\n        }, t.prototype.delete = function (t) {\n          Rn(\"WriteBatch.delete\", arguments, 1), this.verifyNotCommitted();\n          var e = Hu(\"WriteBatch.delete\", t, this._firestore);\n          return this._mutations = this._mutations.concat(new bi(e._key, di.NONE)), this;\n        }, t.prototype.commit = function () {\n          return h(this, void 0, void 0, function () {\n            return p(this, function (t) {\n              return this.verifyNotCommitted(), this._committed = !0, 0 < this._mutations.length ? [2, this._firestore.ensureClientConfigured().write(this._mutations)] : [2];\n            });\n          });\n        }, t.prototype.verifyNotCommitted = function () {\n          if (this._committed) throw new Sn(En.FAILED_PRECONDITION, \"A write batch can no longer be used after commit() has been called.\");\n        }, t;\n      }(),\n          Fu = function () {\n        function n(t, e) {\n          this._key = t, this.firestore = e, this._firestoreClient = this.firestore.ensureClientConfigured();\n        }\n\n        return n.forPath = function (t, e) {\n          if (t.length % 2 != 0) throw new Sn(En.INVALID_ARGUMENT, \"Invalid document reference. Document references must have an even number of segments, but \" + t.canonicalString() + \" has \" + t.length);\n          return new n(new mr(t), e);\n        }, Object.defineProperty(n.prototype, \"id\", {\n          get: function get() {\n            return this._key.path.lastSegment();\n          },\n          enumerable: !0,\n          configurable: !0\n        }), Object.defineProperty(n.prototype, \"parent\", {\n          get: function get() {\n            return new ju(this._key.path.popLast(), this.firestore);\n          },\n          enumerable: !0,\n          configurable: !0\n        }), Object.defineProperty(n.prototype, \"path\", {\n          get: function get() {\n            return this._key.path.canonicalString();\n          },\n          enumerable: !0,\n          configurable: !0\n        }), n.prototype.collection = function (t) {\n          if (Rn(\"DocumentReference.collection\", arguments, 1), On(\"DocumentReference.collection\", \"non-empty string\", 1, t), !t) throw new Sn(En.INVALID_ARGUMENT, \"Must provide a non-empty collection name to collection()\");\n          var e = fr.fromString(t);\n          return new ju(this._key.path.child(e), this.firestore);\n        }, n.prototype.isEqual = function (t) {\n          if (!(t instanceof n)) throw jn(\"isEqual\", \"DocumentReference\", 1, t);\n          return this.firestore === t.firestore && this._key.isEqual(t._key);\n        }, n.prototype.set = function (t, e) {\n          _n(\"DocumentReference.set\", arguments, 1, 2);\n\n          var n = (e = Wu(\"DocumentReference.set\", e)).merge || e.mergeFields ? this.firestore._dataConverter.parseMergeData(\"DocumentReference.set\", t, e.mergeFields) : this.firestore._dataConverter.parseSetData(\"DocumentReference.set\", t);\n          return this._firestoreClient.write(n.toMutations(this._key, di.NONE));\n        }, n.prototype.update = function (t, e) {\n          for (var n, r = [], i = 2; i < arguments.length; i++) {\n            r[i - 2] = arguments[i];\n          }\n\n          return n = \"string\" == typeof t || t instanceof ru ? (Mn(\"DocumentReference.update\", arguments, 2), this.firestore._dataConverter.parseUpdateVarargs(\"DocumentReference.update\", t, e, r)) : (Rn(\"DocumentReference.update\", arguments, 1), this.firestore._dataConverter.parseUpdateData(\"DocumentReference.update\", t)), this._firestoreClient.write(n.toMutations(this._key, di.exists(!0)));\n        }, n.prototype.delete = function () {\n          return Rn(\"DocumentReference.delete\", arguments, 0), this._firestoreClient.write([new bi(this._key, di.NONE)]);\n        }, n.prototype.onSnapshot = function () {\n          for (var t = [], e = 0; e < arguments.length; e++) {\n            t[e] = arguments[e];\n          }\n\n          _n(\"DocumentReference.onSnapshot\", arguments, 1, 4);\n\n          var n,\n              r = {\n            includeMetadataChanges: !1\n          },\n              i = 0;\n          \"object\" != typeof t[i] || hu(t[i]) || (Kn(\"DocumentReference.onSnapshot\", r = t[i], [\"includeMetadataChanges\"]), xn(\"DocumentReference.onSnapshot\", \"boolean\", \"includeMetadataChanges\", r.includeMetadataChanges), i++);\n          var o = {\n            includeMetadataChanges: r.includeMetadataChanges\n          };\n          return n = hu(t[i]) ? t[i] : (On(\"DocumentReference.onSnapshot\", \"function\", i, t[i]), Pn(\"DocumentReference.onSnapshot\", \"function\", i + 1, t[i + 1]), Pn(\"DocumentReference.onSnapshot\", \"function\", i + 2, t[i + 2]), {\n            next: t[i],\n            error: t[i + 1],\n            complete: t[i + 2]\n          }), this.onSnapshotInternal(o, n);\n        }, n.prototype.onSnapshotInternal = function (t, n) {\n          var r = this,\n              e = function e(t) {\n            console.error(\"Uncaught Error in onSnapshot:\", t);\n          };\n\n          n.error && (e = n.error.bind(n));\n\n          var i = new nu({\n            next: function next(t) {\n              if (n.next) {\n                vn(t.docs.size <= 1, \"Too many documents returned on a document query\");\n                var e = t.docs.get(r._key);\n                n.next(new Bu(r.firestore, r._key, e, t.fromCache, t.hasPendingWrites));\n              }\n            },\n            error: e\n          }),\n              o = this._firestoreClient.listen(Hr.atPath(this._key.path), i, t);\n\n          return function () {\n            i.mute(), r._firestoreClient.unlisten(o);\n          };\n        }, n.prototype.get = function (n) {\n          var r = this;\n          return _n(\"DocumentReference.get\", arguments, 0, 1), zu(\"DocumentReference.get\", n), new Promise(function (e, t) {\n            n && \"cache\" === n.source ? r.firestore.ensureClientConfigured().getDocumentFromLocalCache(r._key).then(function (t) {\n              e(new Bu(r.firestore, r._key, t, !0, t instanceof gr && t.hasLocalMutations));\n            }, t) : r.getViaSnapshotListener(e, t, n);\n          });\n        }, n.prototype.getViaSnapshotListener = function (e, n, r) {\n          var i = this.onSnapshotInternal({\n            includeMetadataChanges: !0,\n            waitForSyncWhenOnline: !0\n          }, {\n            next: function next(t) {\n              i(), !t.exists && t.metadata.fromCache ? n(new Sn(En.UNAVAILABLE, \"Failed to get document because the client is offline.\")) : t.exists && t.metadata.fromCache && r && \"server\" === r.source ? n(new Sn(En.UNAVAILABLE, 'Failed to get document from server. (However, this document does exist in the local cache. Run again without setting source to \"server\" to retrieve the cached document.)')) : e(t);\n            },\n            error: n\n          });\n        }, n;\n      }(),\n          Vu = function () {\n        function t(t, e) {\n          this.hasPendingWrites = t, this.fromCache = e;\n        }\n\n        return t.prototype.isEqual = function (t) {\n          return this.hasPendingWrites === t.hasPendingWrites && this.fromCache === t.fromCache;\n        }, t;\n      }(),\n          Bu = function () {\n        function e(t, e, n, r, i) {\n          this._firestore = t, this._key = e, this._document = n, this._fromCache = r, this._hasPendingWrites = i;\n        }\n\n        return e.prototype.data = function (t) {\n          return _n(\"DocumentSnapshot.data\", arguments, 0, 1), t = Gu(\"DocumentSnapshot.data\", t), this._document ? this.convertObject(this._document.data, Ir.fromSnapshotOptions(t, this._firestore._areTimestampsInSnapshotsEnabled())) : void 0;\n        }, e.prototype.get = function (t, e) {\n          if (_n(\"DocumentSnapshot.get\", arguments, 1, 2), e = Gu(\"DocumentSnapshot.get\", e), this._document) {\n            var n = this._document.data.field(ku(\"DocumentSnapshot.get\", t));\n\n            if (void 0 !== n) return this.convertValue(n, Ir.fromSnapshotOptions(e, this._firestore._areTimestampsInSnapshotsEnabled()));\n          }\n        }, Object.defineProperty(e.prototype, \"id\", {\n          get: function get() {\n            return this._key.path.lastSegment();\n          },\n          enumerable: !0,\n          configurable: !0\n        }), Object.defineProperty(e.prototype, \"ref\", {\n          get: function get() {\n            return new Fu(this._key, this._firestore);\n          },\n          enumerable: !0,\n          configurable: !0\n        }), Object.defineProperty(e.prototype, \"exists\", {\n          get: function get() {\n            return null !== this._document;\n          },\n          enumerable: !0,\n          configurable: !0\n        }), Object.defineProperty(e.prototype, \"metadata\", {\n          get: function get() {\n            return new Vu(this._hasPendingWrites, this._fromCache);\n          },\n          enumerable: !0,\n          configurable: !0\n        }), e.prototype.isEqual = function (t) {\n          if (!(t instanceof e)) throw jn(\"isEqual\", \"DocumentSnapshot\", 1, t);\n          return this._firestore === t._firestore && this._fromCache === t._fromCache && this._key.isEqual(t._key) && (null === this._document ? null === t._document : this._document.isEqual(t._document));\n        }, e.prototype.convertObject = function (t, n) {\n          var r = this,\n              i = {};\n          return t.forEach(function (t, e) {\n            i[t] = r.convertValue(e, n);\n          }), i;\n        }, e.prototype.convertValue = function (t, e) {\n          if (t instanceof Fr) return this.convertObject(t, e);\n          if (t instanceof Vr) return this.convertArray(t, e);\n\n          if (t instanceof xr) {\n            var n = t.value(e),\n                r = this._firestore.ensureClientConfigured().databaseId();\n\n            return t.databaseId.isEqual(r) || mn(\"Document \" + this._key.path + \" contains a document reference within a different database (\" + t.databaseId.projectId + \"/\" + t.databaseId.database + \") which is not supported. It will be treated as a reference in the current database (\" + r.projectId + \"/\" + r.database + \") instead.\"), new Fu(n, this._firestore);\n          }\n\n          return t.value(e);\n        }, e.prototype.convertArray = function (t, e) {\n          var n = this;\n          return t.internalValue.map(function (t) {\n            return n.convertValue(t, e);\n          });\n        }, e;\n      }(),\n          Uu = function (o) {\n        function t(t, e, n, r, i) {\n          return o.call(this, t, e, n, r, i) || this;\n        }\n\n        return a(t, o), t.prototype.data = function (t) {\n          var e = o.prototype.data.call(this, t);\n          return vn(\"object\" == typeof e, \"Document in a QueryDocumentSnapshot should exist\"), e;\n        }, t;\n      }(Bu),\n          Qu = function () {\n        function c(t, e) {\n          this._query = t, this.firestore = e;\n        }\n\n        return c.prototype.where = function (t, e, n) {\n          var r;\n          Rn(\"Query.where\", arguments, 3), On(\"Query.where\", \"non-empty string\", 2, e), Qn(\"Query.where\", 3, n);\n          var i = ku(\"Query.where\", t),\n              o = Xr.fromString(e);\n\n          if (i.isKeyField()) {\n            if (o === Xr.ARRAY_CONTAINS) throw new Sn(En.INVALID_ARGUMENT, \"Invalid Query. You can't perform array-contains queries on FieldPath.documentId() since document IDs are not arrays.\");\n\n            if (\"string\" == typeof n) {\n              if (\"\" === n) throw new Sn(En.INVALID_ARGUMENT, \"Function Query.where() requires its third parameter to be a valid document ID if the first parameter is FieldPath.documentId(), but it was an empty string.\");\n              if (!this._query.isCollectionGroupQuery() && -1 !== n.indexOf(\"/\")) throw new Sn(En.INVALID_ARGUMENT, \"Invalid third parameter to Query.where(). When querying a collection by FieldPath.documentId(), the value provided must be a plain document ID, but '\" + n + \"' contains a slash.\");\n\n              var s = this._query.path.child(fr.fromString(n));\n\n              if (!mr.isDocumentKey(s)) throw new Sn(En.INVALID_ARGUMENT, \"Invalid third parameter to Query.where(). When querying a collection group by FieldPath.documentId(), the value provided must result in a valid document path, but '\" + s + \"' is not because it has an odd number of segments (\" + s.length + \").\");\n              r = new xr(this.firestore._databaseId, new mr(s));\n            } else {\n              if (!(n instanceof Fu)) throw new Sn(En.INVALID_ARGUMENT, \"Function Query.where() requires its third parameter to be a string or a DocumentReference if the first parameter is FieldPath.documentId(), but it was: \" + Un(n) + \".\");\n              var a = n;\n              r = new xr(this.firestore._databaseId, a._key);\n            }\n          } else r = this.firestore._dataConverter.parseQueryValue(\"Query.where\", n);\n\n          var u = Yr.create(i, o, r);\n          return this.validateNewFilter(u), new c(this._query.addFilter(u), this.firestore);\n        }, c.prototype.orderBy = function (t, e) {\n          var n;\n          if (_n(\"Query.orderBy\", arguments, 1, 2), Pn(\"Query.orderBy\", \"non-empty string\", 2, e), void 0 === e || \"asc\" === e) n = ti.ASCENDING;else {\n            if (\"desc\" !== e) throw new Sn(En.INVALID_ARGUMENT, \"Function Query.orderBy() has unknown direction '\" + e + \"', expected 'asc' or 'desc'.\");\n            n = ti.DESCENDING;\n          }\n          if (null !== this._query.startAt) throw new Sn(En.INVALID_ARGUMENT, \"Invalid query. You must not call Query.startAt() or Query.startAfter() before calling Query.orderBy().\");\n          if (null !== this._query.endAt) throw new Sn(En.INVALID_ARGUMENT, \"Invalid query. You must not call Query.endAt() or Query.endBefore() before calling Query.orderBy().\");\n          var r = ku(\"Query.orderBy\", t),\n              i = new ni(r, n);\n          return this.validateNewOrderBy(i), new c(this._query.addOrderBy(i), this.firestore);\n        }, c.prototype.limit = function (t) {\n          if (Rn(\"Query.limit\", arguments, 1), On(\"Query.limit\", \"number\", 1, t), t <= 0) throw new Sn(En.INVALID_ARGUMENT, \"Invalid Query. Query limit (\" + t + \") is invalid. Limit must be positive.\");\n          return new c(this._query.withLimit(t), this.firestore);\n        }, c.prototype.startAt = function (t) {\n          for (var e = [], n = 1; n < arguments.length; n++) {\n            e[n - 1] = arguments[n];\n          }\n\n          Mn(\"Query.startAt\", arguments, 1);\n          var r = this.boundFromDocOrFields(\"Query.startAt\", t, e, !0);\n          return new c(this._query.withStartAt(r), this.firestore);\n        }, c.prototype.startAfter = function (t) {\n          for (var e = [], n = 1; n < arguments.length; n++) {\n            e[n - 1] = arguments[n];\n          }\n\n          Mn(\"Query.startAfter\", arguments, 1);\n          var r = this.boundFromDocOrFields(\"Query.startAfter\", t, e, !1);\n          return new c(this._query.withStartAt(r), this.firestore);\n        }, c.prototype.endBefore = function (t) {\n          for (var e = [], n = 1; n < arguments.length; n++) {\n            e[n - 1] = arguments[n];\n          }\n\n          Mn(\"Query.endBefore\", arguments, 1);\n          var r = this.boundFromDocOrFields(\"Query.endBefore\", t, e, !0);\n          return new c(this._query.withEndAt(r), this.firestore);\n        }, c.prototype.endAt = function (t) {\n          for (var e = [], n = 1; n < arguments.length; n++) {\n            e[n - 1] = arguments[n];\n          }\n\n          Mn(\"Query.endAt\", arguments, 1);\n          var r = this.boundFromDocOrFields(\"Query.endAt\", t, e, !1);\n          return new c(this._query.withEndAt(r), this.firestore);\n        }, c.prototype.isEqual = function (t) {\n          if (!(t instanceof c)) throw jn(\"isEqual\", \"Query\", 1, t);\n          return this.firestore === t.firestore && this._query.isEqual(t._query);\n        }, c.prototype.boundFromDocOrFields = function (t, e, n, r) {\n          if (Qn(t, 1, e), e instanceof Bu) {\n            if (0 < n.length) throw new Sn(En.INVALID_ARGUMENT, \"Too many arguments provided to \" + t + \"().\");\n            var i = e;\n            if (!i.exists) throw new Sn(En.NOT_FOUND, \"Can't use a DocumentSnapshot that doesn't exist for \" + t + \"().\");\n            return this.boundFromDocument(t, i._document, r);\n          }\n\n          var o = [e].concat(n);\n          return this.boundFromFields(t, o, r);\n        }, c.prototype.boundFromDocument = function (t, e, n) {\n          for (var r = [], i = 0, o = this._query.orderBy; i < o.length; i++) {\n            var s = o[i];\n            if (s.field.isKeyField()) r.push(new xr(this.firestore._databaseId, e.key));else {\n              var a = e.field(s.field);\n              if (a instanceof Pr) throw new Sn(En.INVALID_ARGUMENT, 'Invalid query. You are trying to start or end a query using a document for which the field \"' + s.field + '\" is an uncommitted server timestamp. (Since the value of this field is unknown, you cannot start/end a query with it.)');\n\n              if (void 0 === a) {\n                var u = s.field.canonicalString();\n                throw new Sn(En.INVALID_ARGUMENT, \"Invalid query. You are trying to start or end a query using a document for which the field '\" + u + \"' (used as the orderBy) does not exist.\");\n              }\n\n              r.push(a);\n            }\n          }\n\n          return new ei(r, n);\n        }, c.prototype.boundFromFields = function (t, e, n) {\n          var r = this._query.explicitOrderBy;\n          if (e.length > r.length) throw new Sn(En.INVALID_ARGUMENT, \"Too many arguments provided to \" + t + \"(). The number of arguments must be less than or equal to the number of Query.orderBy() clauses\");\n\n          for (var i = [], o = 0; o < e.length; o++) {\n            var s = e[o];\n\n            if (r[o].field.isKeyField()) {\n              if (\"string\" != typeof s) throw new Sn(En.INVALID_ARGUMENT, \"Invalid query. Expected a string for document ID in \" + t + \"(), but got a \" + typeof s);\n              if (!this._query.isCollectionGroupQuery() && -1 !== s.indexOf(\"/\")) throw new Sn(En.INVALID_ARGUMENT, \"Invalid query. When querying a collection and ordering by FieldPath.documentId(), the value passed to \" + t + \"() must be a plain document ID, but '\" + s + \"' contains a slash.\");\n\n              var a = this._query.path.child(fr.fromString(s));\n\n              if (!mr.isDocumentKey(a)) throw new Sn(En.INVALID_ARGUMENT, \"Invalid query. When querying a collection group and ordering by FieldPath.documentId(), the value passed to \" + t + \"() must result in a valid document path, but '\" + a + \"' is not because it contains an odd number of segments.\");\n              var u = new mr(a);\n              i.push(new xr(this.firestore._databaseId, u));\n            } else {\n              var c = this.firestore._dataConverter.parseQueryValue(t, s);\n\n              i.push(c);\n            }\n          }\n\n          return new ei(i, n);\n        }, c.prototype.onSnapshot = function () {\n          for (var t = [], e = 0; e < arguments.length; e++) {\n            t[e] = arguments[e];\n          }\n\n          _n(\"Query.onSnapshot\", arguments, 1, 4);\n\n          var n,\n              r = {},\n              i = 0;\n          return \"object\" != typeof t[i] || hu(t[i]) || (Kn(\"Query.onSnapshot\", r = t[i], [\"includeMetadataChanges\"]), xn(\"Query.onSnapshot\", \"boolean\", \"includeMetadataChanges\", r.includeMetadataChanges), i++), n = hu(t[i]) ? t[i] : (On(\"Query.onSnapshot\", \"function\", i, t[i]), Pn(\"Query.onSnapshot\", \"function\", i + 1, t[i + 1]), Pn(\"Query.onSnapshot\", \"function\", i + 2, t[i + 2]), {\n            next: t[i],\n            error: t[i + 1],\n            complete: t[i + 2]\n          }), this.onSnapshotInternal(r, n);\n        }, c.prototype.onSnapshotInternal = function (t, e) {\n          var n = this,\n              r = function r(t) {\n            console.error(\"Uncaught Error in onSnapshot:\", t);\n          };\n\n          e.error && (r = e.error.bind(e));\n          var i = new nu({\n            next: function next(t) {\n              e.next && e.next(new Ku(n.firestore, n._query, t));\n            },\n            error: r\n          }),\n              o = this.firestore.ensureClientConfigured(),\n              s = o.listen(this._query, i, t);\n          return function () {\n            i.mute(), o.unlisten(s);\n          };\n        }, c.prototype.get = function (n) {\n          var r = this;\n          return _n(\"Query.get\", arguments, 0, 1), zu(\"Query.get\", n), new Promise(function (e, t) {\n            n && \"cache\" === n.source ? r.firestore.ensureClientConfigured().getDocumentsFromLocalCache(r._query).then(function (t) {\n              e(new Ku(r.firestore, r._query, t));\n            }, t) : r.getViaSnapshotListener(e, t, n);\n          });\n        }, c.prototype.getViaSnapshotListener = function (e, n, r) {\n          var i = this.onSnapshotInternal({\n            includeMetadataChanges: !0,\n            waitForSyncWhenOnline: !0\n          }, {\n            next: function next(t) {\n              i(), t.metadata.fromCache && r && \"server\" === r.source ? n(new Sn(En.UNAVAILABLE, 'Failed to get documents from server. (However, these documents may exist in the local cache. Run again without setting source to \"server\" to retrieve the cached documents.)')) : e(t);\n            },\n            error: n\n          });\n        }, c.prototype.validateNewFilter = function (t) {\n          if (t instanceof Jr) if (t.isInequality()) {\n            var e = this._query.getInequalityFilterField();\n\n            if (null !== e && !e.isEqual(t.field)) throw new Sn(En.INVALID_ARGUMENT, \"Invalid query. All where filters with an inequality (<, <=, >, or >=) must be on the same field. But you have inequality filters on '\" + e.toString() + \"' and '\" + t.field.toString() + \"'\");\n\n            var n = this._query.getFirstOrderByField();\n\n            null !== n && this.validateOrderByAndInequalityMatch(t.field, n);\n          } else if (t.op === Xr.ARRAY_CONTAINS && this._query.hasArrayContainsFilter()) throw new Sn(En.INVALID_ARGUMENT, \"Invalid query. Queries only support a single array-contains filter.\");\n        }, c.prototype.validateNewOrderBy = function (t) {\n          if (null === this._query.getFirstOrderByField()) {\n            var e = this._query.getInequalityFilterField();\n\n            null !== e && this.validateOrderByAndInequalityMatch(e, t.field);\n          }\n        }, c.prototype.validateOrderByAndInequalityMatch = function (t, e) {\n          if (!e.isEqual(t)) throw new Sn(En.INVALID_ARGUMENT, \"Invalid query. You have a where filter with an inequality (<, <=, >, or >=) on field '\" + t.toString() + \"' and so you must also use '\" + t.toString() + \"' as your first Query.orderBy(), but your first Query.orderBy() is on field '\" + e.toString() + \"' instead.\");\n        }, c;\n      }(),\n          Ku = function () {\n        function e(t, e, n) {\n          this._firestore = t, this._originalQuery = e, this._snapshot = n, this._cachedChanges = null, this._cachedChangesIncludeMetadataChanges = null, this.metadata = new Vu(n.hasPendingWrites, n.fromCache);\n        }\n\n        return Object.defineProperty(e.prototype, \"docs\", {\n          get: function get() {\n            var e = [];\n            return this.forEach(function (t) {\n              return e.push(t);\n            }), e;\n          },\n          enumerable: !0,\n          configurable: !0\n        }), Object.defineProperty(e.prototype, \"empty\", {\n          get: function get() {\n            return this._snapshot.docs.isEmpty();\n          },\n          enumerable: !0,\n          configurable: !0\n        }), Object.defineProperty(e.prototype, \"size\", {\n          get: function get() {\n            return this._snapshot.docs.size;\n          },\n          enumerable: !0,\n          configurable: !0\n        }), e.prototype.forEach = function (e, n) {\n          var r = this;\n          _n(\"QuerySnapshot.forEach\", arguments, 1, 2), On(\"QuerySnapshot.forEach\", \"function\", 1, e), this._snapshot.docs.forEach(function (t) {\n            e.call(n, r.convertToDocumentImpl(t));\n          });\n        }, Object.defineProperty(e.prototype, \"query\", {\n          get: function get() {\n            return new Qu(this._originalQuery, this._firestore);\n          },\n          enumerable: !0,\n          configurable: !0\n        }), e.prototype.docChanges = function (t) {\n          t && (Kn(\"QuerySnapshot.docChanges\", t, [\"includeMetadataChanges\"]), xn(\"QuerySnapshot.docChanges\", \"boolean\", \"includeMetadataChanges\", t.includeMetadataChanges));\n          var e = !(!t || !t.includeMetadataChanges);\n          if (e && this._snapshot.excludesMetadataChanges) throw new Sn(En.INVALID_ARGUMENT, \"To include metadata changes with your document changes, you must also pass { includeMetadataChanges:true } to onSnapshot().\");\n          return this._cachedChanges && this._cachedChangesIncludeMetadataChanges === e || (this._cachedChanges = function (i, e, o) {\n            {\n              if (o.oldDocs.isEmpty()) {\n                var n,\n                    r = 0;\n                return o.docChanges.map(function (t) {\n                  var e = new Uu(i, t.doc.key, t.doc, o.fromCache, o.mutatedKeys.has(t.doc.key));\n                  return vn(t.type === Ui.Added, \"Invalid event type for first snapshot\"), vn(!n || o.query.docComparator(n, t.doc) < 0, \"Got added events in wrong order\"), n = t.doc, {\n                    type: \"added\",\n                    doc: e,\n                    oldIndex: -1,\n                    newIndex: r++\n                  };\n                });\n              }\n\n              var s = o.oldDocs;\n              return o.docChanges.filter(function (t) {\n                return e || t.type !== Ui.Metadata;\n              }).map(function (t) {\n                var e = new Uu(i, t.doc.key, t.doc, o.fromCache, o.mutatedKeys.has(t.doc.key)),\n                    n = -1,\n                    r = -1;\n                return t.type !== Ui.Added && (vn(0 <= (n = s.indexOf(t.doc.key)), \"Index for document not found\"), s = s.delete(t.doc.key)), t.type !== Ui.Removed && (s = s.add(t.doc), r = s.indexOf(t.doc.key)), {\n                  type: function (t) {\n                    switch (t) {\n                      case Ui.Added:\n                        return \"added\";\n\n                      case Ui.Modified:\n                      case Ui.Metadata:\n                        return \"modified\";\n\n                      case Ui.Removed:\n                        return \"removed\";\n\n                      default:\n                        return gn(\"Unknown change type: \" + t);\n                    }\n                  }(t.type),\n                  doc: e,\n                  oldIndex: n,\n                  newIndex: r\n                };\n              });\n            }\n          }(this._firestore, e, this._snapshot), this._cachedChangesIncludeMetadataChanges = e), this._cachedChanges;\n        }, e.prototype.isEqual = function (t) {\n          if (!(t instanceof e)) throw jn(\"isEqual\", \"QuerySnapshot\", 1, t);\n          return this._firestore === t._firestore && this._originalQuery.isEqual(t._originalQuery) && this._snapshot.isEqual(t._snapshot);\n        }, e.prototype.convertToDocumentImpl = function (t) {\n          return new Uu(this._firestore, t.key, t, this.metadata.fromCache, this._snapshot.mutatedKeys.has(t.key));\n        }, e;\n      }();\n\n      [\"length\", \"forEach\", \"map\"].concat(\"undefined\" != typeof Symbol ? [Symbol.iterator] : []).forEach(function (t) {\n        try {\n          Object.defineProperty(Ku.prototype.docChanges, t, {\n            get: function get() {\n              return function () {\n                throw new Sn(En.INVALID_ARGUMENT, 'QuerySnapshot.docChanges has been changed from a property into a method, so usages like \"querySnapshot.docChanges\" should become \"querySnapshot.docChanges()\"');\n              }();\n            }\n          });\n        } catch (t) {}\n      });\n\n      var ju = function (r) {\n        function t(t, e) {\n          var n = r.call(this, Hr.atPath(t), e) || this;\n          if (t.length % 2 != 1) throw new Sn(En.INVALID_ARGUMENT, \"Invalid collection reference. Collection references must have an odd number of segments, but \" + t.canonicalString() + \" has \" + t.length);\n          return n;\n        }\n\n        return a(t, r), Object.defineProperty(t.prototype, \"id\", {\n          get: function get() {\n            return this._query.path.lastSegment();\n          },\n          enumerable: !0,\n          configurable: !0\n        }), Object.defineProperty(t.prototype, \"parent\", {\n          get: function get() {\n            var t = this._query.path.popLast();\n\n            return t.isEmpty() ? null : new Fu(new mr(t), this.firestore);\n          },\n          enumerable: !0,\n          configurable: !0\n        }), Object.defineProperty(t.prototype, \"path\", {\n          get: function get() {\n            return this._query.path.canonicalString();\n          },\n          enumerable: !0,\n          configurable: !0\n        }), t.prototype.doc = function (t) {\n          if (_n(\"CollectionReference.doc\", arguments, 0, 1), 0 === arguments.length && (t = zn.newId()), On(\"CollectionReference.doc\", \"non-empty string\", 1, t), \"\" === t) throw new Sn(En.INVALID_ARGUMENT, \"Document path must be a non-empty string\");\n          var e = fr.fromString(t);\n          return Fu.forPath(this._query.path.child(e), this.firestore);\n        }, t.prototype.add = function (t) {\n          Rn(\"CollectionReference.add\", arguments, 1), On(\"CollectionReference.add\", \"object\", 1, t);\n          var e = this.doc();\n          return e.set(t).then(function () {\n            return e;\n          });\n        }, t;\n      }(Qu);\n\n      function Wu(t, e) {\n        if (void 0 === e) return {\n          merge: !1\n        };\n        if (Kn(t, e, [\"merge\", \"mergeFields\"]), xn(t, \"boolean\", \"merge\", e.merge), qn(t, \"mergeFields\", \"a string or a FieldPath\", e.mergeFields, function (t) {\n          return \"string\" == typeof t || t instanceof ru;\n        }), void 0 !== e.mergeFields && void 0 !== e.merge) throw new Sn(En.INVALID_ARGUMENT, \"Invalid options passed to function \" + t + '(): You cannot specify both \"merge\" and \"mergeFields\".');\n        return e;\n      }\n\n      function Gu(t, e) {\n        return void 0 === e ? {} : (Kn(t, e, [\"serverTimestamps\"]), Fn(t, 0, \"serverTimestamps\", e.serverTimestamps, [\"estimate\", \"previous\", \"none\"]), e);\n      }\n\n      function zu(t, e) {\n        Pn(t, \"object\", 1, e), e && (Kn(t, e, [\"source\"]), Fn(t, 0, \"source\", e.source, [\"default\", \"server\", \"cache\"]));\n      }\n\n      function Hu(t, e, n) {\n        if (e instanceof Fu) {\n          if (e.firestore !== n) throw new Sn(En.INVALID_ARGUMENT, \"Provided document reference is from a different Firestore instance.\");\n          return e;\n        }\n\n        throw jn(t, \"DocumentReference\", 1, e);\n      }\n\n      var Yu = Tn(Lu, \"Use firebase.firestore() instead.\"),\n          Xu = Tn(xu, \"Use firebase.firestore().runTransaction() instead.\"),\n          Ju = Tn(qu, \"Use firebase.firestore().batch() instead.\"),\n          $u = Tn(Fu, \"Use firebase.firestore().doc() instead.\"),\n          Zu = Tn(Bu),\n          tc = Tn(Uu),\n          ec = Tn(Qu),\n          nc = Tn(Ku),\n          rc = Tn(ju, \"Use firebase.firestore().collection() instead.\"),\n          ic = {\n        Firestore: Yu,\n        GeoPoint: or,\n        Timestamp: sr,\n        Blob: ir,\n        Transaction: Xu,\n        WriteBatch: Ju,\n        DocumentReference: $u,\n        DocumentSnapshot: Zu,\n        Query: ec,\n        QueryDocumentSnapshot: tc,\n        QuerySnapshot: nc,\n        CollectionReference: rc,\n        FieldPath: ru,\n        FieldValue: bu,\n        setLogLevel: Lu.setLogLevel,\n        CACHE_SIZE_UNLIMITED: _u\n      };\n\n      function oc(t) {\n        t.INTERNAL.registerService(\"firestore\", function (t) {\n          return new Lu(t);\n        }, function (t) {\n          vn(t && \"object\" == typeof t, \"shallowCopy() expects object parameter.\");\n          var e = {};\n\n          for (var n in t) {\n            Object.prototype.hasOwnProperty.call(t, n) && (e[n] = t[n]);\n          }\n\n          return e;\n        }(ic));\n      }\n\n      oc(sc);\n    }).apply(this, arguments);\n  } catch (t) {\n    throw console.error(t), new Error(\"Cannot instantiate firebase-firestore - be sure to load firebase-app.js first.\");\n  }\n});","map":null,"metadata":{},"sourceType":"script"}